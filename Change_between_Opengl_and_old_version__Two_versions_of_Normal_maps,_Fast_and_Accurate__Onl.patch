Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Projection/Camera.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Projection/Camera.java	(date 1566499660595)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Projection/Camera.java	(date 1566499660595)
@@ -0,0 +1,48 @@
+package com.jacobjacob.ttproject.OpenGL.Projection;
+
+import android.opengl.Matrix;
+
+public class Camera {
+
+
+    // Position the eye behind the origin.
+    float eyeX = 0.0f;
+    float eyeY = 0.0f;
+    float eyeZ = 1.5f;
+
+    // We are looking toward the distance
+    float lookX = 0.0f;
+    float lookY = 0.0f;
+    float lookZ = -5.0f;
+
+    // Set our up vector. This is where our head would be pointing were we holding the camera.
+    float upX = 0.0f;
+    float upY = 1.0f;
+    float upZ = 0.0f;
+
+    /**
+     * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space;
+     * it positions things relative to our eye.
+     */
+    private float[] mViewMatrix = new float[16];
+
+    public Camera(float x, float y, float z){
+
+        this.eyeX = x;
+        this.eyeY = y;
+        this.eyeZ = z;
+
+        // Set the view matrix. This matrix can be said to represent the camera position.
+        // NOTE: In OpenGL 1, a ModelView matrix is used, which is a combination of a model and
+        // view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose.
+
+    }
+
+    public void ChangePosition(int x, int y, int z){
+        this.eyeX += x;
+        this.eyeY += y;
+        this.eyeZ += z;
+    }
+
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Load/LoadTexture.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Load/LoadTexture.java	(date 1566820528357)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Load/LoadTexture.java	(date 1566820528357)
@@ -0,0 +1,487 @@
+package com.jacobjacob.ttproject.OpenGL.Load;
+
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.LightingColorFilter;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.opengl.GLES20;
+import android.opengl.GLUtils;
+
+import com.jacobjacob.ttproject.R;
+import com.jacobjacob.ttproject.Vector;
+
+import java.util.ArrayList;
+
+import static com.jacobjacob.ttproject.Util.CONTEXT;
+import static com.jacobjacob.ttproject.Util.MATERIALARRAY;
+import static com.jacobjacob.ttproject.Util.MATERIALLIST;
+import static com.jacobjacob.ttproject.Util.MATERIALLISTUPDATING;
+import static com.jacobjacob.ttproject.Util.MATERIALNORMALS;
+import static com.jacobjacob.ttproject.Util.PLACETILE;
+import static com.jacobjacob.ttproject.Util.TEXTUREWIDTH;
+import static com.jacobjacob.ttproject.Util.TILELAYER;
+import static com.jacobjacob.ttproject.Util.TILELAYERSTART;
+import static com.jacobjacob.ttproject.Util.TILESIZE;
+import static com.jacobjacob.ttproject.Util.TILESIZEORIGINAL;
+import static com.jacobjacob.ttproject.Util.TILESIZETEXTURE;
+import static com.jacobjacob.ttproject.Util.TILESOFSINGLEKIND;
+
+
+public class LoadTexture { //rgb
+
+    private ArrayList<Bitmap> Bitmaplist;
+    ArrayList<Bitmap> RGBTilesLAYER1 = new ArrayList<>();
+    ArrayList<Bitmap> RGBTilesLAYER2 = new ArrayList<>();
+    ArrayList<Bitmap> RGBTilesLAYER3 = new ArrayList<>();
+
+    private Bitmap texture;
+    private Bitmap Tilemapbmp;  //from source as bmp
+
+    Rect SrcDst = new Rect(0, 0, TILESIZE, TILESIZE);
+
+
+    public LoadTexture() {
+        Bitmaplist = new ArrayList<>();
+
+        MATERIALLIST = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
+        MATERIALNORMALS = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
+
+        Bitmap LayerR, LayerG, LayerB;
+
+        Paint paint = new Paint();
+        int Pixel;
+
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inScaled = false;
+
+        Tilemapbmp = BitmapFactory.decodeResource(CONTEXT.getResources(), R.drawable.tilemap, options);
+
+        TILESIZE = Tilemapbmp.getWidth() / TEXTUREWIDTH;
+        TILESIZETEXTURE = TILESIZE; // The size of the source // if the camera is to far away, the source needs to get scaled accordingly to make it run faster with 10000 Tiles on the screen
+
+        for (int row = 0; row < TEXTUREWIDTH; row++) {
+            for (int column = 0; column < TEXTUREWIDTH; column++) {
+
+                LayerR = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+                LayerG = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+                LayerB = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+                texture = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+
+                Canvas canvasLayerR = new Canvas(LayerR);
+                Canvas canvasLayerG = new Canvas(LayerG);
+                Canvas canvasLayerB = new Canvas(LayerB);
+                Canvas canvastexture = new Canvas(texture);
+
+                for (int i = 0; i < TILESIZEORIGINAL; i++) {
+                    int X1 = (int) ((i * TILESIZE) / TILESIZEORIGINAL);
+                    int X2 = (int) (((i + 1) * TILESIZE) / TILESIZEORIGINAL);
+
+                    for (int j = 0; j < TILESIZEORIGINAL; j++) {
+                        int Y1 = (int) ((j * TILESIZE) / TILESIZEORIGINAL);
+                        int Y2 = (int) (((j + 1) * TILESIZE) / TILESIZEORIGINAL);
+
+
+                        int PixelX = (int) ((column * TILESIZE + i * TILESIZE / TILESIZEORIGINAL));
+                        int PixelY = (int) ((row * TILESIZE + j * TILESIZE / TILESIZEORIGINAL));
+
+                        Pixel = Tilemapbmp.getPixel(PixelX, PixelY);
+
+                        int A = Color.alpha(Pixel);
+                        int R = Color.red(Pixel);
+                        int G = Color.green(Pixel);
+                        int B = Color.blue(Pixel);
+                        if (R < 20) {
+                            R = 0;
+                        }
+                        if (G < 20) {
+                            G = 0;
+                        }
+                        if (B < 20) {
+                            B = 0;
+                        }
+                        paint.setColor(Color.argb(R, R, R, R));
+                        canvasLayerR.drawRect(X1, Y1, X2, Y2, paint);
+
+                        paint.setColor(Color.argb(G, G, G, G));
+                        canvasLayerG.drawRect(X1, Y1, X2, Y2, paint);
+
+                        paint.setColor(Color.argb(B, B, B, B));
+                        canvasLayerB.drawRect(X1, Y1, X2, Y2, paint);
+                        paint.setColor(Color.argb(A, R, G, B));
+                        canvastexture.drawRect(X1, Y1, X2, Y2, paint);
+                    }
+                }
+                RGBTilesLAYER1.add(LayerR);
+                RGBTilesLAYER2.add(LayerG);
+                RGBTilesLAYER3.add(LayerB);
+                Bitmaplist.add(texture);
+            }
+        }
+    }
+
+
+    /**
+     * This method rotates a Bitmap
+     *
+     * @param Input   the bitmap that should be rotated
+     * @param Degrees the amount of rotation
+     * @return the rotated bitmap
+     */
+    private Bitmap Rotate(Bitmap Input, int Degrees) {
+        Matrix matrix = new Matrix();
+        matrix.postRotate(Degrees);
+        Bitmap scaledBitmap = Bitmap.createScaledBitmap(Input, Input.getWidth(), Input.getHeight(), true);
+        return /* Bitmap rotatedBitmap = */Bitmap.createBitmap(scaledBitmap, 0, 0, scaledBitmap.getWidth(), scaledBitmap.getHeight(), matrix, true);
+    }
+
+    /**
+     * This method Overlays two Bitmaps
+     *
+     * @param Bottom The first bitmap on the bottom
+     * @param Top    The second Bitmap that gets drawn on top of the first one
+     * @return
+     */
+    private Bitmap OverlayTilemap(Bitmap Bottom, Bitmap Top) {
+
+        Bitmap Out = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+        Canvas Output = new Canvas();
+        Output.setBitmap(Out);
+        Output.drawBitmap(Bottom, SrcDst, SrcDst, null);
+        Output.drawBitmap(Top, SrcDst, SrcDst, null);
+
+        return Out;
+    }
+
+    /**
+     * Returns a bmp of a Bitmap with fitting ID and Material
+     *
+     * @param ID          The Id of the Bitmap / can range from 0 to 15
+     * @param MATERIALint The Material the Texture has
+     * @return
+     */
+    public void getTexture(int ID, int MATERIALint) { // no animations possible yet
+
+        if (!PLACETILE/*MATERIALNORMALS[MATERIALint] != null && MATERIALint * 5 < Bitmaplist.size() && MATERIALARRAY[MATERIALint].showNormal()*/) {
+            try {
+                //return MATERIALNORMALS[MATERIALint][ID];
+            } catch (Exception e) {
+            }
+        }
+
+
+        if (MATERIALLIST != null && MATERIALLIST[MATERIALint] != null && ID < MATERIALLIST[MATERIALint].length) {
+
+            // Bind to the texture in OpenGL
+            final int[] textureHandle = new int[1];
+            GLES20.glGenTextures(1, textureHandle, 0);
+
+
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[0]);
+
+            // Set filtering
+            GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
+            GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);
+
+            // Load the bitmap into the bound texture.
+            GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, MATERIALLIST[MATERIALint][ID], 0);
+
+            // Recycle the bitmap, since its data has been loaded into OpenGL.
+            //bitmap.recycle();
+
+            //return ;/*/return Materiallist.get(ID)[MATERIALint];/**/
+
+        } else {
+            //return null;
+        }
+    }
+
+    /**
+     * Returns the Bitmap of a specific Layer to make the quick selection screen possible.
+     * It does not take in an ID, the ID equals 15 / the bottom Tile
+     *
+     * @param MATERIALint The Material we want the Bitmap of a specific Layer from
+     * @return a grey Bitmap
+     */
+    public Bitmap getBitmap(int MATERIALint) { // no animations possible yet
+        // Material
+        if (MATERIALint >= 0) {
+            if (MATERIALARRAY[MATERIALint] != null && MATERIALint * 5 < Bitmaplist.size()) {
+                if (TILELAYER == TILELAYERSTART + 1) {
+                    return RGBTilesLAYER1.get(MATERIALint * 5);
+                } else if (TILELAYER == TILELAYERSTART + 2) {
+                    return RGBTilesLAYER2.get(MATERIALint * 5);
+                } else if (TILELAYER == TILELAYERSTART + 3) {
+                    return RGBTilesLAYER3.get(MATERIALint * 5);
+                } else {
+                    return null;
+                }
+
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
+
+    public void CreateTilemap(int Material, int Layer1, int Layer2, int Layer3, int ColorLayer0, int ColorLayer1, int ColorLayer2, int ColorLayer3) { // needs more Options as input
+
+        Bitmap[] SingleTilemap = new Bitmap[15]; // Tiles from 0 to 15 as Bitmap
+        Paint paint = new Paint();
+        ColorFilter filter;
+
+        //Layer1 = 0;
+        //Layer2 = 0;
+        //Layer3 = 0;
+        if (Layer1 < 0) {
+            Layer1 = 0;
+        }
+        if (Layer2 < 0) {
+            Layer2 = 0;
+        }
+        if (Layer3 < 0) {
+            Layer3 = 0;
+        }
+        Layer1 *= TILESOFSINGLEKIND;
+        Layer2 *= TILESOFSINGLEKIND;
+        Layer3 *= TILESOFSINGLEKIND;
+
+        for (int i = 0; i < TILESOFSINGLEKIND; i++) { // i < 5 // all five starting tiles in grey
+
+            Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+            Canvas Currentcanvas = new Canvas();
+            Currentcanvas.setBitmap(Current);
+            if (i == 0) {
+                paint.setColor(ColorLayer0);
+                Currentcanvas.drawRect(SrcDst, paint);
+            }
+
+            filter = new LightingColorFilter(ColorLayer1, 0);
+            paint.setColorFilter(filter);
+            paint.setAlpha(Color.alpha(ColorLayer1));
+            Currentcanvas.drawBitmap(RGBTilesLAYER1.get(Layer1 + i), SrcDst, SrcDst, paint);
+
+            filter = new LightingColorFilter(ColorLayer2, 0);
+            paint.setColorFilter(filter);
+            paint.setAlpha(Color.alpha(ColorLayer2));
+            Currentcanvas.drawBitmap(RGBTilesLAYER2.get(Layer2 + i), SrcDst, SrcDst, paint);
+
+            filter = new LightingColorFilter(ColorLayer3, 0);
+            paint.setColorFilter(filter);
+            paint.setAlpha(Color.alpha(ColorLayer3));
+            Currentcanvas.drawBitmap(RGBTilesLAYER3.get(Layer3 + i), SrcDst, SrcDst, paint);
+            SingleTilemap[i] = Current;
+        }
+
+        Bitmap[] FinishedTilemap = getFinnishedBitmaplist(SingleTilemap);
+
+        for (int i = 0; i < FinishedTilemap.length; i++) {
+            FinishedTilemap[i] = OverlayTilemap(FinishedTilemap[15], FinishedTilemap[i]);
+        }
+        MATERIALLIST[Material] = FinishedTilemap; // updates all Tiles from a specific Material
+    }
+
+    public void UpdateTilemap(int Material, int Layer1, int Layer2, int Layer3, int ColorLayer0, int ColorLayer1, int ColorLayer2, int ColorLayer3) { // needs more Options as input
+
+        if (MATERIALLISTUPDATING == null) {
+            MATERIALLISTUPDATING = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
+        }
+
+        Bitmap[] SingleTilemap = new Bitmap[15]; // Tiles from 0 to 15 as Bitmap
+
+
+        Paint paint = new Paint();
+        ColorFilter filter;
+
+
+        if (Layer1 < 0) {
+            Layer1 = 0;
+        }
+        if (Layer2 < 0) {
+            Layer2 = 0;
+        }
+        if (Layer3 < 0) {
+            Layer3 = 0;
+        }
+
+
+        Layer1 *= TILESOFSINGLEKIND;
+        Layer2 *= TILESOFSINGLEKIND;
+        Layer3 *= TILESOFSINGLEKIND;
+
+        for (int i = 0; i < TILESOFSINGLEKIND; i++) { // i < 5 // all five starting tiles in grey
+
+            Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+            Canvas Currentcanvas = new Canvas();
+            Currentcanvas.setBitmap(Current);
+
+
+            filter = new LightingColorFilter(ColorLayer1, 0);
+            paint.setColorFilter(filter);
+            paint.setAlpha(Color.alpha(ColorLayer1));
+            Currentcanvas.drawBitmap(RGBTilesLAYER1.get(Layer1 + i), SrcDst, SrcDst, paint);
+
+            filter = new LightingColorFilter(ColorLayer2, 0);
+            paint.setColorFilter(filter);
+            paint.setAlpha(Color.alpha(ColorLayer2));
+            Currentcanvas.drawBitmap(RGBTilesLAYER2.get(Layer2 + i), SrcDst, SrcDst, paint);
+
+            filter = new LightingColorFilter(ColorLayer3, 0);
+            paint.setColorFilter(filter);
+            paint.setAlpha(Color.alpha(ColorLayer3));
+            Currentcanvas.drawBitmap(RGBTilesLAYER3.get(Layer3 + i), SrcDst, SrcDst, paint);
+            SingleTilemap[i] = Current;
+        }
+
+        Bitmap[] FinishedTilemap = getFinnishedBitmaplist(SingleTilemap);
+
+        for (int i = 0; i < FinishedTilemap.length; i++) {
+            FinishedTilemap[i] = OverlayTilemap(FinishedTilemap[15], FinishedTilemap[i]);
+        }
+
+        MATERIALLISTUPDATING[Material] = FinishedTilemap; // updates all Tiles from a specific Material
+    }
+
+    private Bitmap[] getFinnishedBitmaplist(Bitmap[] SingleTilemap) {
+        Bitmap[] FinishedTilemap = new Bitmap[16];
+
+        FinishedTilemap[15] = SingleTilemap[0];
+        /**Need the Bottom underneath*/
+        FinishedTilemap[14] = SingleTilemap[4];
+        FinishedTilemap[13] = Rotate(SingleTilemap[4], 90);
+        FinishedTilemap[12] = Rotate(SingleTilemap[1], 90);
+        FinishedTilemap[11] = Rotate(SingleTilemap[4], 180);
+        FinishedTilemap[10] = OverlayTilemap(Rotate(SingleTilemap[4], 180), SingleTilemap[4]);
+        FinishedTilemap[9] = Rotate(SingleTilemap[1], 180);
+        FinishedTilemap[8] = Rotate(SingleTilemap[2], 90);
+        FinishedTilemap[7] = Rotate(SingleTilemap[4], 270);
+        FinishedTilemap[6] = SingleTilemap[1];
+        FinishedTilemap[5] = Rotate(FinishedTilemap[10], 90);
+        FinishedTilemap[4] = SingleTilemap[2];
+        FinishedTilemap[3] = Rotate(SingleTilemap[1], 270);
+        FinishedTilemap[2] = Rotate(SingleTilemap[2], 270);
+        FinishedTilemap[1] = Rotate(SingleTilemap[2], 180);
+        FinishedTilemap[0] = OverlayTilemap(SingleTilemap[3], Rotate(SingleTilemap[3], 90));
+        FinishedTilemap[0] = OverlayTilemap(FinishedTilemap[0], Rotate(FinishedTilemap[0], 180));
+        return FinishedTilemap;
+    }
+
+    public void CreateNormals(int intMaterial, int Layer1, int Layer2, int Layer3, int alpha1, int alpha2, int alpha3) {
+
+        Bitmap[] SingleTilemap = new Bitmap[15]; // Tiles from 0 to 15 as Bitmap
+        Paint paint = new Paint();
+
+        if (Layer1 < 0) {
+            Layer1 = 0;
+        }
+        if (Layer2 < 0) {
+            Layer2 = 0;
+        }
+        if (Layer3 < 0) {
+            Layer3 = 0;
+        }
+
+        Layer1 *= TILESOFSINGLEKIND;
+        Layer2 *= TILESOFSINGLEKIND;
+        Layer3 *= TILESOFSINGLEKIND;
+
+        for (int i = 0; i < TILESOFSINGLEKIND; i++) { // i < 5 // all five starting tiles in grey
+
+            Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+            Canvas Currentcanvas = new Canvas();
+            Currentcanvas.setBitmap(Current);
+
+            if (i == 0){
+                paint.setColor(Color.rgb(127,127,255)); // equals 0 0 1
+                //paint.setColor(Color.rgb(0,0,0)); // equals 0 0 1
+                Currentcanvas.drawRect(new Rect(0,0,TILESIZEORIGINAL,TILESIZEORIGINAL), paint);
+            }
+
+            for (int j = TILESIZEORIGINAL; j < TILESIZEORIGINAL * 2; j++) {
+                for (int k = TILESIZEORIGINAL; k < 2 * TILESIZEORIGINAL; k++) {
+
+
+                    int ColorLayerUP = 0;
+                    int ColorLayerDOWN = 0;
+                    int ColorLayerLEFT = 0;
+                    int ColorLayerRIGHT = 0;
+
+                    Bitmap Layer;
+                    float Alpha;
+
+                    for (int l = 0; l < 3; l++) {
+
+                        if (l == 0) {
+                            Layer = RGBTilesLAYER1.get(Layer1 + i);
+                            Alpha = alpha1;
+                        } else if (l == 1) {
+                            Layer = RGBTilesLAYER2.get(Layer2 + i);
+                            Alpha = alpha2;
+                        } else {
+                            Layer = RGBTilesLAYER2.get(Layer3 + i);
+                            Alpha = alpha3;
+                        }
+
+                        int jrelative = j % TILESIZEORIGINAL;
+                        int krelative = k % TILESIZEORIGINAL;
+
+                        ColorLayerUP += (int) (((Alpha / 255.0f)) * Color.red(Layer.getPixel(jrelative, (k - 1) % TILESIZEORIGINAL)));// takes the colorvalue of the three bitmaps at the same point
+
+                        ColorLayerDOWN += (int) (((Alpha / 255.0f)) * Color.red(Layer.getPixel(jrelative, (k + 1) % TILESIZEORIGINAL)));// takes the colorvalue of the three bitmaps at the same point
+
+                        ColorLayerLEFT += (int) (((Alpha / 255.0f)) * Color.red(Layer.getPixel((j - 1) % TILESIZEORIGINAL, krelative)));// takes the colorvalue of the three bitmaps at the same point
+
+                        ColorLayerRIGHT += (int) (((Alpha / 255.0f)) * Color.red(Layer.getPixel((j + 1) % TILESIZEORIGINAL, krelative)));// takes the colorvalue of the three bitmaps at the same point
+                    }
+
+                    Vector NormalVec;
+
+                    //NormalVec = (NormalVec.normalize()).multiplydouble(255);
+
+                    float Scale = alpha1 + alpha2 + alpha3;
+
+                    float Hor = (float) (-ColorLayerLEFT + ColorLayerRIGHT) / Scale; // value from 0 to 1
+                    float Ver = (float) (-ColorLayerUP + ColorLayerDOWN) / Scale; // value from 0 to 1
+
+                    float Sca = 1f;
+
+                    Vector vb = new Vector(Sca, 0,Hor).normalize();
+                    Vector va = new Vector(0, Sca,Ver).normalize();
+
+                    //va = new Vector(Hor, 0,Sca).normalize();
+                    //vb = new Vector(0, Ver,Sca).normalize();
+                    NormalVec = (va.cross(vb)).normalize();
+
+                    NormalVec = new Vector(NormalVec.getX(),NormalVec.getY(),Math.abs(NormalVec.getZ())).normalize();
+
+                    int red = (int) (255-((NormalVec.getX() + 1) * 127));
+                    int green = (int) (255-(NormalVec.getY() + 1) * 127);
+                    int blue =  (int) ((NormalVec.getZ() + 1) * 127);
+
+                    paint.setColor(Color.rgb(red, green, blue));
+                    //Currentcanvas.drawRect(j%TILESIZEORIGINAL, k%TILESIZEORIGINAL,j%TILESIZEORIGINAL+1,k%TILESIZEORIGINAL+1, paint);
+                    if ((red < 120 || red > 133) && (green < 120 || green > 133) && (blue < 120 || blue > 133)) {
+                        Currentcanvas.drawPoint(j % TILESIZEORIGINAL, k % TILESIZEORIGINAL, paint);
+                    }
+                }
+            }
+
+            SingleTilemap[i] = Current;
+        }
+
+
+        Bitmap[] FinishedTilemap = getFinnishedBitmaplist(SingleTilemap);
+
+        for (int i = 0; i < FinishedTilemap.length; i++) {
+            FinishedTilemap[i] = OverlayTilemap(FinishedTilemap[15], FinishedTilemap[i]);
+        }
+
+        MATERIALNORMALS[intMaterial] = FinishedTilemap;
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/vertextShader.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/vertextShader.txt	(date 1566752514920)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/vertextShader.txt	(date 1566752514920)
@@ -0,0 +1,11 @@
+#version 400 core
+
+in vec3 position;
+in vec2 textureCoords;
+out vec2 pass_texureCoords;
+
+void main(void){
+
+    gl_Position = vec4(position,1.0);
+    pass_texureCoords = textureCoords;
+}
\ No newline at end of file
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/MainSurfaceView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/MainSurfaceView.java	(date 1567883248750)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/MainSurfaceView.java	(date 1567883248750)
@@ -0,0 +1,54 @@
+package com.jacobjacob.ttproject.OpenGL;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.opengl.GLSurfaceView;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+
+import com.jacobjacob.ttproject.Input.CustomButtons;
+import com.jacobjacob.ttproject.OpenGL.Shapes.RawModel;
+import com.jacobjacob.ttproject.Vector;
+
+import java.nio.FloatBuffer;
+
+import static com.jacobjacob.ttproject.Util.CONTEXT;
+import static com.jacobjacob.ttproject.Util.CUSTOMBUTTONSLIST;
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+
+public class MainSurfaceView extends GLSurfaceView {
+
+    public static CustomButtons Joystick;
+    public static CustomButtons MoveUp;
+    public static CustomButtons MoveDown;
+    public static CustomButtons SELECTLEVEL;
+    public static CustomButtons SELECTOPENGL;
+    public static FloatBuffer vertexBuffer;
+
+    public static RawModel model;
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public MainSurfaceView(Context context) {
+        super(context);
+
+        CONTEXT = context;
+
+        Joystick = new CustomButtons(0, new Vector(0.2 * WIDTHSCREEN * 0.5, HEIGHTSCREEN * 0.8), (float) (WIDTHSCREEN * 0.15), (float) (WIDTHSCREEN * 0.15), Color.rgb(120, 120, 120));
+
+        MoveDown = new CustomButtons(1, new Vector(WIDTHSCREEN * 0.22f, HEIGHTSCREEN * 0.88f), (float) (WIDTHSCREEN * 0.05f), (float) (WIDTHSCREEN * 0.05f), Color.rgb(120, 120, 120));
+        MoveUp = new CustomButtons(2, new Vector(WIDTHSCREEN * 0.22f, HEIGHTSCREEN * 0.72f), (float) (WIDTHSCREEN * 0.05f), (float) (WIDTHSCREEN * 0.05f), Color.rgb(120, 120, 120));
+
+        SELECTLEVEL = new CustomButtons(3, new Vector(WIDTHSCREEN * 0.3f, HEIGHTSCREEN * 0.72f), (float) (WIDTHSCREEN * 0.1f), (float) (WIDTHSCREEN * 0.05f), Color.rgb(140, 120, 120));
+
+        SELECTOPENGL = new CustomButtons(4, new Vector(WIDTHSCREEN * 0.3f, HEIGHTSCREEN * 0.88f), (float) (WIDTHSCREEN * 0.1f), (float) (WIDTHSCREEN * 0.05f), Color.rgb(140, 120, 120));
+
+        CUSTOMBUTTONSLIST.add(Joystick);
+        CUSTOMBUTTONSLIST.add(MoveUp);
+        CUSTOMBUTTONSLIST.add(MoveDown);
+        CUSTOMBUTTONSLIST.add(SELECTLEVEL);
+        CUSTOMBUTTONSLIST.add(SELECTOPENGL);
+
+    }
+}
+
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/fragmentShader.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/fragmentShader.txt	(date 1566752715593)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/fragmentShader.txt	(date 1566752715593)
@@ -0,0 +1,13 @@
+#version400core
+
+in vec2 pass_textureCoords;
+
+out vec4 out_Color;
+
+uniform sampler2D textureSampler;
+
+void main(void){
+
+    out_Color = texture(textureSampler,pass_textureCoords);
+
+}
\ No newline at end of file
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/StaticShader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/StaticShader.java	(date 1566754603634)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/StaticShader.java	(date 1566754603634)
@@ -0,0 +1,20 @@
+package com.jacobjacob.ttproject.OpenGL.Shaders;
+
+import android.graphics.Shader;
+
+public class StaticShader extends ShaderProgram{
+
+    private static final String VERTEX_FILE = "com.jacobjacob.ttproject/OpenGL/Shaders/vertextShader.txt";
+    private static final String FRAGMENT_FILE = "com.jacobjacob.ttproject/OpenGL/Shaders/fragmentShader.txt";
+
+    public StaticShader(){
+        super(VERTEX_FILE,FRAGMENT_FILE);
+
+    }
+    @Override
+    protected void bindAttributes(){
+        super.bindAttribute(0,"position");
+        //super.bindAttribute(1,"textureCoords");
+    }
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/ShaderProgram.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/ShaderProgram.java	(date 1566754565913)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shaders/ShaderProgram.java	(date 1566754565913)
@@ -0,0 +1,82 @@
+package com.jacobjacob.ttproject.OpenGL.Shaders;
+
+import android.opengl.GLES20;
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.FileReader;
+
+import javax.microedition.khronos.opengles.GL11;
+
+public abstract class ShaderProgram {
+
+    private int programID;
+    private int vertextShaderID;
+    private int fragmentShaderID;
+
+    public ShaderProgram(String vertextFile, String fragmentFile){
+
+        vertextShaderID = loadShader(vertextFile,GLES20.GL_VERTEX_SHADER);
+        fragmentShaderID = loadShader(fragmentFile,GLES20.GL_FRAGMENT_SHADER);
+        programID = GLES20.glCreateProgram();
+        GLES20.glAttachShader(programID, vertextShaderID);
+        GLES20.glAttachShader(programID, fragmentShaderID);
+        GLES20.glLinkProgram(programID);
+        GLES20.glValidateProgram(programID);
+        bindAttributes();
+
+    }
+
+    public void start(){
+        GLES20.glUseProgram(programID);
+    }
+    public void stop(){
+        GLES20.glUseProgram(0);
+    }
+
+    public void CleanUp(){
+        stop();
+        GLES20.glDetachShader(programID,vertextShaderID);
+        GLES20.glDetachShader(programID,fragmentShaderID);
+        GLES20.glDeleteShader(vertextShaderID);
+        GLES20.glDeleteShader(fragmentShaderID);
+        GLES20.glDeleteProgram(programID);
+    }
+
+    protected abstract void bindAttributes();
+
+    protected void bindAttribute(int attribute,String variableName){
+        GLES20.glBindAttribLocation(programID,attribute,variableName);
+    }
+
+
+    private static int loadShader(String file, int type){
+        StringBuilder shaderSource = new StringBuilder();
+        try {
+
+
+            BufferedReader reader = new BufferedReader(new FileReader(file));
+            String line;
+
+            while ((line = reader.readLine()) != null) {
+                shaderSource.append(line).append("\n");
+            }reader.close();
+        }catch (Exception e){
+            Log.d("Reader: ", e.getMessage());
+            System.exit(-1);
+        }
+
+        int shaderID = GLES20.glCreateShader(type);
+        GLES20.glShaderSource(shaderID, String.valueOf(shaderSource));
+        GLES20.glCompileShader(shaderID);
+
+        if (GLES20.GL_COMPILE_STATUS == GL11.GL_FALSE){
+            //System.out.println(GLES20.glGetShaderInfoLog((int)shaderID,(int)500));
+            System.err.println("Could not Compile Shader");
+            System.exit(-1);
+        }
+
+        return shaderID;
+    }
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/MainRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/MainRenderer.java	(date 1567961631171)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/MainRenderer.java	(date 1567961631171)
@@ -0,0 +1,970 @@
+package com.jacobjacob.ttproject.OpenGL;
+
+import android.content.Context;
+import android.graphics.Color;
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+import android.opengl.Matrix;
+import android.os.SystemClock;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+
+import com.jacobjacob.ttproject.Input.CustomButtons;
+import com.jacobjacob.ttproject.Light.PointLight;
+import com.jacobjacob.ttproject.Tile.Tile;
+import com.jacobjacob.ttproject.Vector;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.util.ArrayList;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+
+import static com.jacobjacob.ttproject.Util.BACKGROUNDCOLOR;
+import static com.jacobjacob.ttproject.Util.CUSTOMBUTTONSLIST;
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.KDTREE;
+import static com.jacobjacob.ttproject.Util.TILESIZE;
+import static com.jacobjacob.ttproject.Util.TILETEXTURE;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+import static com.jacobjacob.ttproject.Util.ZOOMFACTOR;
+import static com.jacobjacob.ttproject.Util.camera;
+
+
+public class MainRenderer extends AppCompatActivity implements GLSurfaceView.Renderer {
+    Context context;
+
+
+    public MainRenderer(Context context) {
+        this.context = context;
+    }
+
+    /**
+     * Store the model matrix. This matrix is used to move models from object space (where each model can be thought
+     * of being located at the center of the universe) to world space.
+     */
+    private float[] mModelMatrix = new float[16];
+
+    /**
+     * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space;
+     * it positions things relative to our eye.
+     */
+    private float[] mViewMatrix = new float[16];
+
+    /**
+     * Store the projection matrix. This is used to project the scene onto a 2D viewport.
+     */
+    private float[] mProjectionMatrix = new float[16];
+
+    /**
+     * Allocate storage for the final combined matrix. This will be passed into the shader program.
+     */
+    private float[] mMVPMatrix = new float[16];
+
+    /**
+     * Store our model data in a float buffer.
+     */
+
+    /**
+     * This will be used to pass in the transformation matrix.
+     */
+    private int mMVPMatrixHandle;
+
+    /**
+     * This will be used to pass in model position information.
+     */
+    private int mPositionHandle;
+
+    /**
+     * This will be used to pass in model color information.
+     */
+    private int mColorHandle;
+
+    /**
+     * How many bytes per float.
+     */
+    private final int mBytesPerFloat = 4;
+
+    /**
+     * How many elements per vertex.
+     */
+    private final int mStrideBytes = 7 * mBytesPerFloat; // xyzrgba
+
+    /**
+     * Offset of the position data.
+     */
+    private final int mPositionOffset = 0;
+
+    /**
+     * Size of the position data in elements.
+     */
+    private final int mPositionDataSize = 3;
+
+    /**
+     * Offset of the color data.
+     */
+    private final int mColorOffset = 3;
+
+    /**
+     * Size of the color data in elements.
+     */
+    private final int mColorDataSize = 4;
+
+    final String vertexShader = "uniform mat4 u_MVPMatrix;      \n"        // A constant representing the combined model/view/projection matrix.
+
+            + "attribute vec4 a_Position;     \n"                          // Per-vertex position information we will pass in.
+            + "attribute vec4 a_Color;        \n"                          // Per-vertex color information we will pass in.
+
+            + "varying vec4 v_Color;          \n"                          // This will be passed into the fragment shader.
+
+            + "void main()                    \n"                          // The entry point for our vertex shader.
+            + "{                              \n" + "   v_Color = a_Color;          \n"        // Pass the color through to the fragment shader.
+            // It will be interpolated across the triangle.
+            + "   gl_Position = u_MVPMatrix   \n"                          // gl_Position is a special variable used to store the final position.
+            + "               * a_Position;   \n"                          // Multiply the vertex by the matrix to get the final point in
+            + "}                              \n";                         // normalized screen coordinates.
+
+    final String fragmentShader = "precision mediump float;       \n"      // Set the default precision to medium. We don't need as high of a
+            // precision in the fragment shader.
+            + "varying vec4 v_Color;          \n"                          // This is the color from the vertex shader interpolated across the
+            // triangle per fragment.
+            + "void main()                    \n"                          // The entry point for our fragment shader.
+            + "{                              \n" + "   gl_FragColor = v_Color;     \n"        // Pass the color directly through the pipeline.
+            + "}                              \n";
+
+    /*/
+        final String per_pixel_vertex_shader =
+                "uniform mat4 u_MVPMatrix;"// A constant representing the combined model/view/projection matrix.
+                + "uniform mat4 u_MVMatrix;" + "\n"// A constant representing the combined model/view matrix.
+                + "attribute vec4 a_Position;" + "\n"// Per-vertex position information we will pass in.
+                + "attribute vec2 a_TexCoordinate;" + "\n" // Per-vertex texture coordinate information we will pass in.
+
+                + "varying vec3 v_Position;" + "\n"// This will be passed into the fragment shader.
+
+
+                + "attribute vec3 a_Light;" + "\n"         // Vector from the Light to the Tile
+
+                + "varying vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+
+
+                //+ "varying vec3 v_Normal;" + "\n"// This will be passed into the fragment shader.
+                + "varying vec2 v_TexCoordinate;" + "\n"   // This will be passed into the fragment shader.
+                // The entry point for our vertex shader.
+
+                + "void main()\n" + "{\n"
+                // Transform the vertex into eye space.
+                + "v_Position = vec3(u_MVMatrix * a_Position);\n"
+                // Pass through the texture coordinate.
+                + "v_TexCoordinate = a_TexCoordinate;\n"
+
+                + "v_Light = a_Light;"
+
+                // Transform the normal's orientation into eye space.
+                //+ "    v_Normal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));\n"
+                // gl_Position is a special variable used to store the final position.
+                // Multiply the vertex by the matrix to get the final point in normalized screen coordinates.
+                + "gl_Position = u_MVPMatrix * a_Position;\n" + "}";
+        /**/
+    final String per_pixel_vertex_shader = "uniform mat4 u_MVPMatrix;" + "uniform mat4 u_MVMatrix;" + "\n"
+
+            + "attribute vec4 a_Position;" + "\n" + "varying vec3 v_Position;" + "\n"
+
+            + "attribute vec2 a_TexCoordinate;" + "\n" + "varying vec2 v_TexCoordinate;" + "\n"
+
+            //+ "attribute vec3 a_Light;" + "\n"
+            //+ "varying vec3 v_Light;" + "\n"
+
+
+            + "void main()\n" + "{\n"
+
+            + "v_Position = vec3(u_MVMatrix * a_Position);\n"
+
+            //+ "v_Light = a_Light;\n"
+
+            + "v_TexCoordinate = a_TexCoordinate;\n"
+
+            + "gl_Position = u_MVPMatrix * a_Position;\n"
+
+            + "}";
+
+/*/
+    final String per_pixel_fragment_shader =
+            "precision mediump float;" +
+            // Set the default precision to medium. We don't need as high of a
+            // precision in the fragment shader.
+            "uniform vec3 u_LightPos;\n"          // The position of the light in eye space.
+            + "uniform sampler2D u_Texture;\n"    // The input texture
+            + "varying vec3 v_Position;\n"        // Interpolated position for this fragment.
+            + "varying vec4 v_Color;\n"           // This is the color from the vertex shader interpolated across the triangle per fragment.
+            + "varying vec3 v_Normal;\n"
+                                                  // Interpolated normal for this fragment.
+            + "varying vec2 v_TexCoordinate;\n"
+                                                  // Interpolated texture coordinate per fragment.
+                                                  // The entry point for our fragment shader.
+            + "void main()" + "{\n"
+                                                  // Will be used for attenuation.
+            + "float distance = length(u_LightPos - v_Position);\n"
+            // Get a lighting direction vector from the light to the vertex.
+            + "vec3 lightVector = normalize(u_LightPos - v_Position);\n"
+            // Calculate the dot product of the light vector and vertex normal. If the normal and light vector are
+            // pointing in the same direction then it will get max illumination.
+            + "float diffuse = max(dot(v_Normal, lightVector), 0.0);\n"
+          // Add attenuation.
+            + "diffuse = diffuse * (1.0 / (1.0 + (0.10 * distance)));\n"
+          // Add ambient lighting
+            + "diffuse = diffuse + 0.3;  \n"
+            // Multiply the color by the diffuse illumination level and texture value to get final output color.
+            + "gl_FragColor = (texture2D(u_Texture, v_TexCoordinate));\n"
+            + "}";
+/**/
+
+/*/
+    final String per_pixel_fragment_shader =
+            "precision mediump float;"
+                    + "uniform sampler2D u_Texture;\n"    // The input texture
+                    + "uniform sampler2D n_Texture;\n"
+                    + "varying vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+                    + "varying vec2 v_TexCoordinate;\n"  // interpolated Texture coordinate same for texture and normaltexture
+                    + "float brightness;" + "\n"
+
+                    + "void main()" + "{\n"
+                    //+ "vec3 vec_normalTex = normalize(vec3(texture2D(n_Texture, v_TexCoordinate))-0.5);" +"\n"
+                    + "vec3 vec_normalTex = (vec3(texture2D(n_Texture, v_TexCoordinate))-0.5);" +"\n"
+                    //+ "vec4 vec_normalTex = (texture2D(n_Texture, v_TexCoordinate)-0.5)*2;" +"\n"
+                    //+ "vec3 vec_normal = normalize(texture2D(n_Texture, v_TexCoordinate)-0.5);" + "\n" // normalized normal of the pixel / fragment
+
+                   // + "float brightness = 0.5;" + "\n"
+                    + "float dist = (length(v_Light.xyz));" + "\n"
+                    //+ "brightness = dot(normalize(v_Light),vec_normalTex);" + "\n"
+                    + "brightness = dot(v_Light,vec_normalTex);" + "\n"
+
+                    + "brightness = ((0.8 * brightness * (1.0 / dist)) + 0.2);" + "\n"
+                    //+ "gl_FragColor = (texture2D(u_Texture, v_TexCoordinate)) * brightness;\n"
+
+                    + "gl_FragColor =  texture2D(u_Texture, v_TexCoordinate) * brightness;" + "\n"
+                    //+ "gl_FragColor =  (texture2D(u_Texture, v_TexCoordinate)  +texture2D(n_Texture, v_TexCoordinate))*0.5;" + "\n"
+                    + "}";
+/**/
+
+    /*/
+    final String per_pixel_fragment_shader =
+            "precision mediump float;"
+                    + "uniform sampler2D u_Texture;\n"    // The input texture
+                    + "uniform sampler2D n_Texture;\n"
+                    + "varying vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+                    + "varying vec2 v_TexCoordinate;\n"  // interpolated Texture coordinate same for texture and normaltexture
+                    + "float brightness;" + "\n"
+
+                    + "void main()" + "{\n"
+                //    + "vec3 vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" +"\n"
+
+                //    + "float dist = (length(v_Light.xyz));" + "\n"
+                //    + "brightness = dot(v_Light,vec_normalTex);" + "\n"
+
+                //    + "brightness = ((1.0 * brightness * (1.0 / dist)) + 0.0);" + "\n"
+
+                //    + "gl_FragColor =  texture2D(u_Texture, v_TexCoordinate) * brightness;" + "\n"
+                    + "vec4 color_vec = texture2D(u_Texture, v_TexCoordinate);"
+
+
+                    //    + "vec3 vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" +"\n"
+
+                    //    + "float dist = (length(v_Light.xyz));" + "\n"
+                    //    + "brightness = dot(v_Light,vec_normalTex);" + "\n"
+
+                    //    + "brightness = ((1.0 * brightness * (1.0 / dist)) + 0.0);" + "\n"
+
+                    //    //+ "gl_FragColor =  texture2D(u_Texture, v_TexCoordinate) * brightness;" + "\n"
+                    //+ "color_vec = brightness * color_vec; " + "\n"
+                    + "gl_FragColor =  color_vec;" + "\n"
+                    + "}";
+    /**/
+
+
+    /*/
+    final String per_pixel_fragment_shader =
+            "precision mediump float;"
+                    + "uniform sampler2D u_Texture;\n"    // The input texture
+                    + "uniform sampler2D n_Texture;\n"
+
+                    + "uniform vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+
+                    + "varying vec2 v_TexCoordinate;\n"  // interpolated Texture coordinate same for texture and normaltexture
+
+                    + "float brightness;" + "\n"
+                    + "vec4 color_vec;"
+                    + "vec3 vec_normalTex;"
+                    + "float dist;"
+
+                    + "void main()" + "{\n"
+                    //    + "vec3 vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" +"\n"
+
+                    //    + "float dist = (length(v_Light.xyz));" + "\n"
+                    //    + "brightness = dot(v_Light,vec_normalTex);" + "\n"
+
+                    //    + "brightness = ((1.0 * brightness * (1.0 / dist)) + 0.0);" + "\n"
+
+                    //    + "gl_FragColor =  texture2D(u_Texture, v_TexCoordinate) * brightness;" + "\n"
+                    + "color_vec = texture2D(u_Texture, v_TexCoordinate);"
+
+
+                    + "vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" +"\n"
+
+                        //+ "vec3 Light = vec3(v_Light);"//vec3(0.5,0.5,1.0);"
+
+                   // + "vec3 Light = vec3(1,0.0,0.0);"
+                        + "dist = (length(v_Light.xyz));" + "\n"
+                    + "brightness = dot(v_Light,vec_normalTex);" + "\n"
+
+
+                    + "brightness = ((0.8 * brightness * (0.5 / dist)) + 0.2);" + "\n" //
+
+                   //     //+ "gl_FragColor =  texture2D(u_Texture, v_TexCoordinate) * brightness;" + "\n"
+                    + "color_vec = brightness * color_vec; " + "\n"
+                    + "gl_FragColor =  color_vec;" + "\n"
+                    + "}";
+    /**/
+
+    /*/
+    final String per_pixel_fragment_shader =
+            "precision mediump float;"
+                    + "uniform sampler2D u_Texture;\n"    // The input texture
+                    + "uniform sampler2D n_Texture;\n"
+
+                    + "uniform vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+
+                    + "varying vec2 v_TexCoordinate;\n"  // interpolated Texture coordinate same for texture and normaltexture
+
+                    + "float brightness;" + "\n"
+                    + "vec4 color_vec;"
+                    + "vec3 vec_normalTex;"
+                    + "float dist;"
+
+
+
+                    + "void main()" + "{\n"
+                   // + "color_vec = texture2D(u_Texture, v_TexCoordinate);"
+
+
+                   // + "vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" +"\n"
+                   // + "dist = (length(v_Light.xyz));" + "\n"
+                   // + "brightness = dot(v_Light,vec_normalTex);" + "\n"
+
+
+                   // + "brightness = ((0.8 * brightness * (0.5 / dist)) + 0.2);" + "\n"
+                   // + "color_vec = brightness * color_vec; " + "\n"
+                   // + "gl_FragColor =  color_vec;" + "\n"
+
+                        // Will be used for attenuation.\n"+
+
+                    +"float distance = length(v_Light);\n"// Get a lighting direction vector from the light to the vertex.\n"
+                    +"vec3 lightVector = normalize(v_Light);\n"
+
+                    + "vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" +"\n"
+
+                    +"float diffuse = max(dot(vec_normalTex, lightVector), 0.0);\n" // 0 to 1
+
+                    +"diffuse = (diffuse * (1.0 / (1.0 + (0.05 * distance))) + 0.2);\n" // + 0.5 * (1.0 / (1.0 + (0.005 * distance)))
+
+                    + "vec4 colorvec = (diffuse * texture2D(u_Texture, v_TexCoordinate));" //diffuse*
+
+                    +"gl_FragColor = colorvec;" // Multiply the color by the diffuse illumination level and texture value to get final output color.\n"
+                    + "}";
+    /**/
+    /*/ // normal shading, working pretty well:
+    final String per_pixel_fragment_shader = "precision mediump float;" + "uniform sampler2D u_Texture;\n"    // The input texture
+            + "uniform sampler2D n_Texture;\n"
+
+            + "uniform vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+
+            //+"varying vec3 v_Position;"
+            + "uniform vec3 v_Tile;"
+
+            + "varying vec2 v_TexCoordinate;\n"  // interpolated Texture coordinate same for texture and normaltexture
+
+            + "float brightness;" + "\n"
+            + "vec4 color_vec;"
+            + "vec3 vec_normalTex;"
+            + "float dist;"
+
+
+            + "void main()" + "{\n"
+
+            + "float distance = length(v_Light - v_Tile - vec3(v_TexCoordinate,0));\n"// Get a lighting direction vector from the light to the vertex.\n"
+
+            + "float distancepixel = length(vec2(v_Light - v_Tile - vec3(v_TexCoordinate,0)));\n"// Get a lighting direction vector from the light to the vertex.\n"
+
+            + "vec3 lightVector = normalize(v_Light - v_Tile - vec3(v_TexCoordinate,0));\n"
+
+            + "vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" + "\n"
+
+            + "float diffuse = max(dot(vec_normalTex, lightVector), 0.0);\n" // 0 to 1
+
+            + "diffuse = (diffuse * (1.0 / (1.0 + (0.05 * distance))) + 0.2);\n" // + 0.5 * (1.0 / (1.0 + (0.005 * distance)))
+
+            + "vec4 colorvec = (diffuse * texture2D(u_Texture, v_TexCoordinate));" //diffuse*
+            //+ " if(distancepixel < 0.1){"
+            + "colorvec = colorvec+colorvec * (1.0/(1.0+10.0*distancepixel));"//vec4(1.0,1.0,1.0,1.0);"
+            //+"}"
+            + "gl_FragColor = colorvec;" // Multiply the color by the diffuse illumination level and texture value to get final output color.\n"
+            + "}";
+    /**/
+
+    /**/ //Toonshading :
+    final String per_pixel_fragment_shader = "precision mediump float;" + "uniform sampler2D u_Texture;\n"    // The input texture
+            + "uniform sampler2D n_Texture;\n"
+
+            + "uniform vec3 v_Light;" + "\n"         // Vector from the Light to the Tile
+
+            //+"varying vec3 v_Position;"
+            + "uniform vec3 v_Tile;"
+
+            + "varying vec2 v_TexCoordinate;\n"  // interpolated Texture coordinate same for texture and normaltexture
+
+            + "float brightness;" + "\n" + "vec4 color_vec;" + "vec3 vec_normalTex;" + "float dist;"
+
+            + "const float levels = -6.0;"
+
+
+            + "void main()" + "{\n"
+
+            + "float distance = length(v_Light - v_Tile - vec3(v_TexCoordinate,0));\n"// Get a lighting direction vector from the light to the vertex.\n"
+
+            + "float distancepixel = length(vec2(v_Light - v_Tile - vec3(v_TexCoordinate,0)));\n"// Get a lighting direction vector from the light to the vertex.\n"
+
+            + "vec3 lightVector = normalize(v_Light - v_Tile - vec3(v_TexCoordinate,0));\n"
+
+            + "vec_normalTex = vec3(texture2D(n_Texture, v_TexCoordinate))-0.5;" + "\n"
+
+            + "float diffuse = max(dot(vec_normalTex, lightVector), 0.0);\n" // 0 to 1
+
+            + "diffuse = (diffuse * (1.0 / (1.0 + (0.05 * distance))) + 0.2);\n" // + 0.5 * (1.0 / (1.0 + (0.005 * distance)))
+
+            + "vec4 colorvec = (diffuse * texture2D(u_Texture, v_TexCoordinate));" //diffuse*
+            //+ " if(distancepixel < 0.1){"
+            + "colorvec = colorvec+colorvec * (1.0/(1.0+10.0*distancepixel));"//vec4(1.0,1.0,1.0,1.0);"
+            //+"}"
+            + "if(levels > 0.0){" + "colorvec = floor(colorvec * levels)/levels;" + "}" + "gl_FragColor = colorvec;" // Multiply the color by the diffuse illumination level and texture value to get final output color.\n"
+            + "}";
+    /**/
+
+    int Program[] = new int[2];
+
+    PointLight Lightsource = new PointLight(new Vector(), Color.rgb(255, 255, 200));
+
+    @Override
+    public void onSurfaceCreated(GL10 glUnused, EGLConfig config) {
+        // Set the background clear color to gray.
+        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 0.5f);
+
+
+        // Position the eye behind the origin.
+        final float eyeX = 0.0f;
+        final float eyeY = 0.0f;
+        final float eyeZ = 1.f;
+
+        // We are looking toward the distance
+        final float lookX = 0.0f;
+        final float lookY = 0.0f;
+        final float lookZ = -5.0f;
+
+        // Set our up vector. This is where our head would be pointing were we holding the camera.
+        final float upX = 0.0f;
+        final float upY = 1.0f;
+        final float upZ = 0.0f;
+
+        // Set the view matrix. This matrix can be said to represent the camera position.
+        // NOTE: In OpenGL 1, a ModelView matrix is used, which is a combination of a model and
+        // view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose.
+        Matrix.setLookAtM(mViewMatrix, 0, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ);
+
+
+        Program[1] = createProgram(vertexShader, fragmentShader);
+
+
+        Program[0] = createProgram(per_pixel_vertex_shader, per_pixel_fragment_shader);
+        GLES20.glUseProgram(Program[1]);
+
+        //TILETEXTURE.updateTextures();        // working
+        //TILETEXTURE.updateTexturesNormals(); // working
+        for (int i = 0; i < 40; i++) {
+            TILETEXTURE.UpdateMaterialTexture(i);
+            TILETEXTURE.UpdateMaterialNormalTexture(i);
+        }
+
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+    }
+
+
+    @Override
+    public void onSurfaceChanged(GL10 glUnused, int width, int height) {
+        // Set the OpenGL viewport to the same size as the surface.
+        GLES20.glViewport(0, 0, width, height);
+
+        // Create a new perspective projection matrix. The height will stay the same
+        // while the width will vary as per aspect ratio.
+        float ratio = 1f;//(float) width / height;
+        float left = -ratio;
+        float right = ratio;
+        float bottom = -1.0f;
+        float top = 1.0f;
+        float near = 0.9999f;
+        float far = 10.0f;
+
+        Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far);
+    }
+
+
+    private void setRGBA(int Colorint) {
+        r = (float) (Color.red(Colorint)) / 255.0f;
+        g = (float) (Color.green(Colorint)) / 255.0f;
+        b = (float) (Color.blue(Colorint)) / 255.0f;
+        a = (float) (Color.alpha(Colorint)) / 255.0f;
+    }
+
+    private float r, g, b, a;
+
+    @Override
+    public void onDrawFrame(GL10 glUnused) {
+
+        GLES20.glUseProgram(Program[0]);
+
+        camera.UpdateEye2D();
+
+        GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);
+
+        setRGBA(BACKGROUNDCOLOR);
+        GLES20.glClearColor(r, g, b, a);
+
+        //TODO Parallel thread that always saves all the visible Tiles, if not, the renderer is slower :(
+
+
+        ArrayList<Tile> visible = KDTREE.getVisibleTilesInCurrentTree(); // KDTREECOPY
+
+
+        Log.d("Tiles: ", String.valueOf(visible.size()));
+
+
+        Vector Cal = new Vector();
+        float TILESIZEzoom = (float) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
+
+
+        mTextureUniformHandle = GLES20.glGetUniformLocation(Program[0], "u_Texture");
+        TextureUniformHandleNormal = GLES20.glGetUniformLocation(Program[0], "n_Texture");
+
+        //LightUniformHandle = GLES20.glGetAttribLocation(Program[0],"a_Light");
+        //LightUniformHandle = GLES20.glGetAttribLocation(Program[0],"v_Light");
+        LightUniformHandle = GLES20.glGetUniformLocation(Program[0], "v_Light");
+        PositionTileUniformHandle = GLES20.glGetUniformLocation(Program[0], "v_Tile");
+
+
+        mTextureCoordinateHandle = GLES20.glGetAttribLocation(Program[0], "a_TexCoordinate");
+        mMVPMatrixHandle = GLES20.glGetUniformLocation(Program[0], "u_MVPMatrix");
+        mPositionHandle = GLES20.glGetAttribLocation(Program[0], "a_Position");
+
+
+        Matrix.setIdentityM(mModelMatrix, 0);
+        Matrix.translateM(mModelMatrix, 0, 0, 0, -1.0f);
+
+
+        float[] cubeTextureCoordinateData = {
+                // Front face
+                0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f};
+
+        FloatBuffer mSquareTextureCoordinates;
+        mSquareTextureCoordinates = ByteBuffer.allocateDirect(cubeTextureCoordinateData.length * mBytesPerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();
+        mSquareTextureCoordinates.put(cubeTextureCoordinateData).position(0);
+        // Pass in the texture coordinate information
+        mSquareTextureCoordinates.position(0);
+        GLES20.glVertexAttribPointer(mTextureCoordinateHandle, mTextureCoordinateDataSize, GLES20.GL_FLOAT, false, 0, mSquareTextureCoordinates);
+        GLES20.glEnableVertexAttribArray(mTextureCoordinateHandle);
+
+
+        Vector LightVec = camera.getEye2D(); // position of the Light
+
+        float Rotationtime = 5000.0f; // in ms
+        float Rotationdistance = 3;
+
+        float A = SystemClock.uptimeMillis() % Rotationtime;
+        float Time = A / Rotationtime; // float from 0 to 1. It takes 5s to reset
+
+        //Log.d("percentage:",String.valueOf(Time));
+
+        float X = (float) (Rotationdistance * Math.sin(Math.PI * 2 * Time)); // rotating point in a distance of 5 tiles / units
+        float Y = (float) (Rotationdistance * Math.cos(Math.PI * 2 * Time)); // rotating point in a distance of 5 tiles / units
+
+
+        //X = 0;
+        //Y = 0;
+
+        float[] LightPositionData = {(float) (LightVec.getValue(0) / TILESIZE) + X, (float) (LightVec.getValue(1) / TILESIZE) + Y, 10.0f / TILESIZE}; // light x, y, z
+        GLES20.glUniform3f(LightUniformHandle, LightPositionData[0], LightPositionData[1], LightPositionData[2]);
+
+
+        for (int i = 0; i < visible.size(); i++) {
+            try {
+
+
+                Cal = Cal.getScreencoordinatesFromTileCoordinates(visible.get(i).getPosition());
+
+
+                float left = (float) Cal.getValue(0);//(float) visible.get(i).getPositionRAW().getX() * Scale;//width / height;
+                float top = (float) Cal.getValue(1);//(float) visible.get(i).getPositionRAW().getY() * Scale;
+                float right = (float) Cal.getValue(0) + TILESIZEzoom;//(float) (visible.get(i).getPositionRAW().getX() + 1) * Scale;
+                float bottom = (float) Cal.getValue(1) + TILESIZEzoom;//(float) (visible.get(i).getPositionRAW().getY() + 1) * Scale;
+
+
+                left = 2 * ((left / WIDTHSCREEN) * 2 - 1);
+                top = 2 * (1 - (top / HEIGHTSCREEN) * 2);
+                right = 2 * ((right / WIDTHSCREEN) * 2 - 1);
+                bottom = 2 * (1 - (bottom / HEIGHTSCREEN) * 2);
+
+                try {
+                    drawTexture(left, top, right, bottom, visible.get(i).getIDint(), visible.get(i).getMaterial(), visible.get(i).getPosition());
+                } catch (Exception e) {
+                    Log.d("Render Texture: ", e + "");
+                }
+            } catch (Exception e) {
+                Log.d("KDTREE: ", "Tile null error");
+            }
+        }
+
+
+        mMVPMatrixHandle = GLES20.glGetUniformLocation(Program[1], "u_MVPMatrix");
+        mPositionHandle = GLES20.glGetAttribLocation(Program[1], "a_Position");
+        mColorHandle = GLES20.glGetAttribLocation(Program[1], "a_Color");
+
+        GLES20.glUseProgram(Program[1]);
+
+        for (CustomButtons CB : CUSTOMBUTTONSLIST) {
+            drawSquare(CB.getLeft(), CB.getTop(), CB.getRight(), CB.getBottom(), CB.getColor());
+        }
+        GLES20.glDisableVertexAttribArray(mPositionHandle);
+        GLES20.glDisableVertexAttribArray(mColorHandle);
+        GLES20.glDisableVertexAttribArray(mTextureCoordinateHandle);
+        GLES20.glDisableVertexAttribArray(mPositionHandle);
+        GLES20.glDisableVertexAttribArray(LightUniformHandle);
+        GLES20.glDisableVertexAttribArray(mMVPMatrixHandle);
+
+
+        //GLES20.glFlush();
+    }
+
+
+    /**
+     * Draws a triangle from the given vertex data.
+     *
+     * @param aTriangleBuffer The buffer containing the vertex data.
+     */
+    /*/
+    private void drawTriangle(final FloatBuffer aTriangleBuffer) {
+        // Pass in the position information
+        aTriangleBuffer.position(mPositionOffset);
+        GLES20.glVertexAttribPointer(mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false, mStrideBytes, aTriangleBuffer);
+
+        GLES20.glEnableVertexAttribArray(mPositionHandle);
+
+        // Pass in the color information
+        aTriangleBuffer.position(mColorOffset);
+        GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, false, mStrideBytes, aTriangleBuffer);
+
+        GLES20.glEnableVertexAttribArray(mColorHandle);
+
+        // This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix
+        // (which currently contains model * view).
+        Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);
+
+        // This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix
+        // (which now contains model * view * projection).
+        Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mMVPMatrix, 0);
+
+        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0);
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);
+    }/**/
+
+    /**
+     * Draws a square / rect on the glsurface / screen using the shader and opengl coordinates
+     *
+     * @param left   left x  coordinate
+     * @param top    top y coordinate
+     * @param right  right x coordinate
+     * @param bottom bottom y coordinate
+     * @param color  Color for all 4 vertices
+     */
+    private void drawSquare(float left, float top, float right, float bottom, int color) { // 6 Values = 2 Triangles
+
+        float red = ((float) Color.red(color)) / 255;
+        float green = ((float) Color.green(color)) / 255;
+        float blue = ((float) Color.blue(color)) / 255;
+        float alpha = ((float) Color.alpha(color)) / 255;
+
+
+        float[] squareVerticesData = {
+                // X, Y, Z,
+                // R, G, B, A
+                left, bottom, 0.0f, red, green, blue, alpha,//1
+
+                left, top, 0.0f, red, green, blue, alpha,//2
+
+                right, top, 0.0f, red, green, blue, alpha,//3
+
+                right, bottom, 0.0f, red, green, blue, alpha,//4
+
+                right, top, 0.0f, red, green, blue, alpha,//3
+
+                left, bottom, 0.0f, red, green, blue, alpha};//1
+
+        FloatBuffer SquareVertices = ByteBuffer.allocateDirect(squareVerticesData.length * mBytesPerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();
+
+        SquareVertices.put(squareVerticesData).position(0);
+
+
+        // Pass in the position information
+        SquareVertices.position(mPositionOffset);
+        GLES20.glVertexAttribPointer(mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false, mStrideBytes, SquareVertices);
+
+        GLES20.glEnableVertexAttribArray(mPositionHandle);
+
+        // Pass in the color information
+        SquareVertices.position(mColorOffset);
+        GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, false, mStrideBytes, SquareVertices);
+
+        GLES20.glEnableVertexAttribArray(mColorHandle);
+
+        // This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix
+        // (which currently contains model * view).
+        Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);
+
+        // This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix
+        // (which now contains model * view * projection).
+        Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mMVPMatrix, 0);
+
+        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0);
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 6); // square = 4, triangle = 3
+    }
+
+
+    /**
+     * This will be used to pass in model normal information.
+     */
+    private int mNormalHandle;
+
+
+    /**
+     * Size of the normal data in elements.
+     */
+    private final int mNormalDataSize = 3;
+
+    private void drawTexture(float left, float top, float right, float bottom, int ID, int Materialint, Vector Position) { // 6 Values = 2 Triangles
+
+
+        TextureDataHandleNormal = TILETEXTURE.getTextureNormals(ID, Materialint);//TILETEXTURE.getTexture(ID, Materialint);
+        // Bind the texture to this unit.
+
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
+
+
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, TextureDataHandleNormal);
+
+        // Tell the texture uniform sampler to use this texture in the shader by binding to texture unit 0.
+        GLES20.glUniform1i(TextureUniformHandleNormal, 0);
+
+
+        mTextureDataHandle = TILETEXTURE.getTexture(ID, Materialint);/**/
+
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE1);
+
+        // Bind the texture to this unit.
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureDataHandle);
+
+        // Tell the texture uniform sampler to use this texture in the shader by binding to texture unit 0.
+        GLES20.glUniform1i(mTextureUniformHandle, 1);
+
+
+        //LightUniformHandle
+
+        /** Store our model data in a float buffer. */
+        /*/
+        float[] LightPositionData = {
+                (float)Lightsource.getPositionvec().getValue(0), (float)Lightsource.getPositionvec().getValue(1),  0.0f}; // light x, y, z
+        /*/
+
+
+        float[] PositionData = {(float) Position.getValue(0) / TILESIZE, (float) Position.getValue(1) / TILESIZE, 0.0f}; // light x, y, z
+        GLES20.glUniform3f(PositionTileUniformHandle, PositionData[0], PositionData[1], PositionData[2]);
+
+
+        /** Store our model data in a float buffer. */
+
+        float[] squarePositionData = {left, bottom, 0.0f, left, top, 0.0f, right, top, 0.0f, right, bottom, 0.0f, right, top, 0.0f, left, bottom, 0.0f};
+
+
+        FloatBuffer mSquarePositions = ByteBuffer.allocateDirect(squarePositionData.length * mBytesPerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();
+        mSquarePositions.put(squarePositionData).position(0);
+
+        // Pass in the position information
+        mSquarePositions.position(0);
+        GLES20.glVertexAttribPointer(mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false, 0, mSquarePositions);
+        GLES20.glEnableVertexAttribArray(mPositionHandle);
+
+
+        // This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix
+        // (which currently contains model * view).
+        Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);
+
+        //// Pass in the modelview matrix.
+        //GLES20.glUniformMatrix4fv(mMVMatrixHandle, 1, false, mMVPMatrix, 0);
+
+        // This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix
+        // (which now contains model * view * projection).
+        Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mMVPMatrix, 0);
+
+        // Pass in the combined matrix.
+        GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0);
+
+        // Draw the cube.
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 6);
+    }
+
+
+    /**
+     * This will be used to pass in the Tile itself.
+     */
+    private int PositionTileUniformHandle;
+
+    /**
+     * This will be used to pass in the light(s).
+     */
+    private int LightUniformHandle;//
+
+    /**
+     * This will be used to pass in the texture.
+     */
+    private int mTextureUniformHandle;
+
+    /**
+     * This will be used to pass in the texture.
+     */
+    private int TextureUniformHandleNormal;
+    /**
+     * This will be used to pass in model texture coordinate information.
+     */
+    private int mTextureCoordinateHandle;
+
+    /**
+     * Size of the texture coordinate data in elements.
+     */
+    private int mTextureCoordinateDataSize = 2;
+
+    /**
+     * This is a handle to our texture data.
+     */
+    private int mTextureDataHandle;
+
+    /**
+     * This is a handle to our textures normal data.
+     */
+    private int TextureDataHandleNormal;
+    /**
+     * This is a handle to our cube shading program.
+     */
+    private int mProgramHandle;
+
+
+    private int createProgram(String vertexShader, String fragmentShader) {
+
+        // Load in the vertex shader.
+        int vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);
+
+        if (vertexShaderHandle != 0) {
+            // Pass in the shader source.
+            GLES20.glShaderSource(vertexShaderHandle, vertexShader);
+
+            // Compile the shader.
+            GLES20.glCompileShader(vertexShaderHandle);
+
+            // Get the compilation status.
+            final int[] compileStatus = new int[1];
+            GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);
+
+            // If the compilation failed, delete the shader.
+            if (compileStatus[0] == 0) {
+                GLES20.glDeleteShader(vertexShaderHandle);
+                vertexShaderHandle = 0;
+            }
+        }
+
+        if (vertexShaderHandle == 0) {
+            throw new RuntimeException("Error creating vertex shader.");
+        }
+
+        // Load in the fragment shader shader.
+        int fragmentShaderHandle = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER);
+
+        if (fragmentShaderHandle != 0) {
+            // Pass in the shader source.
+            GLES20.glShaderSource(fragmentShaderHandle, fragmentShader);
+
+            // Compile the shader.
+            GLES20.glCompileShader(fragmentShaderHandle);
+
+            // Get the compilation status.
+            final int[] compileStatus = new int[1];
+            GLES20.glGetShaderiv(fragmentShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);
+
+            // If the compilation failed, delete the shader.
+            if (compileStatus[0] == 0) {
+                GLES20.glDeleteShader(fragmentShaderHandle);
+                fragmentShaderHandle = 0;
+            }
+        }
+
+        if (fragmentShaderHandle == 0) {
+            throw new RuntimeException("Error creating fragment shader.");
+        }
+
+        // Create a program object and store the handle to it.
+        int programHandle = GLES20.glCreateProgram();
+
+        if (programHandle != 0) {
+            // Bind the vertex shader to the program.
+            GLES20.glAttachShader(programHandle, vertexShaderHandle);
+
+            // Bind the fragment shader to the program.
+            GLES20.glAttachShader(programHandle, fragmentShaderHandle);
+
+            // Bind attributes
+            GLES20.glBindAttribLocation(programHandle, 0, "a_Position");
+            GLES20.glBindAttribLocation(programHandle, 1, "a_Color");
+            GLES20.glBindAttribLocation(programHandle, 2, "a_Normal");
+            GLES20.glBindAttribLocation(programHandle, 3, "a_TexCoordinate");
+
+
+            // Link the two shaders together into a program.
+            GLES20.glLinkProgram(programHandle);
+
+            // Get the link status.
+            final int[] linkStatus = new int[1];
+            GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0);
+
+            // If the link failed, delete the program.
+            if (linkStatus[0] == 0) {
+                GLES20.glDeleteProgram(programHandle);
+                programHandle = 0;
+            }
+        }
+        if (programHandle == 0) {
+            throw new RuntimeException("Error creating program.");
+        }
+
+
+        mMVPMatrixHandle = GLES20.glGetUniformLocation(programHandle, "u_MVPMatrix");
+        mPositionHandle = GLES20.glGetAttribLocation(programHandle, "a_Position");
+        mColorHandle = GLES20.glGetAttribLocation(programHandle, "a_Color");
+
+
+        return programHandle;
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/jacobjacob/ttproject/Input/UI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Input/UI.java	(date 1567859062490)
+++ app/src/main/java/com/jacobjacob/ttproject/Input/UI.java	(date 1567859062490)
@@ -0,0 +1,8 @@
+package com.jacobjacob.ttproject.Input;
+
+import com.jacobjacob.ttproject.Vector;
+
+public interface UI {
+
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Input/UIButtons.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Input/UIButtons.java	(date 1567878473845)
+++ app/src/main/java/com/jacobjacob/ttproject/Input/UIButtons.java	(date 1567878473845)
@@ -0,0 +1,17 @@
+package com.jacobjacob.ttproject.Input;
+
+import com.jacobjacob.ttproject.Vector;
+
+public class UIButtons/*/ extends UI/**/ {
+
+    public UIButtons(Vector position, int width, int height) {
+        //super(position, width, height);
+    }
+
+    public void Update(){
+
+    }
+
+    public UIButtons() {
+    }
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Loadfile/ReadFile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Loadfile/ReadFile.java	(date 1567961631116)
+++ app/src/main/java/com/jacobjacob/ttproject/Loadfile/ReadFile.java	(date 1567961631116)
@@ -0,0 +1,293 @@
+package com.jacobjacob.ttproject.Loadfile;
+
+import android.util.Log;
+import android.widget.Toast;
+
+import com.jacobjacob.ttproject.Material;
+import com.jacobjacob.ttproject.Tile.KdTree;
+import com.jacobjacob.ttproject.Tile.Tile;
+import com.jacobjacob.ttproject.Vector;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+
+import static com.jacobjacob.ttproject.Util.CONTEXT;
+import static com.jacobjacob.ttproject.Util.DISPAYTOAST;
+import static com.jacobjacob.ttproject.Util.FILE_NAME;
+import static com.jacobjacob.ttproject.Util.KDTREE;
+import static com.jacobjacob.ttproject.Util.KDTREECOPY;
+import static com.jacobjacob.ttproject.Util.KDTREECURRENTLYBUILDING;
+import static com.jacobjacob.ttproject.Util.MATERIALARRAY;
+import static com.jacobjacob.ttproject.Util.OPENGL;
+import static com.jacobjacob.ttproject.Util.SETTINS_NAME;
+import static com.jacobjacob.ttproject.Util.STARTINGMATERIAL;
+import static com.jacobjacob.ttproject.Util.TEXTUREWIDTH;
+import static com.jacobjacob.ttproject.Util.UPDATEVIEW;
+
+
+public class ReadFile {
+
+    public void ReadFile() { // String Filename
+        FileInputStream fis = null;
+
+        try {
+            fis = CONTEXT.openFileInput(FILE_NAME);
+
+            InputStreamReader isr = new InputStreamReader(fis);
+            BufferedReader br = new BufferedReader(isr);
+            StringBuilder sb = new StringBuilder();
+            String text;
+
+            while ((text = br.readLine()) != null) {
+                sb.append(text).append("\n");
+            }
+            //Toast.makeText(CONTEXT, "Sucess!! : " + CONTEXT.getFilesDir() + "/" + FILE_NAME + " loadet", Toast.LENGTH_LONG).show();
+            if (DISPAYTOAST) {
+                Toast.makeText(CONTEXT, sb.toString(), Toast.LENGTH_LONG).show();
+            }
+            //mEditText.setText(sb.toString());
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    public void ReadSettings() {
+
+
+        FileInputStream fis = null;
+
+        try {
+            fis = CONTEXT.openFileInput(SETTINS_NAME);
+
+            InputStreamReader isr = new InputStreamReader(fis);
+            BufferedReader br = new BufferedReader(isr);
+            StringBuilder sb = new StringBuilder();
+            String text;
+
+            while ((text = br.readLine()) != null) {
+                sb.append(text).append("\n");
+
+                String[] parts = text.split(" ");
+
+                if (String.valueOf(parts[0]).equals("OPENGL")) {
+                    if (String.valueOf(parts[1]).equals("true")) {
+                        OPENGL = true;
+                    } else if (String.valueOf(parts[1]).equals("false")) {
+                        OPENGL = false;
+                    }
+                }
+
+            }
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    public void ReadFileTiles() { // String Filename
+
+
+        //UPDATEVIEW = false;
+
+        //UPDATEVIEW = true;
+
+        ArrayList<Tile> AllTiles = new ArrayList<>();
+
+        //KDTREE = new KdTree();//reset();
+        //KDTREECOPY = new KdTree();
+        //KDTREECURRENTLYBUILDING = false;
+        //KDTREECOPY = KDTREE;
+
+
+        MATERIALARRAY = new Material[TEXTUREWIDTH * TEXTUREWIDTH]; // reset
+        int Materialint = 0;
+
+        boolean readMaterial = false;
+        boolean readMaterialAnimations = false;
+
+        FileInputStream fis = null;
+
+        try {
+            fis = CONTEXT.openFileInput(FILE_NAME);
+
+            InputStreamReader isr = new InputStreamReader(fis);
+            BufferedReader br = new BufferedReader(isr);
+            StringBuilder sb = new StringBuilder();
+            String text;
+
+            while ((text = br.readLine()) != null) {
+                sb.append(text).append("\n");
+
+                String[] parts = text.split(" ");
+
+                if (String.valueOf(parts[0]).equals("m")) {
+                    readMaterial = true;
+                }
+                if (String.valueOf(parts[0]).equals("a")) {
+                    readMaterial = false;
+                    readMaterialAnimations = true;
+                }
+
+                if (!readMaterial && !readMaterialAnimations) {
+
+                    Tile newTile = new Tile(new Vector(Integer.parseInt(parts[0]), Integer.parseInt(parts[1])), Integer.parseInt(parts[2]), Integer.parseInt(parts[3]));
+                    if (parts.length > 4) {
+                        newTile.setMaterial(Integer.parseInt(parts[4]));
+                        if (parts.length > 5) {
+                            newTile.setStarttime(Integer.parseInt(parts[5]));
+                        }
+                    }
+                    AllTiles.add(newTile);
+                }
+                if (readMaterial) {
+
+                    if (!String.valueOf(parts[0]).equals("m")) {
+
+                        MATERIALARRAY[Materialint] = new Material(Integer.parseInt(parts[0]), // number
+                                Integer.parseInt(parts[1]), // layer 1
+                                Integer.parseInt(parts[2]), // layer 2
+                                Integer.parseInt(parts[3]), // layer 3
+
+                                Integer.parseInt(parts[4]), // color int 1
+                                Integer.parseInt(parts[5]), // color int 2
+                                Integer.parseInt(parts[6])); // color int 3
+                        if (parts.length > 7) {
+                            MATERIALARRAY[Materialint].setColorLayer0(Integer.parseInt(parts[7]));
+                        }
+                        Materialint++;
+                    }
+                }
+
+
+                if (readMaterialAnimations) {
+
+                    if (!String.valueOf(parts[0]).equals("a") && !String.valueOf(parts[0]).equals(" ")) {
+                        int[][] Animation = new int[31][3];
+                        if (MATERIALARRAY[Integer.parseInt(parts[0])] != null) {
+                            for (int i = 0; i < (parts.length - 2) / 4; i++) {
+                                Animation[Integer.parseInt(parts[i * 4 + 2])][0] = Integer.parseInt(parts[i * 4 + 3]);
+                                Animation[Integer.parseInt(parts[i * 4 + 2])][1] = Integer.parseInt(parts[i * 4 + 4]);
+                                Animation[Integer.parseInt(parts[i * 4 + 2])][2] = Integer.parseInt(parts[i * 4 + 5]);
+                            }
+                        } else {
+                            MATERIALARRAY[Integer.parseInt(parts[0])] = STARTINGMATERIAL;
+                            for (int i = 0; i < (parts.length - 1) / 4; i++) {
+                                Animation[i * 4 + 2][0] = Integer.parseInt(parts[i * 4 + 3]);
+                                Animation[i * 4 + 2][1] = Integer.parseInt(parts[i * 4 + 4]);
+                                Animation[i * 4 + 2][2] = Integer.parseInt(parts[i * 4 + 5]);
+                            }
+                        }
+
+                        MATERIALARRAY[Integer.parseInt(parts[0])].LoadAnimation(Animation);
+                        MATERIALARRAY[Integer.parseInt(parts[0])].setAnimationtime(Integer.parseInt(parts[1]));
+                        //set Animationtime
+                    }
+                }
+            }
+            //Toast.makeText(CONTEXT, "Success!! : " + CONTEXT.getFilesDir() + "/" + FILE_NAME + " loaded", Toast.LENGTH_LONG).show();
+            //Toast.makeText(CONTEXT, sb.toString(), Toast.LENGTH_LONG).show();
+            if (DISPAYTOAST) {
+                Toast.makeText(CONTEXT, "SUCCESS: " + FILE_NAME + " loaded", Toast.LENGTH_LONG).show();
+                Log.d("Loadtxt: ", "Success!");
+            }
+            //mEditText.setText(sb.toString());
+
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+            Log.d("Read File", "Crash1");
+        } catch (IOException e) {
+            e.printStackTrace();
+            Log.d("Read File", "Crash2");
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                    Log.d("Read File", "Crash3 fis couldn`t be closed");
+                }
+            }
+        }
+
+
+        //FRAMETIMESTART = System.currentTimeMillis();
+
+
+        for (int i = 0; i < MATERIALARRAY.length; i++) {
+            if (MATERIALARRAY[i] == null) {
+                Material NewMaterial = STARTINGMATERIAL;
+                int Number = i;
+                NewMaterial.setNumber(Number);
+                MATERIALARRAY[i] = NewMaterial;
+            } else {
+                if (MATERIALARRAY[i].getNumber() != i) {
+                    MATERIALARRAY[i].setNumber(i);
+                }
+            }
+            MATERIALARRAY[i].UpdateMaterialTileset();
+        }
+
+        KDTREE = new KdTree();
+        KDTREE.setTilesInCurrentTree(AllTiles); // 16ms
+        KDTREE.CreatenewKDTree();
+
+        KDTREECOPY = KDTREE;
+
+
+        //KDTREECOPY = new KdTree();
+        //KDTREECOPY = KDTREE;
+
+
+        //FRAMETIME = System.currentTimeMillis() - FRAMETIMESTART; //41ms with 20 iterations // 23 with 5 iterations // 102 with unlimited Iterations and 6467 Tiles // now 770
+        KDTREECURRENTLYBUILDING = false;
+
+        //if (MATERIALARRAY.length < 1) {
+        //    MATERIALARRAY[0] = STARTINGMATERIAL;
+        //}
+
+
+
+        /*/
+        for (int i = 0; i < MATERIALARRAY.length; i++) {
+            if (MATERIALARRAY[i] == null) {
+                Material NewMaterial = STARTINGMATERIAL;
+                int Number = i;
+                NewMaterial.setNumber(Number);
+                MATERIALARRAY[i] = NewMaterial;
+            } else {
+                if (MATERIALARRAY[i].getNumber() != i) {
+                    MATERIALARRAY[i].setNumber(i);
+                }
+            }
+            MATERIALARRAY[i].UpdateMaterialTileset();
+        }/**/
+
+        UPDATEVIEW = true;
+
+    }
+}
Index: app/src/main/res/raw/settings.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/raw/settings.txt	(date 1567880231080)
+++ app/src/main/res/raw/settings.txt	(date 1567880231080)
@@ -0,0 +1,0 @@
Index: app/src/main/java/com/jacobjacob/ttproject/Savefile/WriteFile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Savefile/WriteFile.java	(date 1567883248743)
+++ app/src/main/java/com/jacobjacob/ttproject/Savefile/WriteFile.java	(date 1567883248743)
@@ -0,0 +1,79 @@
+package com.jacobjacob.ttproject.Savefile;
+
+import android.widget.Toast;
+
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+
+import static android.content.Context.MODE_PRIVATE;
+import static com.jacobjacob.ttproject.Util.CONTEXT;
+import static com.jacobjacob.ttproject.Util.DISPAYTOAST;
+import static com.jacobjacob.ttproject.Util.FILE_NAME;
+import static com.jacobjacob.ttproject.Util.SETTINGS_OPENGL;
+import static com.jacobjacob.ttproject.Util.SETTINS_NAME;
+
+public class WriteFile {
+
+    public void WriteFile(String text) {
+
+        //String text = "new save file complete!!";
+
+
+        FileOutputStream fos = null;
+
+        try {
+
+            fos = CONTEXT.openFileOutput(SETTINS_NAME, MODE_PRIVATE);
+
+            fos.write(text.getBytes());
+            //Toast.makeText(CONTEXT, "Saved to: " + CONTEXT.getFilesDir() + "/" + FILE_NAME, Toast.LENGTH_LONG).show();
+            if (DISPAYTOAST) {
+                Toast.makeText(CONTEXT, "SUCCESS: " + FILE_NAME + " saved", Toast.LENGTH_LONG).show();
+            }
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        //System.out.print(text); /SAVING WORKS !!!
+    }
+
+    public void SaveSettings() {
+
+
+        String text = "";
+        text += "OPENGL " + String.valueOf(SETTINGS_OPENGL) + "\n";
+
+        FileOutputStream fos = null;
+
+        try {
+            fos = CONTEXT.openFileOutput(SETTINS_NAME, MODE_PRIVATE);
+
+            fos.write(text.getBytes());
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        //System.out.print(text); /SAVING WORKS !!!
+    }
+
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Old/Object.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Old/Object.java	(date 1566305118137)
+++ app/src/main/java/com/jacobjacob/ttproject/Old/Object.java	(date 1566305118137)
@@ -0,0 +1,9 @@
+package com.jacobjacob.ttproject.Old;
+
+import com.jacobjacob.ttproject.Vector;
+
+public interface Object{
+    Vector getNormal();
+    Vector getVector(int vector);
+    void setVector(Vector input, int vectorposition);
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Old/Rasterizer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Old/Rasterizer.java	(date 1566305118159)
+++ app/src/main/java/com/jacobjacob/ttproject/Old/Rasterizer.java	(date 1566305118159)
@@ -0,0 +1,482 @@
+package com.jacobjacob.ttproject.Old;
+
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+
+import com.jacobjacob.ttproject.Matrix;
+import com.jacobjacob.ttproject.Old.Triangle;
+import com.jacobjacob.ttproject.Vector;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+
+import static com.jacobjacob.ttproject.Util.BACKGROUNDCOLOR;
+import static com.jacobjacob.ttproject.Util.HEIGHT;
+import static com.jacobjacob.ttproject.Util.WIDTH;
+import static com.jacobjacob.ttproject.Util.camera;
+
+public class Rasterizer {
+    static Bitmap bmp;
+    static Canvas canvas;
+    Paint paint = new Paint(BACKGROUNDCOLOR);
+    static ArrayList<Object> objectsrendering = new ArrayList<>();
+    static ArrayList<Object> objectstorender = new ArrayList<>();
+    static ArrayList<Triangle> clippedTriangles = new ArrayList<>();
+    float pDepthBuffer[][] = new float[WIDTH][HEIGHT];
+    int colorR;
+    int colorG;
+    int colorB;
+
+
+    public void InitializeRasterizer() {
+        pDepthBuffer = new float[WIDTH][HEIGHT];
+        bmp = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
+        canvas = new Canvas(bmp);
+        objectstorender.clear();
+        objectsrendering.clear();
+        clippedTriangles.clear();
+        paint.setColor(BACKGROUNDCOLOR);
+        canvas.drawRect(0, 0, WIDTH, HEIGHT, paint);
+        paint.setColor(Color.rgb(200,200,255));
+    }
+
+    public void RenderImage(ArrayList<Object> ObjectsToRasterize) { // Rendering pipeline
+        objectstorender.addAll(ObjectsToRasterize);
+        resetDepthBuffer();
+        for (Object o: objectstorender){
+            if (o instanceof Triangle) {
+                CreateTriangles(o);
+                //ClipTriangles(o);/**Clipping Routine missing!!**/ // Clipping against the screen
+            }
+            //else if (o instanceof Vector){
+            //    CreateLines();
+            //}
+        }
+        ClipTriangles();
+        //objectsrendering.clear();
+        //objectsrendering.addAll(this.clippedTriangles);
+
+        Sortlist();
+
+        DrawTriangle(); // objectsrendering
+    }
+
+    public Bitmap getBmp() { // Returns the rendered Image
+        return bmp;
+    }
+
+
+    private void resetDepthBuffer() {
+        for (int i = 0; i < WIDTH; i++) {// all values of the depth buffer have the value 1
+            for (int j = 0; j < HEIGHT; j++) {
+                pDepthBuffer[i][j] = Float.MAX_VALUE - 1;
+            }
+        }
+    }
+
+    private void CreateTriangles(Object o) {
+
+        Matrix matCamera = new Matrix();
+        matCamera = matCamera.Matrix_PointAt(camera.getEye(), camera.getW(), new Vector(0, 1, 0));
+
+        Matrix matView = matCamera.Matrix_QuickInverse(matCamera);
+
+        //for (Object o : objectstorender) {
+
+            Vector normal = o.getNormal();
+            Vector position = o.getVector(0);
+
+            //Vector visibleposition = position.subtract(camera.getEye());
+            float visible = (float) position.subtract(camera.getEye()).skalarprodukt(normal.negate());
+
+            if (visible >= 0 || true) { // does not work correctly // true = Triangle visible from both sides
+                // Double sided or visible
+
+                // 3d --> 2d                    original Vector, rotated Vector, Matrix()
+
+                Triangle viewed = new Triangle(new Vector(), new Vector(), new Vector());
+
+                viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(0))), 0);
+                viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(1))), 1);
+                viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(2))), 2);
+
+                //Triangle triViewed = viewed; //new Triangle(a, b, c, Color.rgb(red, green, blue));
+
+
+                // Clip Viewed Triangle against near plane, this could form two additional
+                // additional triangles.
+
+
+                int nClippedTriangles;
+                Triangle clipped[] = new Triangle[2];
+                clipped[0] = viewed;
+                clipped[1] = viewed;
+
+                nClippedTriangles = 0;
+                ArrayList<Triangle> clippedTriangles = new Vector().Triangle_ClipAgainstPlane(new Vector(0.0f, 0.0f, 0.1f ), new Vector(0.0f, 0.0f, 1.0f ), viewed);
+                nClippedTriangles = clippedTriangles.size();
+                if (nClippedTriangles >= 1){
+                    clipped[0] = clippedTriangles.get(0);
+                    if (nClippedTriangles >= 2) {
+                        clipped[1] = clippedTriangles.get(1);
+                    }
+                }
+
+                // We may end up with multiple triangles form the clip, so project as
+                // required
+                /**/
+
+                if (clipped[1].getVector(0).getValue(2) > 0 & clipped[1].getVector(1).getValue(2) > 0 & clipped[1].getVector(2).getValue(2) > 0) {
+                    for (int n = 0; n < nClippedTriangles; n++) {
+
+                        // Project triangles from 3D --> 2D
+                        Matrix mat = new Matrix();
+
+                        Triangle triProjected = new Triangle(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(1)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(2)));
+                        triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), 0);
+                        triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(1)), 1);
+                        triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(2)), 2);
+
+                        // Scale into view, we moved the normalising into cartesian space
+                        // out of the matrix.vector function from the previous videos, so
+                        // do this manually
+                        Triangle tridouble = new Triangle(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), triProjected.getVector(1).multiplydouble((float) (1 / triProjected.getVector(1).getW())), triProjected.getVector(2).multiplydouble((float) (1 / triProjected.getVector(2).getW())));
+                        tridouble.setVector(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), 0);
+                        tridouble.setVector(triProjected.getVector(1).multiplydouble((float) (1 / triProjected.getVector(1).getW())), 1);
+                        tridouble.setVector(triProjected.getVector(2).multiplydouble((float) (1 / triProjected.getVector(2).getW())), 2);
+
+                        // X/Y are inverted so put them back
+                        triProjected.setVector(new Vector(-tridouble.getVector(0).getValue(0), -tridouble.getVector(0).getValue(1), tridouble.getVector(0).getValue(2)), 0);
+                        triProjected.setVector(new Vector(-tridouble.getVector(1).getValue(0), -tridouble.getVector(1).getValue(1), tridouble.getVector(1).getValue(2)), 1);
+                        triProjected.setVector(new Vector(-tridouble.getVector(2).getValue(0), -tridouble.getVector(2).getValue(1), tridouble.getVector(2).getValue(2)), 2);
+
+
+                        // Offset verts into visible normalised space
+                        tridouble.setVector(triProjected.getVector(0).addVector(new Vector(1, 1, 0)), 0);
+                        tridouble.setVector(triProjected.getVector(1).addVector(new Vector(1, 1, 0)), 1);
+                        tridouble.setVector(triProjected.getVector(2).addVector(new Vector(1, 1, 0)), 2);
+
+
+                        triProjected.setVector(new Vector(tridouble.getVector(0).getValue(0) * WIDTH / 2, tridouble.getVector(0).getValue(1) * HEIGHT / 2, tridouble.getVector(0).getValue(2)), 0);
+                        triProjected.setVector(new Vector(tridouble.getVector(1).getValue(0) * WIDTH / 2, tridouble.getVector(1).getValue(1) * HEIGHT / 2, tridouble.getVector(1).getValue(2)), 1);
+                        triProjected.setVector(new Vector(tridouble.getVector(2).getValue(0) * WIDTH / 2, tridouble.getVector(2).getValue(1) * HEIGHT / 2, tridouble.getVector(2).getValue(2)), 2);
+
+                        objectsrendering.add(triProjected);
+                    }
+                }
+            }
+        //}
+    }
+    void CreateLines(){
+        Matrix matCamera = new Matrix();
+        matCamera = matCamera.Matrix_PointAt(camera.getEye(), camera.getW(), new Vector(0, 1, 0));
+
+        Matrix matView = matCamera.Matrix_QuickInverse(matCamera);
+
+        for (Object o : objectstorender) {
+
+            Vector position = o.getVector(0);
+
+            Triangle viewed = new Triangle(new Vector(), new Vector(), new Vector());
+
+            viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(0))), 0);
+
+            //Triangle triViewed = viewed; //new Triangle(a, b, c, Color.rgb(red, green, blue));
+
+
+            // Clip Viewed Triangle against near plane, this could form two additional
+            // additional triangles.
+
+
+            int nClippedTriangles;
+            Triangle clipped[] = new Triangle[2];
+            clipped[0] = viewed;
+            clipped[1] = viewed;
+
+            nClippedTriangles = 1;
+
+
+            // We may end up with multiple triangles form the clip, so project as
+            // required
+            /**/
+
+            if (clipped[1].getVector(0).getValue(2) > 0 & clipped[1].getVector(1).getValue(2) > 0 & clipped[1].getVector(2).getValue(2) > 0) {
+                for (int n = 0; n < nClippedTriangles; n++) {
+
+                    // Project triangles from 3D --> 2D
+                    Matrix mat = new Matrix();
+
+                    Triangle triProjected = new Triangle(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(1)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(2)));
+                    triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), 0);
+
+                    // Scale into view, we moved the normalising into cartesian space
+                    // out of the matrix.vector function from the previous videos, so
+                    // do this manually
+                    Triangle tridouble = new Triangle(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), triProjected.getVector(1).multiplydouble((float) (1 / triProjected.getVector(1).getW())), triProjected.getVector(2).multiplydouble((float) (1 / triProjected.getVector(2).getW())));
+                    tridouble.setVector(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), 0);
+
+                    // X/Y are inverted so put them back
+                    triProjected.setVector(new Vector(-tridouble.getVector(0).getValue(0), -tridouble.getVector(0).getValue(1), tridouble.getVector(0).getValue(2)), 0);
+                    // Offset verts into visible normalised space
+                    tridouble.setVector(triProjected.getVector(0).addVector(new Vector(1, 1, 0)), 0);
+                    triProjected.setVector(new Vector(tridouble.getVector(0).getValue(0) * WIDTH / 2, tridouble.getVector(0).getValue(1) * HEIGHT / 2, tridouble.getVector(0).getValue(2)), 0);
+
+                    objectsrendering.add(triProjected);
+                }
+            }
+        }
+    }
+
+    private void ClipTriangles() {
+        /*for (Object o : objectstorender){
+            Triangle Old = new Triangle(o.getVector(0),o.getVector(1),o.getVector(2));
+            if (0 < o.getVector(0).getValue(0) && o.getVector(0).getValue(0) < WIDTH &&
+                    0 < o.getVector(1).getValue(0) && o.getVector(0).getValue(0) < WIDTH &&
+                    0 < o.getVector(2).getValue(0) && o.getVector(0).getValue(0) < WIDTH &&
+
+                    0 < o.getVector(0).getValue(0) && o.getVector(0).getValue(0) < HEIGHT &&
+                    0 < o.getVector(1).getValue(0) && o.getVector(0).getValue(0) < HEIGHT &&
+                    0 < o.getVector(2).getValue(0) && o.getVector(0).getValue(0) < HEIGHT){
+
+                clippedTriangles.add(Old);
+            } // Triangle inside Screen
+
+
+
+
+        }
+        objectsrendering.clear();
+        objectsrendering.addAll(clippedTriangles);*/
+    }
+
+    private void clipPolygon() {
+
+
+    }
+    private void Sortlist() {
+        Collections.sort(objectsrendering, new Comparator<Object>() {
+            @Override
+            public int compare(Object t0, Object t1) {
+                float t0Z = (float) (t0.getVector(1).getValue(2));
+                float t1Z = (float) (t1.getVector(1).getValue(2));
+
+                return Float.valueOf(t1Z).compareTo(t0Z);
+
+            }
+        });
+    }
+
+
+    private void DrawTriangle() {
+        for (Object o : objectsrendering) {
+            Vector pv0 = o.getVector(0);
+            Vector pv1 = o.getVector(1);
+            Vector pv2 = o.getVector(2);
+
+
+            if (pv1.getY() < pv0.getY()) {
+                Vector a = pv0;
+                pv0 = pv1;
+                pv1 = a;
+            }
+            if (pv2.getY() < pv1.getY()) {
+                Vector a = pv1;
+                pv1 = pv2;
+                pv2 = a;
+            }
+            if (pv1.getY() < pv0.getY()) {
+                Vector a = pv0;
+                pv0 = pv1;
+                pv1 = a;
+            }
+            if (pv0.getY() == pv1.getY()) { // natural flat top
+                //sorting vertices
+                if (pv1.getX() < pv0.getX()) {
+                    Vector a = pv0;
+                    pv0 = pv1;
+                    pv1 = a;
+                }
+                int yStart = (int) Math.ceil(pv0.getValue(1) - 0.5);
+                int yEnd = (int) Math.ceil(pv2.getValue(1) - 0.5);
+                DrawTriangleTop(pv0, pv1, pv2, yStart, yEnd);
+            } else if (pv1.getY() == pv2.getY()) {
+                //sorting vertices
+                if (pv2.getX() < pv1.getX()) {
+                    Vector a = pv1;
+                    pv1 = pv2;
+                    pv2 = a;
+                }
+                int yStart = (int) pv0.getValue(1);
+                int yEnd = (int) pv1.getValue(1);
+                DrawTriangleBottom(pv0, pv1, pv2, yStart, yEnd);
+            } else { // general triangle
+                //find splitting vertex
+                final float alphaSplit = (float) ((pv1.getY() - pv0.getY()) / (pv2.getY() - pv0.getY()));
+                final Vector vi = pv0.addVector((pv2.subtract(pv0)).multiplydouble(alphaSplit));
+
+                if (pv1.getX() < vi.getX()) { // major right
+
+
+                    int yStart1 = (int) Math.ceil(pv1.getValue(1) - 0.5);
+                    int yEnd1 = (int) Math.ceil(pv2.getValue(1) - 0.5);
+
+                    DrawTriangleBottom(pv0, pv1, vi, yStart1, yEnd1);
+
+
+                    int yStart = (int) pv0.getValue(1);
+                    int yEnd = (int) pv1.getValue(1);
+
+                    DrawTriangleTop(pv1, vi, pv2, yStart, yEnd); // top flat
+                } else { // major left
+
+
+                    int yStart = (int) pv0.getValue(1);
+                    int yEnd = (int) vi.getValue(1);
+
+                    DrawTriangleBottom(pv0, vi, pv1, yStart, yEnd);
+
+                    int yStart1 = (int) Math.ceil(vi.getValue(1) - 0.5);
+                    int yEnd1 = (int) Math.ceil(pv2.getValue(1) - 0.5); // top flat
+
+
+                    DrawTriangleTop(vi, pv1, pv2, yStart1, yEnd1);
+                }
+            }
+        }
+    }
+
+    private void DrawTriangleBottom(Vector a, Vector b, Vector c, int yStart2, int yEnd2) {
+
+        float m0 = (float) ((b.getValue(0) - a.getValue(0)) / (b.getValue(1) - a.getValue(1)));
+        float m1 = (float) ((c.getValue(0) - a.getValue(0)) / (c.getValue(1) - a.getValue(1)));
+
+        float xmin = (float) Math.min(a.getValue(0), Math.min(b.getValue(0), c.getValue(0)));
+        float xmax = (float) Math.max(a.getValue(0), Math.max(b.getValue(0), c.getValue(0)));
+
+        float curx1 = (float) (a.getValue(0));
+        float curx2 = (float) (a.getValue(0));
+
+        int yStart = (int) a.getValue(1);
+        int yEnd = (int) b.getValue(1);
+
+        for (int y = yStart; y <= yEnd; y++) {
+            for (int x = (int) curx1; x < curx2; x++) {
+
+                if (x < xmin) {
+                    x = (int) xmin;
+                }
+                if (x < 0) {
+                    x = 0;
+                }
+                if (xmax < x) {
+                    break;
+                }
+                if (0 < x && x < WIDTH && 0 < y && y < HEIGHT) {
+
+                    float z = getZ(a, b, c, curx1, curx2, x, yStart, yEnd, y, false, yStart2, yEnd2);
+                    TrianglegetColor(x, y, z);
+                }
+            }
+            curx1 += m0;
+            curx2 += m1;
+        }
+    }
+
+    private void DrawTriangleTop(Vector a, Vector b, Vector c, int yStart2, int yEnd2) { // a = ymax c = xmin
+
+        float m0 = (float) ((c.getValue(0) - a.getValue(0)) / (c.getValue(1) - a.getValue(1)));
+        float m1 = (float) ((c.getValue(0) - b.getValue(0)) / (c.getValue(1) - b.getValue(1)));
+
+        int yStart = (int) Math.ceil(a.getValue(1) - 0.5);
+        int yEnd = (int) Math.ceil(c.getValue(1) - 0.5);
+        if (yStart > HEIGHT) {
+            yStart = HEIGHT;
+        }
+        if (yEnd > HEIGHT) {
+            yEnd = HEIGHT;
+        }
+
+        if (yEnd < 0) {
+            yEnd = 0;
+        }
+        for (int y = yStart; y < yEnd; y++) {
+            final float px0 = (float) ((m0 * (y + 0.5 - a.getValue(1))) + a.getValue(0));
+            final float px1 = (float) ((m1 * (y + 0.5 - b.getValue(1))) + b.getValue(0));
+
+
+            int xStart = (int) (Math.ceil(px0 - 0.5));
+            int xEnd = (int) (Math.ceil(px1 - 0.5));
+            if (xStart > WIDTH) {
+                xStart = WIDTH;
+            }
+            if (xEnd > WIDTH) {
+                xEnd = WIDTH;
+            }
+            if (xStart < 0) {
+                xStart = 0;
+            }
+            if (xEnd < 0) {
+                xEnd = 0;
+            }
+            for (int x = xStart; x < xEnd; x++) {
+                if (x < 0) {
+                    x = 0;
+                }
+                if (WIDTH < x) {
+                    break;
+                }
+                if (0 < x && x < WIDTH && 0 < y && y < HEIGHT) {
+
+                    float z = getZ(a, b, c, xStart, xEnd, x, yStart, yEnd, y, true, yStart2, yEnd2);
+
+                    TrianglegetColor(x, y, z);
+                }
+            }
+        }
+    }
+
+    private float getZ(Vector p1, Vector p2, Vector p3, float xStart, float xEnd, float x, float yStart, float yEnd, float y, boolean TopBottom, int yStart2, int yEnd2) {
+
+        float z1 = (float) (p1.getValue(2)); //xmin
+        float z2 = (float) (p2.getValue(2)); //xmax
+        float z3 = (float) (p3.getValue(2)); //ymax
+        /*
+        if (z1 < 0) {
+            z1 = 0;
+        }
+        if (z2 < 0) {
+            z2 = 0;
+        }
+        if (z3 < 0) {
+            z3 = 0;
+        }*/
+
+        float xpercentage = (x - xStart) / (xEnd - xStart);
+
+        float ypercentage;
+        if (TopBottom) {
+            ypercentage = ((y - yStart) + yEnd2 - yStart2) / (yEnd - yStart + yEnd2 - yStart2);
+        } else {
+
+            ypercentage = (y - yStart) / (yEnd - yStart + yEnd2 - yStart2);
+        }
+
+        float a1 = (1 - ypercentage);
+        float b1 = (ypercentage) * (xpercentage);
+        float c1 = (ypercentage) * (1 - xpercentage);
+
+        return z1 * a1 + z2 * b1 + z3 * c1; // z
+    }
+
+    private void TrianglegetColor(int x, int y, float z) {
+
+        if (z < pDepthBuffer[x][y]) {
+            pDepthBuffer[x][y] = z;
+
+            canvas.drawPoint(x, y, paint);
+        }
+    }
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/Triangle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/Triangle.java	(date 1566855318148)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/Triangle.java	(date 1566855318148)
@@ -0,0 +1,129 @@
+package com.jacobjacob.ttproject.OpenGL.Shapes;
+
+import android.opengl.GLES20;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+
+/*
+ * A triangle with 3 vertices.
+ */
+public class Triangle {
+    //https://github.com/ibraimgm/opengles2-2d-demos/blob/master/src/ibraim/opengles2/Triangle2dActivity.java
+
+
+    //private class Triangle2dRenderer //implements GLSurfaceView.Renderer
+    //{
+    private int vertexHandle;
+    private int fragmentHandle;
+    private int programHandle = -1;
+
+    // These two methods help to Load/Unload the shaders used by OpenGL Es 2.0
+    // Remember that now OpenGL DOES NOT CONTAIN most of the 'old' OpenGL functions;
+    // Now you need to create your own vertex and fragment shaders. Yay!
+    public void setup() {
+        // make sure there's nothing already created
+        tearDown();
+
+        // Vertex shader source.
+        // This shader uses a constant 4x4 matrix 'uScreen' and multiplies it to
+        // the parameter aPosition. The x and y values of aPosition will be filled with
+        // the vertices of our triangle. uScreen will be a matrix that, when multiplied
+        // with the values of our position will CONVERT these values to the OpenGL coordinate
+        // system. This way we can, say, inform our coordinates in 'pixels' and let OpenGL
+        // figure out were the hell the pixels are. More on this later.
+        String vertexSrc = "uniform mat4 uScreen;\n" + "attribute vec2 aPosition;\n" + "void main() {\n" + "  gl_Position = uScreen * vec4(aPosition.xy, 0.0, 1.0);\n" + "}";
+
+        // Our fragment shader. Always returns the color RED.
+        String fragmentSrc = "precision mediump float;\n" + "void main(void)\n" + "{\n" + "  gl_FragColor = vec4(1, 0, 0, 1);\n" + "}";
+
+        // Lets load and compile our shaders, link the program
+        // and tell OpenGL ES to use it for future drawing.
+        vertexHandle = loadShader(GLES20.GL_VERTEX_SHADER, vertexSrc);
+        fragmentHandle = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSrc);
+        programHandle = createProgram(vertexHandle, fragmentHandle);
+
+        GLES20.glUseProgram(programHandle);
+    }
+
+    public void tearDown() {
+        if (programHandle != -1) {
+            GLES20.glDeleteProgram(programHandle);
+            GLES20.glDeleteShader(vertexHandle);
+            GLES20.glDeleteShader(fragmentHandle);
+        }
+    }
+
+    // auxiliary shader functions. Doesn't matter WHAT you're trying to do, they're
+    // always the same thing.
+    private int loadShader(int shaderType, String shaderSource) {
+        int handle = GLES20.glCreateShader(shaderType);
+
+        if (handle == GLES20.GL_FALSE) throw new RuntimeException("Error creating shader!");
+
+        // set and compile the shader
+        GLES20.glShaderSource(handle, shaderSource);
+        GLES20.glCompileShader(handle);
+
+        // check if the compilation was OK
+        int[] compileStatus = new int[1];
+        GLES20.glGetShaderiv(handle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);
+
+        if (compileStatus[0] == 0) {
+            String error = GLES20.glGetShaderInfoLog(handle);
+            GLES20.glDeleteShader(handle);
+            throw new RuntimeException("Error compiling shader: " + error);
+        } else return handle;
+    }
+
+    private int createProgram(int vertexShader, int fragmentShader) {
+        int handle = GLES20.glCreateProgram();
+
+        if (handle == GLES20.GL_FALSE) throw new RuntimeException("Error creating program!");
+
+        // attach the shaders and link the program
+        GLES20.glAttachShader(handle, vertexShader);
+        GLES20.glAttachShader(handle, fragmentShader);
+        GLES20.glLinkProgram(handle);
+
+        // check if the link was successful
+        int[] linkStatus = new int[1];
+        GLES20.glGetProgramiv(handle, GLES20.GL_LINK_STATUS, linkStatus, 0);
+
+        if (linkStatus[0] == 0) {
+            String error = GLES20.glGetProgramInfoLog(handle);
+            GLES20.glDeleteProgram(handle);
+            throw new RuntimeException("Error in program linking: " + error);
+        } else return handle;
+    }
+
+
+    public void onDrawFrame() {
+        // get the position of 'aPosition'
+        int aPos = GLES20.glGetAttribLocation(programHandle, "aPosition");
+
+        // The triangle vertices. Note how I'm using
+        // a 'pixel' coordinate system. This is not in the center of the
+        // screen or anything; this is in absolute position, will vary depending
+        // on the size of your display.
+        float[] data = {0, WIDTHSCREEN, HEIGHTSCREEN, WIDTHSCREEN, HEIGHTSCREEN, 0,};
+
+        // Again, a FloatBuffer will be used to pass the values
+        FloatBuffer b = ByteBuffer.allocateDirect(data.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer();
+        b.put(data).position(0);
+
+        // Enable and set the vertex attribute to accept our array.
+        // This makes possible to inform all of the vertices in one call.
+        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 0, b);
+        GLES20.glEnableVertexAttribArray(aPos);
+
+        // Clear the screen and draw the triangle
+        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);
+    }
+    //}
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Old/Triangle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Old/Triangle.java	(date 1566305118100)
+++ app/src/main/java/com/jacobjacob/ttproject/Old/Triangle.java	(date 1566305118100)
@@ -0,0 +1,47 @@
+package com.jacobjacob.ttproject.Old;
+
+import com.jacobjacob.ttproject.Vector;
+
+public class Triangle implements Object{
+    private Vector A,B,C,Normal;
+
+    public Triangle(Vector A, Vector B, Vector C){
+        this.A=A;
+        this.B = B;
+        this.C = C;
+        Normal = B.subtract(A).cross(C.subtract(A)).normalize();
+    }
+    public Vector getVector(int vector){
+        if (vector == 0){
+            return A;
+        }
+        else if (vector == 1){
+            return B;
+        }
+        else if (vector == 2){
+            return C;
+        }
+        else return A;
+    }
+    public Vector getNormal(){
+        return Normal;
+    }
+    public void setVector(Vector input, int vectorposition){
+        if (vectorposition == 0){
+            A = input;
+        }
+        if (vectorposition == 1){
+            B = input;
+        }
+        if (vectorposition == 2){
+            C = input;
+        }
+    }
+
+    public Triangle addVector(Vector Offsetadd){
+        this.A.add(Offsetadd);
+        this.B.add(Offsetadd);
+        this.C.add(Offsetadd);
+        return new Triangle(A,B,C);
+    }
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Input/CustomButtons.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Input/CustomButtons.java	(date 1567883248683)
+++ app/src/main/java/com/jacobjacob/ttproject/Input/CustomButtons.java	(date 1567883248683)
@@ -0,0 +1,240 @@
+package com.jacobjacob.ttproject.Input;
+
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+import android.util.Log;
+
+import com.jacobjacob.ttproject.OpenGL.Shapes.Square;
+import com.jacobjacob.ttproject.Vector;
+
+import static com.jacobjacob.ttproject.Util.CHUNKCOLOR;
+import static com.jacobjacob.ttproject.Util.COLORDEBUG;
+import static com.jacobjacob.ttproject.Util.FILE_NAME;
+import static com.jacobjacob.ttproject.Util.FILE_NAMES;
+import static com.jacobjacob.ttproject.Util.FILLTILECOLOR;
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.LE;
+import static com.jacobjacob.ttproject.Util.LEVELINT;
+import static com.jacobjacob.ttproject.Util.MOVE;
+import static com.jacobjacob.ttproject.Util.SETTINGS_OPENGL;
+import static com.jacobjacob.ttproject.Util.TILESIZE;
+import static com.jacobjacob.ttproject.Util.TOUCHCUSTOMBUTTONS;
+import static com.jacobjacob.ttproject.Util.TOUCHPOSITION;
+import static com.jacobjacob.ttproject.Util.TOUCHSTATE;
+import static com.jacobjacob.ttproject.Util.WF;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+import static com.jacobjacob.ttproject.Util.camera;
+import static com.jacobjacob.ttproject.Util.movespeed;
+
+public class CustomButtons {
+
+    Vector Position;
+    float Width, Height;
+    String Text;
+    int Type, color = Color.rgb(255, 0, 0);
+    Rect Box;
+    Square BoundingBox;
+
+    float left, right, top, bottom;
+
+    //TODO Button implementations and Seekbar code for r g and b as well as a and the animationtime
+
+    /**
+     * Create a new Button with a Position, a Width and a Height as well as a Type
+     *
+     * @param Type     either a joystick or a button
+     * @param Position The Position in Screenspacecoordinates and is directly at the center of the shape, could get inverted if OpenGl coordinates kick in
+     * @param Width    total width from left to right of the shape
+     * @param Height   total height from top to bottom
+     * @param Colorint The color of the Button
+     */
+    public CustomButtons(int Type, Vector Position, float Width, float Height, int Colorint) {
+        this.Position = Position;
+        this.Width = Width;
+        this.Height = Height;
+        this.Type = Type;
+        this.color = Colorint;
+
+        float left = (float) (this.Position.getX() - (this.Width / 2));
+        float right = (float) (this.Position.getX() + (this.Width / 2));
+        float top = (float) (this.Position.getY() - (this.Height / 2));
+        float bottom = (float) (this.Position.getY() + (this.Height / 2));
+
+        this.Box = new Rect((int) (left), (int) (top), (int) (right), (int) (bottom));
+
+        this.BoundingBox = new Square(new Vector(left, top), new Vector(right, top), new Vector(right, bottom), new Vector(left, bottom), Color.rgb(255, 0, 150));
+
+        this.left = 2 * ((left / WIDTHSCREEN) * 2 - 1);
+        this.right = 2 * ((right / WIDTHSCREEN) * 2 - 1);
+        this.top = -2 * ((top / HEIGHTSCREEN) * 2 - 1);
+        this.bottom = -2 * ((bottom / HEIGHTSCREEN) * 2 - 1);
+    }
+
+    /**
+     * Create a new Button with a Position, a Width and a Height as well as a Type
+     *
+     * @param Type     either a joystick or a button
+     * @param Position The Position in Screenspacecoordinates and is directly at the center of the shape, could get inverted if OpenGl coordinates kick in
+     * @param Width    total width from left to right of the shape
+     * @param Height   total height from top to bottom
+     * @param Text     The Text displayed on top of the button
+     * @param Colorint The color of the Button
+     */
+    public CustomButtons(int Type, Vector Position, float Width, float Height, String Text, int Colorint) {
+        this.Position = Position;
+        this.Width = Width;
+        this.Height = Height;
+        this.Type = Type;
+        this.color = Colorint;
+        this.Box = new Rect((int) (this.Position.getX() - (this.Width / 2)), (int) (this.Position.getY() - (this.Height / 2)), (int) (this.Position.getX() + (this.Width / 2)), (int) (this.Position.getY() + (this.Height / 2)));
+    }
+
+    //TODO Better Buttons class. Maybe an Interface
+
+    /**
+     * Joystickcode to Control the Cameras x and y Values
+     */
+    public void CustomJoyStick() {
+        Vector Movementvalue = this.Position.subtract(TOUCHPOSITION);
+        float MaxMovementDist = (float) (Math.sqrt(this.Width * this.Width + this.Height * this.Height) / 2); // is int Screen/ Pixelspace, might be too much
+        //MaxMovementDist = 1;
+
+        MaxMovementDist = HEIGHTSCREEN;
+
+        if (Movementvalue.length() > MaxMovementDist) {
+            Movementvalue = (Movementvalue.normalize()).multiplydouble(MaxMovementDist);
+        }
+
+        Movementvalue.setZ((float) camera.getEye2D().getZ()); // offset!!
+
+
+        int r = (int) (255 * (1 - Math.sin(Math.abs(Movementvalue.normalize().getX()))));
+        int g = (int) (255 * (1 - Math.sin(Math.abs(Movementvalue.normalize().getY()))));
+
+        COLORDEBUG = Color.rgb(r, g, 0);
+
+        float lenghtMiddleTouch = (float) (this.Position.subtract(TOUCHPOSITION)).length();
+        float lenghtMiddleVertex = (float) Math.sqrt(this.Width * this.Width + this.Height * this.Height) / 2;
+
+        Movementvalue.setZ(0);
+        Movementvalue = Movementvalue.normalize().negate().multiplydouble(TILESIZE);
+
+        float Strengthmovement = lenghtMiddleTouch / lenghtMiddleVertex;
+
+        Movementvalue = Movementvalue.multiplydouble(Strengthmovement);
+
+        Log.d("Position:", "X: " + (Movementvalue.getX()) + " Y: " + (Movementvalue.getY()) + " Z: " + (Movementvalue.getZ() + " Color: " + COLORDEBUG));
+
+        MOVE.Move(Movementvalue);
+    }
+
+    public void MoveUPDOWN() {
+        if (this.Type == 1) {
+            camera.move2D(new Vector(0, 0, movespeed / 5)); // moves the Camera down
+        } else {
+            camera.move2D(new Vector(0, 0, -movespeed / 5)); // moves the Camera up
+        }
+    }
+
+    public void SelectLVL() { // only adds one to the counter and loads the next level
+        LEVELINT++;
+        if (FILE_NAMES.size() <= LEVELINT) {
+            LEVELINT = 0;
+        }
+        LE.SaveLevel();
+
+        FILE_NAME = FILE_NAMES.get(LEVELINT);//adapterView.getSelectedItem().toString();
+
+        LE.LoadLevel();
+
+
+        //TILETEXTURE.deleteTextures();
+        //TILETEXTURE.deleteNormals();
+
+
+        //for(int i = 0; i < 10; i++){ // 10 number of updated Materials
+        //    TILETEXTURE.UpdateMaterialTexture(i);
+        //    TILETEXTURE.UpdateMaterialNormalTexture(i);
+        //}
+
+
+        //TILETEXTURE.updateTextures();        // working // reloads all the important Textures into opengl
+        //TILETEXTURE.updateTexturesNormals(); // working // reloads all the important Textures into opengl
+    }
+
+    /**
+     * Takes the Type int into account and then runs the buttonspecific Code
+     */
+    public void UpdateButton() {
+        if (this.Box.contains((int) TOUCHPOSITION.getValue(0), (int) TOUCHPOSITION.getValue(1))) {
+            TOUCHCUSTOMBUTTONS = true;
+            if (this.Type == 0) {
+                CustomJoyStick();
+            }
+            if (this.Type == 1 || this.Type == 2) {
+                MoveUPDOWN();
+            }
+            if (this.Type == 3) {
+                if (TOUCHSTATE == 0) { // if the touch is down, not if moving or up
+                    SelectLVL();
+                }
+            }
+            if (this.Type == 4) {
+                if (TOUCHSTATE == 0) {
+
+                    SETTINGS_OPENGL = !SETTINGS_OPENGL;
+                    if (SETTINGS_OPENGL) {
+                        this.color = FILLTILECOLOR; // Green
+                    } else {
+                        this.color = CHUNKCOLOR; // Red
+                    }
+                    WF.SaveSettings();
+
+                }
+            }
+        }
+    }
+
+    /**
+     * Draws the boundingbox with a solid, previously given color
+     */
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public void draw() {
+        BoundingBox.draw();
+    }
+
+    public void CustomToggleButton() {
+
+    }
+
+    /**
+     * Returns a Rectangle in Screenspace for the Boundingbox of the Button
+     *
+     * @return Rect left, top, right, bottom
+     */
+    public Rect getBox() {
+        return this.Box;
+    }
+
+    public float getLeft() {
+        return this.left;
+    }
+
+    public float getRight() {
+        return this.right;
+    }
+
+    public float getTop() {
+        return this.top;
+    }
+
+    public float getBottom() {
+        return this.bottom;
+    }
+
+    public int getColor() {
+        return this.color;
+    }
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/Square.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/Square.java	(date 1566845385266)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/Square.java	(date 1566845385266)
@@ -0,0 +1,179 @@
+package com.jacobjacob.ttproject.OpenGL.Shapes;
+
+import android.graphics.Color;
+import android.opengl.GLES20;
+import android.opengl.GLES30;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+
+import com.jacobjacob.ttproject.OpenGL.MainRenderer;
+import com.jacobjacob.ttproject.Vector;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.nio.ShortBuffer;
+
+import static android.opengl.GLES20.glGetError;
+import static com.jacobjacob.ttproject.Util.COLORDEBUG;
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+
+/*
+ * A square drawn in 2 triangles (using TRIANGLE_STRIP).
+ * https://www3.ntu.edu.sg/home/ehchua/programming/android/Android_3D.html
+ */
+
+
+public class Square/*/ extends MainRenderer/**/ {
+    // Constructor - Setup the vertex buffer
+
+    private FloatBuffer _rectangleVFB;
+
+    private float red, green, blue, alpha;
+    private String _rectangleFragmentShaderCode = "attribute vec4 aColor;\n" + "void main() {\n" + " gl_FragColor = vec4(1.0f,0.0g,0.0f,1.0f);\n" // Color of the Rectangle
+            + "}                             \n";
+
+    private int _rectangleProgram, _rectangleAPositionLocation,_rectangleAColorLocation, _rectangleVertexShader, _rectangleFragmentShader;
+
+    private String _rectangleVertexShaderCode = "attribute vec4 aPosition;\n" + "void main() {\n" + " gl_Position = aPosition;\n" + "}\n";
+
+
+    float color[] = {this.red, this.green, this.blue, 1.0f};
+
+    /**
+     * Sqare with 4 points in Screenspace, not -1 1 -1 1 but rather 0 width 0 height
+     *
+     * @param Topleft     Top left point of the shape
+     * @param Topright    Top right point of the shape
+     * @param Bottomright Bottom right point of the shape
+     * @param Bottomleft  Bottom left point of the shape
+     * @param Colorint    Color of the shape
+     */
+    public Square(Vector Topleft, Vector Topright, Vector Bottomright, Vector Bottomleft, int Colorint) {
+
+        //this._rectangleVertexShaderCode = "";
+
+        this.red = (float) (Color.red(Colorint) / 255f);
+        this.green = (float) (Color.green(Colorint) / 255f);
+        this.blue = 1;//(float)(Color.blue(Colorint) /255f);
+        this.alpha = 1;//(float)(Color.alpha(Colorint)/255f);
+
+        this.color = new float[]{this.red, this.green, this.blue, 1.0f};
+
+        initShapes(Topleft, Topright, Bottomright, Bottomleft);
+        FragmentShader();
+
+        this._rectangleVertexShader = loadShader(GLES20.GL_VERTEX_SHADER, this._rectangleVertexShaderCode);
+        this._rectangleFragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, this._rectangleFragmentShaderCode);
+
+
+        this._rectangleProgram = GLES20.glCreateProgram();
+
+
+        GLES20.glAttachShader(this._rectangleProgram, this._rectangleVertexShader);
+        GLES20.glAttachShader(this._rectangleProgram, this._rectangleFragmentShader);
+
+
+        GLES20.glLinkProgram(this._rectangleProgram);
+        this._rectangleAPositionLocation = GLES20.glGetAttribLocation(this._rectangleProgram, "aPosition");
+        //this._rectangleAColorLocation = GLES20.glGetAttribLocation(this._rectangleProgram, "aColor");
+        int a = 5;
+    }
+
+    private void initShapes(Vector Topleft, Vector Topright, Vector Bottomright, Vector Bottomleft) {
+
+
+        float XLT = (float) ((Topleft.getValue(0) / WIDTHSCREEN) * 2 - 1);
+        float YLT = (float) -((Topleft.getValue(1) / HEIGHTSCREEN) * 2 - 1);
+
+        float XRT = (float) ((Topright.getValue(0) / WIDTHSCREEN) * 2 - 1);
+        float YRT = (float) -((Topright.getValue(1) / HEIGHTSCREEN) * 2 - 1);
+
+        float XRB = (float) ((Bottomright.getValue(0) / WIDTHSCREEN) * 2 - 1);
+        float YRB = (float) -((Bottomright.getValue(1) / HEIGHTSCREEN) * 2 - 1);
+
+        float XLB = (float) ((Bottomleft.getValue(0) / WIDTHSCREEN) * 2 - 1);
+        float YLB = (float) -((Bottomleft.getValue(1) / HEIGHTSCREEN) * 2 - 1);
+
+        float rectangleVFA[] = {XLB, YLB, 0, // Bottom left // Triangle 1 A
+                XLT, YLT, 0, // Top left    // Triangle 1 B
+                XRT, YRT, 0, // top right   // Triangle 1 C
+                XRT, YRT, 0, // top right   // Triangle 2 C
+                XRB, YRB, 0, // Bottom right// Triangle 2 D
+                XLB, YLB, 0, // Bottom left // Triangle 2 A
+        };
+
+
+        ByteBuffer rectangleVBB = ByteBuffer.allocateDirect(rectangleVFA.length * 4);
+        rectangleVBB.order(ByteOrder.nativeOrder());
+        this._rectangleVFB = rectangleVBB.asFloatBuffer();
+        this._rectangleVFB.put(rectangleVFA);
+        this._rectangleVFB.position(0);
+    }
+
+    private void FragmentShader() {
+
+        this._rectangleFragmentShaderCode = "uniform vec4(" + this.red + ", " + this.green + "," + this.blue + "," + this.alpha + ");" + "void main() {\n"
+
+                + "gl_FragColor = vColor;\n" // Color of the Rectangle
+                + "}\n";
+
+        //this._rectangleFragmentShaderCode = "void main() {\n"
+
+        //        + "gl_FragColor = vec4(" + this.red + ", " + this.green + "," + this.blue + "," + this.alpha + ");\n" // Color of the Rectangle
+        //        + "}\n";
+    }
+
+    private int loadShader(int type, String source) {
+        int shader = GLES20.glCreateShader(type);
+        GLES20.glShaderSource(shader, source);
+        GLES20.glCompileShader(shader);
+        glGetError();
+        return shader;
+    }
+
+    // Render the shape
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public void draw() {
+
+
+        GLES20.glEnable(GLES20.GL_COLOR_CLEAR_VALUE);
+
+
+        this.red = (float) Color.red(COLORDEBUG) / 255f;
+        this.green = (float) Color.green(COLORDEBUG) / 255f;
+        this.blue = (float) Color.blue(COLORDEBUG) / 255f;
+
+        /**/
+        GLES20.glUseProgram(this._rectangleProgram);
+        GLES20.glVertexAttribPointer(this._rectangleAPositionLocation, 3, GLES20.GL_FLOAT, false, 12, this._rectangleVFB);
+
+
+        //GLES20.glBlendColor(this.red, this.green, this.blue, 1);
+        GLES20.glEnableVertexAttribArray(this._rectangleAPositionLocation);
+
+        GLES30.glClearColor(this.red, this.green, this.blue, 1);
+
+        // get handle to fragment shader's vColor member
+        int mColorHandle = GLES20.glGetUniformLocation(this._rectangleProgram, "gl_FragColor");
+
+
+        // Set color for drawing the triangle
+
+
+
+        GLES20.glUniform4fv(mColorHandle, 1, color, 0);
+
+        //GLES20.glUniform4fv(0,color,0);
+        GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 6);
+
+
+        //GLES20.glDrawElements(GLES20.GL_TRIANGLES,6,GLES20.GL_SHORT,this._rectangleAPositionLocation);
+        GLES20.glDisableVertexAttribArray(this._rectangleAPositionLocation);
+
+    }
+
+
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/RawModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/RawModel.java	(date 1566757263007)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Shapes/RawModel.java	(date 1566757263007)
@@ -0,0 +1,22 @@
+package com.jacobjacob.ttproject.OpenGL.Shapes;
+
+public class RawModel {
+
+    private int vaoID;
+    private int vertexCount;
+
+    public RawModel(int vaoID, int vertexCount){
+        this.vaoID = vaoID;
+        this.vertexCount = vertexCount;
+
+
+    }
+
+    public int getVaoID() {
+        return vaoID;
+    }
+
+    public int getVertexCount() {
+        return vertexCount;
+    }
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Tile/Chunk.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Tile/Chunk.java	(date 1567878473874)
+++ app/src/main/java/com/jacobjacob/ttproject/Tile/Chunk.java	(date 1567878473874)
@@ -0,0 +1,107 @@
+package com.jacobjacob.ttproject.Tile;
+
+import android.graphics.Rect;
+
+import com.jacobjacob.ttproject.Tile.Tile;
+import com.jacobjacob.ttproject.Vector;
+
+import java.util.ArrayList;
+
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.TILESIZE;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+import static com.jacobjacob.ttproject.Util.ZOOMFACTOR;
+import static com.jacobjacob.ttproject.Util.camera;
+
+public class Chunk {
+
+    private int Size = 20;
+    private Rect Boundingbox;
+    private int X, Y;
+
+    private Vector PositionChunkspace;
+
+    private Tile[][] TilesinChunk;
+
+    public Chunk(int X, int Y) { // Position in Chunkspace!!!
+        this.Boundingbox = new Rect(X, Y, X + this.Size, Y + this.Size);
+        this.TilesinChunk = new Tile[this.Size][this.Size];
+        this.X = X;
+        this.Y = Y;
+        this.PositionChunkspace = new Vector(X,Y);
+    }
+
+    /**
+     * Returns the Boundingbox / Hitbox that contains the Tiles
+     *
+     * @return Rect as Boundingbox
+     */
+    public Rect getBoundaries() {
+        return this.Boundingbox;
+    }
+
+    /**
+     * The Position is in Chunkspace, therfore the Width is not the Tilewidth, but the Width of the Chunk * the Tilewidth!!!
+     * @return the Position as a vector
+     */
+    public Vector getPositionRAW(){
+        return this.PositionChunkspace;
+    }
+    public boolean isOnScreen(){
+
+        Vector Cal = new Vector().getScreencoordinatesFromTileCoordinates(this.PositionChunkspace.multiplydouble(this.Size * TILESIZE));
+        float TILESIZEzoom = (float) Math.ceil(this.Size * TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
+
+
+        int left = (int) Cal.getValue(0);//(float) visible.get(i).getPositionRAW().getX() * Scale;//width / height;
+        int top = (int) Cal.getValue(1);//(float) visible.get(i).getPositionRAW().getY() * Scale;
+        int right = (int) (Cal.getValue(0) + TILESIZEzoom);//(float) (visible.get(i).getPositionRAW().getX() + 1) * Scale;
+        int bottom = (int) (Cal.getValue(1) + TILESIZEzoom);//(float) (visible.get(i).getPositionRAW().getY() + 1) * Scale;
+
+        Rect TileRect = new Rect(left,top,right,bottom);
+
+        Rect Screen = new Rect(0,0,WIDTHSCREEN,HEIGHTSCREEN);
+
+        if (Screen.contains(TileRect) || Screen.intersect(TileRect)) {
+            return true;
+        }else {
+            return false;
+        }
+    }
+
+    public void addTile(Tile TileToAdd) {
+        if (this.Boundingbox.contains(TileToAdd.getBoundaries())) {
+            TilesinChunk[(int) (this.X - TileToAdd.getPositionRAW().getX())][(int) (this.Y - TileToAdd.getPositionRAW().getY())] = TileToAdd;
+        }
+    }
+
+    public Tile getTile(int X,int Y) {
+        if (this.Boundingbox.contains(X,Y)) {
+            try {
+                return this.TilesinChunk[this.X - X][this.Y - Y];
+            }catch (Exception e){
+                try {
+                    return this.TilesinChunk[X - this.X][Y - this.Y];
+                }catch (Exception f){
+
+                }
+            }
+        }
+        return null;
+    }
+
+    public void removeTile(){
+
+    }
+
+    public ArrayList<Tile> getTilesInCurrentChunk() { // up to which Iteration you want the Boundary
+        ArrayList<Tile> returnTilesInChunk = new ArrayList<>();
+        for(int i = 0; i < this.Size; i++) {
+            for (int j = 0; j < this.Size; j++) {
+                returnTilesInChunk.add(this.TilesinChunk[i][j]);
+            }
+        }
+        return returnTilesInChunk;
+    }
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/OpenGL/Load/Loader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/OpenGL/Load/Loader.java	(date 1566762649670)
+++ app/src/main/java/com/jacobjacob/ttproject/OpenGL/Load/Loader.java	(date 1566762649670)
@@ -0,0 +1,76 @@
+package com.jacobjacob.ttproject.OpenGL.Load;
+
+import android.opengl.GLES20;
+import android.opengl.GLES30;
+import android.os.Build;
+import android.support.annotation.RequiresApi;
+
+import com.jacobjacob.ttproject.OpenGL.Shapes.RawModel;
+
+import java.nio.FloatBuffer;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Loader {
+
+    private List<Integer> vaos = new ArrayList<>();
+    private List<Integer> vbos = new ArrayList<>();
+
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public RawModel loadToVAO(float[] positions) {
+        int vaoID = createVAO();
+        storeDataInAttributeList(0, positions);
+        unbindVAO();
+        return new RawModel(vaoID, positions.length / 3);
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    private int createVAO() {
+        int vaoID = vaos.get(vaos.size() ) + 1;// = GLES30.glGenVertexArrays();
+        GLES30.glBindVertexArray(vaoID);
+        vaos.add(vaoID);
+        return vaoID;
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    public void cleanUP(){
+        for (int vao:vaos){
+            GLES30.glDeleteVertexArrays(vao,null);
+        }
+        for (int vbo:vbos){
+            GLES30.glDeleteBuffers(vbo,null);
+        }
+    }
+
+    private void storeDataInAttributeList(int attributeNumber, float[] data) {
+
+        int[] dataint = new int[data.length];
+        for (int i = 0; i < data.length; i++){
+            dataint[i] =(int) data[i];
+        }
+
+        GLES30.glGenBuffers(GLES30.GL_ARRAY_BUFFER,dataint,0);
+
+        FloatBuffer buffer = storeDataInFloatBuffer(data);
+        GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, buffer.array().length, buffer, GLES20.GL_STATIC_DRAW);
+        GLES20.glVertexAttribPointer(attributeNumber, 3, GLES20.GL_FLOAT, false, 0, 0);
+
+        int vaoID = vaos.get(vaos.size()) + 1;
+        GLES20.glBindBuffer(GLES30.GL_ARRAY_BUFFER, vaoID);
+        vbos.add(vaoID);
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    private void unbindVAO() {
+        GLES30.glBindVertexArray(0);
+    }
+
+    private FloatBuffer storeDataInFloatBuffer(float[] data) {
+        FloatBuffer buffer = null;// = //new FloatBuffer(0,0,data.length,data.length);//BufferUtils.create;
+        buffer.put(data);
+        buffer.flip();
+        return buffer;
+    }
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Light/PointLight.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Light/PointLight.java	(date 1567462782561)
+++ app/src/main/java/com/jacobjacob/ttproject/Light/PointLight.java	(date 1567462782561)
@@ -0,0 +1,42 @@
+package com.jacobjacob.ttproject.Light;
+
+import android.graphics.Color;
+
+import com.jacobjacob.ttproject.Vector;
+
+public class PointLight {
+    Vector Positionvec;
+    int Colorint;
+
+    public PointLight(Vector Position){
+        this.Positionvec = Position;
+        this.Colorint = Color.rgb(255,255,255);
+    }
+
+    /**
+     * Lightconstructor
+     * @param Position Position of light as raw
+     * @param Colorint Color of the Light as int
+     */
+    public PointLight(Vector Position,int Colorint){
+        this.Positionvec = Position;
+        this.Colorint = Colorint;
+    }
+
+    public void setPositionvec(Vector positionvec) {
+        Positionvec = positionvec;
+    }
+
+    public void setColorint(int colorint) {
+        Colorint = colorint;
+    }
+
+    public Vector getPositionvec() {
+        return Positionvec;
+    }
+
+    public int getColorint() {
+        return Colorint;
+    }
+
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Tile/KdTreeChunks.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Tile/KdTreeChunks.java	(date 1567878473858)
+++ app/src/main/java/com/jacobjacob/ttproject/Tile/KdTreeChunks.java	(date 1567878473858)
@@ -0,0 +1,392 @@
+package com.jacobjacob.ttproject.Tile;
+
+
+import android.graphics.Rect;
+
+import com.jacobjacob.ttproject.Vector;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
+import static com.jacobjacob.ttproject.Util.KDTREEMAXITEMS;
+import static com.jacobjacob.ttproject.Util.TILESIZE;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+import static com.jacobjacob.ttproject.Util.ZOOMFACTOR;
+import static com.jacobjacob.ttproject.Util.camera;
+
+public class KdTreeChunks {
+
+
+    private ArrayList<Chunk> ChunksInCurrentTree;
+    private ArrayList<Chunk> ChunkChildren1 = new ArrayList<>(); // Top / Right
+    private ArrayList<Chunk> ChunkChildren2 = new ArrayList<>(); // Bottom / Left
+
+    private ArrayList<KdTreeChunks> Children = new ArrayList<>();
+
+    private Rect BoundaryOld;
+    private boolean hasChildren = false;
+    private int Iteration = 0;
+    private int[][] TileMaterialint;
+    int Boundary;
+
+/*/
+    public KdTreeChunks(ArrayList<Chunk> Chunks, Rect BoundaryOld, int Iteration) {
+
+        this.ChunksInCurrentTree = Chunks;
+        this.Iteration = Iteration;
+        this.BoundaryOld = BoundaryOld;
+
+
+        this.Boundary = (int) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
+
+        int X = this.BoundaryOld.width() + 2;
+        int Y = this.BoundaryOld.height() + 2;
+
+        this.TileMaterialint = new int[X][Y]; // must be bigger to give the Tiles on the edges the right Orientation
+
+        for (int i = 0; i < X; i++) {
+            for (int j = 0; j < Y; j++) {
+                this.TileMaterialint[i][j] = -1;
+
+            }
+        }
+
+        if ((KDTREEMAXITEMS) < this.ChunksInCurrentTree.size() && Iteration < 20) {
+            Split();
+        }
+        if (1 < this.ChunksInCurrentTree.size()) {
+            CheckIntersections();
+        }
+    }
+
+    public KdTreeChunks() {
+
+    } // to create the Kd Tree at the start
+
+    public void setChunksInCurrentTree(ArrayList<Chunk> ChunksInCurrentTree) {
+        this.ChunksInCurrentTree = ChunksInCurrentTree;
+    }
+
+    public void addTilesInCurrentTree(ArrayList<Chunk> ChunksInCurrentTree) {
+        try {
+            this.ChunksInCurrentTree.addAll(ChunksInCurrentTree);
+        }catch (Exception e){
+
+        }
+    }
+
+    public void CreatenewKDTree() {
+        try {
+
+            int minX = 999, minY = 999, maxX = -999, maxY = -999;
+
+            if (this.Iteration == 0) {
+
+                ArrayList<Chunk> allChunks = getChunksInCurrentTree();
+                this.ChunksInCurrentTree.clear();
+                this.ChunksInCurrentTree.addAll(allChunks);
+                this.Children.clear();
+                this.hasChildren = false;
+
+                for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                    if (this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0) < minX) {
+                        minX = (int) this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0);
+                    }
+                    if (this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1) < minY) {
+                        minY = (int) this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1);
+                    }
+                    if (this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0) > maxX) {
+                        maxX = (int) this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0);
+                    }
+                    if (this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1) > maxY) {
+                        maxY = (int) this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1);
+                    }
+                }
+                minX -= 1;
+                minY -= 1;
+                maxX += 1;
+                maxY += 1;
+                this.BoundaryOld = new Rect(minX, minY, maxX, maxY);
+
+                int X = this.BoundaryOld.width() + 2;
+                int Y = this.BoundaryOld.height() + 2;
+                if (X < 0) {
+                    X = 0;
+                }
+                if (Y < 0) {
+                    Y = 0;
+                }
+                this.TileMaterialint = new int[X][Y]; // must be bigger to give the Tiles on the edges the right Orientation
+                for (int i = 0; i < X; i++) {
+                    for (int j = 0; j < Y; j++) {
+                        this.TileMaterialint[i][j] = -1;
+
+                    }
+                }
+
+                this.Boundary = (int) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
+            }
+
+            if (( KDTREEMAXITEMS) < this.ChunksInCurrentTree.size()) { // THE MAXIMUM IN A GIVEN CELL IS NOW KDTREEMMAXITEMS, SINCE THE TREE GETS DEVIDED INTO TWO CHILDREN HALF AS BIG
+                Split();
+            }
+        }catch (Exception e){
+
+        }
+    }
+
+
+    private void Split() {
+        float XMIDDLE = 0;
+        float YMIDDLE = 0;
+
+        KdTreeChunks KdTree1;
+        KdTreeChunks KdTree2;
+        Rect BoundaryChildren1;
+        Rect BoundaryChildren2;
+
+        if (this.Iteration % 2 == 0) { // Starts with the Y split ----
+
+            for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                YMIDDLE += this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1);
+            }
+
+            YMIDDLE /= this.ChunksInCurrentTree.size();
+            YMIDDLE = (int) YMIDDLE;
+
+
+            for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                if (this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1) + 0.5 > YMIDDLE) { // Ysplit
+                    this.ChunkChildren1.add(this.ChunksInCurrentTree.get(i));
+                } else {
+                    this.ChunkChildren2.add(this.ChunksInCurrentTree.get(i));
+                }
+            }
+
+            BoundaryChildren1 = new Rect(this.BoundaryOld.left, (int) YMIDDLE, this.BoundaryOld.right, this.BoundaryOld.bottom); // Bottom Rect
+            BoundaryChildren2 = new Rect(this.BoundaryOld.left, this.BoundaryOld.top, this.BoundaryOld.right, (int) YMIDDLE); // Top Rect
+
+
+            KdTree1 = new KdTreeChunks(this.ChunkChildren1, BoundaryChildren1, this.Iteration + 1); // Top new Tree
+            KdTree2 = new KdTreeChunks(this.ChunkChildren2, BoundaryChildren2, this.Iteration + 1); // Bottom new Tree
+
+
+        } else { // Continues with the X split |  |
+
+            for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                XMIDDLE += this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0);
+            }
+            XMIDDLE /= this.ChunksInCurrentTree.size();
+            XMIDDLE = (int) XMIDDLE;
+
+
+            for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                if (this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0) + 0.5  < XMIDDLE) { // Xsplit
+                    this.ChunkChildren1.add(this.ChunksInCurrentTree.get(i)); // Left from Xall
+                } else {
+                    this.ChunkChildren2.add(this.ChunksInCurrentTree.get(i)); // Right from Xall
+                }
+            }
+
+            BoundaryChildren1 = new Rect(this.BoundaryOld.left, this.BoundaryOld.top, (int) XMIDDLE, this.BoundaryOld.bottom); // left Rect
+            BoundaryChildren2 = new Rect((int) XMIDDLE, this.BoundaryOld.top, this.BoundaryOld.right, this.BoundaryOld.bottom); // right Rect
+
+            KdTree1 = new KdTreeChunks(this.ChunkChildren1, BoundaryChildren1, this.Iteration + 1); // Left new Tree
+            KdTree2 = new KdTreeChunks(this.ChunkChildren2, BoundaryChildren2, this.Iteration + 1); // Right new Tree
+        }
+
+        this.ChunksInCurrentTree.clear();
+        this.hasChildren = true;
+        this.Children.clear();
+        this.Children.add(KdTree1);
+        this.Children.add(KdTree2);
+    }
+
+
+    public ArrayList<Chunk> getChunksInCurrentTree() { // up to which Iteration you want the Boundary
+        ArrayList<Chunk> returnChunksfromChildren = new ArrayList<>();
+        if (this.ChunksInCurrentTree != null) {
+            returnChunksfromChildren.addAll(this.ChunksInCurrentTree);
+        }
+        for (int i = 0; i < this.Children.size(); i++) {
+            returnChunksfromChildren.addAll(this.Children.get(i).getChunksInCurrentTree());
+        }
+        return returnChunksfromChildren;
+    }
+
+    public ArrayList<Rect> getBoundaries() { // up to which Iteration you want the Boundary
+
+        ArrayList<Rect> Boundary = new ArrayList<>();
+        if (this.hasChildren) {
+            // Checks own Visibility
+
+            Vector a = new Vector(this.BoundaryOld.left, this.BoundaryOld.top).multiplydouble(TILESIZE);
+            Vector b = new Vector(this.BoundaryOld.right, this.BoundaryOld.bottom).multiplydouble(TILESIZE);
+
+            a = a.getScreencoordinatesFromTileCoordinates(a);
+            b = b.getScreencoordinatesFromTileCoordinates(b);
+
+            Rect CURRENTOnScreen = new Rect((int) a.getValue(0), (int) a.getValue(1), (int) b.getValue(0), (int) b.getValue(1));
+
+            Rect Screenboundaries = new Rect(-this.Boundary, -this.Boundary, WIDTHSCREEN + this.Boundary, HEIGHTSCREEN + this.Boundary);
+
+
+            if (Screenboundaries.contains(CURRENTOnScreen) && !Screenboundaries.intersect(CURRENTOnScreen) && this.Iteration == 0) {
+                Boundary.add(this.BoundaryOld);
+            } else {
+                if (Screenboundaries.intersect(CURRENTOnScreen) || Screenboundaries.contains(CURRENTOnScreen)) {
+                    for (int i = 0; i < this.Children.size(); i++) {
+                        Boundary.addAll(this.Children.get(i).getBoundaries());
+                    }
+                }
+            }
+        } else {
+            if (this.ChunksInCurrentTree != null && this.ChunksInCurrentTree.size() > 0) {
+                Boundary.add(this.BoundaryOld);
+            }
+        }
+        return Boundary;
+    }
+
+    //TODO make new sorting System to get the visible Tiles more efficently and faster!!!
+    public ArrayList<Tile> getVisibleTilesInCurrentTree() { // Looks like it Works!
+        ArrayList<Tile> returnTilesfromChildren = new ArrayList<>();
+
+        if (this.hasChildren) {
+            // Checks own Visibility
+            Rect Screenboundaries = new Rect(0, 0, WIDTHSCREEN, HEIGHTSCREEN);
+
+
+            Vector a = new Vector(this.BoundaryOld.left, this.BoundaryOld.top).multiplydouble(TILESIZE);
+            Vector b = new Vector(this.BoundaryOld.right, this.BoundaryOld.bottom).multiplydouble(TILESIZE);
+
+            a = a.getScreencoordinatesFromTileCoordinates(a);
+            b = b.getScreencoordinatesFromTileCoordinates(b);
+
+            Rect CURRENTOnScreen = new Rect((int) a.getValue(0), (int) a.getValue(1), (int) b.getValue(0), (int) b.getValue(1));
+
+            if (Screenboundaries.contains(CURRENTOnScreen) && !Screenboundaries.intersect(CURRENTOnScreen)) {
+                returnTilesfromChildren.addAll(getAllTilesBelow());
+            } else {
+                if (Screenboundaries.intersect(CURRENTOnScreen)) {
+                    for (int i = 0; i < this.Children.size(); i++) {
+                        returnTilesfromChildren.addAll(this.Children.get(i).getVisibleTilesInCurrentTree());
+                    }
+                }
+            }
+        } else {
+            try {
+                for (int i = 0; i < this.ChunksInCurrentTree.size();i++) {
+                    if (this.ChunksInCurrentTree.get(i).isOnScreen()){
+                        returnTilesfromChildren.add(this.ChunksInCurrentTree.get(i));
+                    }
+                }
+            }catch (Exception e){
+
+            }
+        }
+        return returnTilesfromChildren;
+
+    }
+
+    public ArrayList<Tile> getTilesInsideBoundary(Rect Boundary) { // Looks like it Works!
+        ArrayList<Tile> returnTilesfromChildren = new ArrayList<>();
+
+        for (int i = Boundary.left - 1; i < Boundary.left + 1 + Boundary.width(); i++) {
+            for (int j = Boundary.top - 1; j < Boundary.top + 1 + Boundary.height(); j++) {
+                returnTilesfromChildren.addAll(getTile(i, j));
+            }
+        }
+        return returnTilesfromChildren;
+    }
+
+    //TODO implement getting / Setting Method for Tiles
+    public ArrayList<Tile> getTile(int x, int y) { // X & Y as Tile Coordinates
+        ArrayList<Chunk> Tiles = new ArrayList<>();
+        if (this.ChunksInCurrentTree.size() < 1) {
+            for (int i = 0; i < this.Children.size(); i++) {
+                if (this.Children.get(i).getBoundarieOld().contains(x + 1, y + 1) || this.Children.get(i).getBoundarieOld().contains(x - 1, y - 1) || this.Children.get(i).getBoundarieOld().contains(x + 1, y - 1) || this.Children.get(i).getBoundarieOld().contains(x - 1, y + 1)) {
+                    Tiles.addAll(this.Children.get(i).getTile(x, y));
+                }
+            }
+        } else {
+            for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                if (this.ChunksInCurrentTree.get(i) != null) {
+                    Rect R = this.ChunksInCurrentTree.get(i).getBoundaries();
+                    if (R.contains(x, y)) {
+                        Tile add = this.ChunksInCurrentTree.get(i);
+                        Tiles.add(add);
+                    }
+                }
+            }
+        }
+        return Tiles;
+    }
+
+    public ArrayList<Tile> getAllTilesBelow() { // Works
+        ArrayList<Tile> AllTilesBelow = new ArrayList<>();
+        if (this.hasChildren) {
+            for (int i = 0; i < this.Children.size(); i++) {
+                AllTilesBelow.addAll(0, this.Children.get(i).getAllTilesBelow());
+            }
+        }
+        return AllTilesBelow;
+    }
+
+
+    public void CheckIntersections() {
+        Collections.reverse(this.ChunksInCurrentTree);
+        for (int i = this.ChunksInCurrentTree.size() - 1; 1 < i; i--) {
+            for (int j = i - 1; -1 < j; j--) {
+                if (i != j) {
+                    if (this.ChunksInCurrentTree.get(i).getBoundaries().contains(this.ChunksInCurrentTree.get(j).getBoundaries())) {
+                        this.ChunksInCurrentTree.remove(j);
+                        i--;
+                    }
+                }
+            }
+        }
+        Collections.reverse(this.ChunksInCurrentTree);
+    }
+
+
+    //public void Autotile() {
+    //    for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) { // Adds the Material id to the List
+    //        int X = (int) (1 +this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(0) - this.BoundaryOld.left);
+    //        int Y = (int) (1 +this.ChunksInCurrentTree.get(i).getPositionRAW().getValue(1) - this.BoundaryOld.top);
+
+    //        if (0 < Y && 0 < X && X < this.BoundaryOld.width()  + 2 && Y < this.BoundaryOld.height() + 2) {
+    //            this.TileMaterialint[X][Y] = this.ChunksInCurrentTree.get(i).getMaterial();
+    //        }
+    //    }
+    //    for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) { // Changes the ID
+    //        if (this.ChunksInCurrentTree.get(i).isAutotile()) {
+    //            this.ChunksInCurrentTree.get(i).setID(getnewID(this.TileMaterialint, this.ChunksInCurrentTree.get(i)));
+    //        }
+    //    }
+    //}
+
+    public Rect getBoundarieOld() {
+        return this.BoundaryOld;
+    }
+
+    public void removeTile(int x, int y) { // X & Y as Chunk Coordinates
+        if (this.ChunksInCurrentTree.size() < 1) {
+            for (int i = 0; i < this.Children.size(); i++) {
+                if (this.Children.get(i).getBoundarieOld().contains(x + 1, y + 1) || this.Children.get(i).getBoundarieOld().contains(x - 1, y - 1) || this.Children.get(i).getBoundarieOld().contains(x + 1, y - 1) || this.Children.get(i).getBoundarieOld().contains(x - 1, y + 1)) {
+                    this.Children.get(i).removeTile(x, y);
+                }
+            }
+        } else {
+
+            for (int i = 0; i < this.ChunksInCurrentTree.size(); i++) {
+                Rect R = this.ChunksInCurrentTree.get(i).getBoundaries();
+                if (R.contains(x, y)) {
+                    this.ChunksInCurrentTree.remove(i);
+                    i--;
+                }
+            }
+        }
+    }/**/
+}
Index: app/src/main/java/com/jacobjacob/ttproject/Object.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Object.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Object.java	(date 1564787735000)
@@ -1,7 +0,0 @@
-package com.jacobjacob.ttproject;
-
-public interface Object{
-    Vector getNormal();
-    Vector getVector(int vector);
-    void setVector(Vector input, int vectorposition);
-}
Index: app/src/main/java/com/jacobjacob/ttproject/Random1.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Random1.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Random1.java	(date 1564787735000)
@@ -1,46 +0,0 @@
-package com.jacobjacob.ttproject;
-
-import static com.jacobjacob.ttproject.Util.SEED;
-
-public class Random1 {
-    private int Hash = 6824;
-    private long Randomnumber;
-
-
-    public Random1(){
-        Randomnumber = SEED + Hash + SEED * Hash;
-        Randomnumber++;
-    }
-
-    public Vector returnVector(Vector Position,int staticAxis){
-        float x = (float) Position.getValue(0);
-        float y = (float) Position.getValue(1);
-        float z = (float) Position.getValue(2);
-
-        //if (staticAxis == 0){
-        //    x = newValue(x);
-//
-        //    y = y;
-        //    z = z;
-        //}
-        //if (staticAxis == 1){
-            x = x;
-            y = newValue(y);
-            z = z;
-        //}
-        //if (staticAxis == 2){
-        //    x = x;
-        //    y = y;
-        //    z = newValue(z);
-        //}
-        return new Vector(x,y,z);
-    }
-
-    private float newValue(float T){
-        float Value = (float) (5*T * Math.sin(T));
-
-
-        return Value;
-    }
-
-}
Index: app/src/main/java/com/jacobjacob/ttproject/Rasterizer.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Rasterizer.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Rasterizer.java	(date 1564787735000)
@@ -1,478 +0,0 @@
-package com.jacobjacob.ttproject;
-
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-
-import static com.jacobjacob.ttproject.Util.BACKGROUNDCOLOR;
-import static com.jacobjacob.ttproject.Util.HEIGHT;
-import static com.jacobjacob.ttproject.Util.WIDTH;
-import static com.jacobjacob.ttproject.Util.camera;
-
-public class Rasterizer {
-    static Bitmap bmp;
-    static Canvas canvas;
-    Paint paint = new Paint(BACKGROUNDCOLOR);
-    static ArrayList<Object> objectsrendering = new ArrayList<>();
-    static ArrayList<Object> objectstorender = new ArrayList<>();
-    static ArrayList<Triangle> clippedTriangles = new ArrayList<>();
-    float pDepthBuffer[][] = new float[WIDTH][HEIGHT];
-    int colorR;
-    int colorG;
-    int colorB;
-
-
-    public void InitializeRasterizer() {
-        pDepthBuffer = new float[WIDTH][HEIGHT];
-        bmp = Bitmap.createBitmap(WIDTH, HEIGHT, Bitmap.Config.ARGB_8888);
-        canvas = new Canvas(bmp);
-        objectstorender.clear();
-        objectsrendering.clear();
-        clippedTriangles.clear();
-        paint.setColor(BACKGROUNDCOLOR);
-        canvas.drawRect(0, 0, WIDTH, HEIGHT, paint);
-        paint.setColor(Color.rgb(200,200,255));
-    }
-
-    public void RenderImage(ArrayList<Object> ObjectsToRasterize) { // Rendering pipeline
-        objectstorender.addAll(ObjectsToRasterize);
-        resetDepthBuffer();
-        for (Object o: objectstorender){
-            if (o instanceof Triangle) {
-                CreateTriangles(o);
-                //ClipTriangles(o);/**Clipping Routine missing!!**/ // Clipping against the screen
-            }
-            //else if (o instanceof Vector){
-            //    CreateLines();
-            //}
-        }
-        ClipTriangles();
-        //objectsrendering.clear();
-        //objectsrendering.addAll(this.clippedTriangles);
-
-        Sortlist();
-
-        DrawTriangle(); // objectsrendering
-    }
-
-    public Bitmap getBmp() { // Returns the rendered Image
-        return bmp;
-    }
-
-
-    private void resetDepthBuffer() {
-        for (int i = 0; i < WIDTH; i++) {// all values of the depth buffer have the value 1
-            for (int j = 0; j < HEIGHT; j++) {
-                pDepthBuffer[i][j] = Float.MAX_VALUE - 1;
-            }
-        }
-    }
-
-    private void CreateTriangles(Object o) {
-
-        Matrix matCamera = new Matrix();
-        matCamera = matCamera.Matrix_PointAt(camera.getEye(), camera.getW(), new Vector(0, 1, 0));
-
-        Matrix matView = matCamera.Matrix_QuickInverse(matCamera);
-
-        //for (Object o : objectstorender) {
-
-            Vector normal = o.getNormal();
-            Vector position = o.getVector(0);
-
-            //Vector visibleposition = position.subtract(camera.getEye());
-            float visible = (float) position.subtract(camera.getEye()).skalarprodukt(normal.negate());
-
-            if (visible >= 0 || true) { // does not work correctly // true = Triangle visible from both sides
-                // Double sided or visible
-
-                // 3d --> 2d                    original Vector, rotated Vector, Matrix()
-
-                Triangle viewed = new Triangle(new Vector(), new Vector(), new Vector());
-
-                viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(0))), 0);
-                viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(1))), 1);
-                viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(2))), 2);
-
-                //Triangle triViewed = viewed; //new Triangle(a, b, c, Color.rgb(red, green, blue));
-
-
-                // Clip Viewed Triangle against near plane, this could form two additional
-                // additional triangles.
-
-
-                int nClippedTriangles;
-                Triangle clipped[] = new Triangle[2];
-                clipped[0] = viewed;
-                clipped[1] = viewed;
-
-                nClippedTriangles = 0;
-                ArrayList<Triangle> clippedTriangles = new Vector().Triangle_ClipAgainstPlane(new Vector(0.0f, 0.0f, 0.1f ), new Vector(0.0f, 0.0f, 1.0f ), viewed);
-                nClippedTriangles = clippedTriangles.size();
-                if (nClippedTriangles >= 1){
-                    clipped[0] = clippedTriangles.get(0);
-                    if (nClippedTriangles >= 2) {
-                        clipped[1] = clippedTriangles.get(1);
-                    }
-                }
-
-                // We may end up with multiple triangles form the clip, so project as
-                // required
-                /**/
-
-                if (clipped[1].getVector(0).getValue(2) > 0 & clipped[1].getVector(1).getValue(2) > 0 & clipped[1].getVector(2).getValue(2) > 0) {
-                    for (int n = 0; n < nClippedTriangles; n++) {
-
-                        // Project triangles from 3D --> 2D
-                        Matrix mat = new Matrix();
-
-                        Triangle triProjected = new Triangle(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(1)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(2)));
-                        triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), 0);
-                        triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(1)), 1);
-                        triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(2)), 2);
-
-                        // Scale into view, we moved the normalising into cartesian space
-                        // out of the matrix.vector function from the previous videos, so
-                        // do this manually
-                        Triangle tridouble = new Triangle(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), triProjected.getVector(1).multiplydouble((float) (1 / triProjected.getVector(1).getW())), triProjected.getVector(2).multiplydouble((float) (1 / triProjected.getVector(2).getW())));
-                        tridouble.setVector(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), 0);
-                        tridouble.setVector(triProjected.getVector(1).multiplydouble((float) (1 / triProjected.getVector(1).getW())), 1);
-                        tridouble.setVector(triProjected.getVector(2).multiplydouble((float) (1 / triProjected.getVector(2).getW())), 2);
-
-                        // X/Y are inverted so put them back
-                        triProjected.setVector(new Vector(-tridouble.getVector(0).getValue(0), -tridouble.getVector(0).getValue(1), tridouble.getVector(0).getValue(2)), 0);
-                        triProjected.setVector(new Vector(-tridouble.getVector(1).getValue(0), -tridouble.getVector(1).getValue(1), tridouble.getVector(1).getValue(2)), 1);
-                        triProjected.setVector(new Vector(-tridouble.getVector(2).getValue(0), -tridouble.getVector(2).getValue(1), tridouble.getVector(2).getValue(2)), 2);
-
-
-                        // Offset verts into visible normalised space
-                        tridouble.setVector(triProjected.getVector(0).addVector(new Vector(1, 1, 0)), 0);
-                        tridouble.setVector(triProjected.getVector(1).addVector(new Vector(1, 1, 0)), 1);
-                        tridouble.setVector(triProjected.getVector(2).addVector(new Vector(1, 1, 0)), 2);
-
-
-                        triProjected.setVector(new Vector(tridouble.getVector(0).getValue(0) * WIDTH / 2, tridouble.getVector(0).getValue(1) * HEIGHT / 2, tridouble.getVector(0).getValue(2)), 0);
-                        triProjected.setVector(new Vector(tridouble.getVector(1).getValue(0) * WIDTH / 2, tridouble.getVector(1).getValue(1) * HEIGHT / 2, tridouble.getVector(1).getValue(2)), 1);
-                        triProjected.setVector(new Vector(tridouble.getVector(2).getValue(0) * WIDTH / 2, tridouble.getVector(2).getValue(1) * HEIGHT / 2, tridouble.getVector(2).getValue(2)), 2);
-
-                        objectsrendering.add(triProjected);
-                    }
-                }
-            }
-        //}
-    }
-    void CreateLines(){
-        Matrix matCamera = new Matrix();
-        matCamera = matCamera.Matrix_PointAt(camera.getEye(), camera.getW(), new Vector(0, 1, 0));
-
-        Matrix matView = matCamera.Matrix_QuickInverse(matCamera);
-
-        for (Object o : objectstorender) {
-
-            Vector position = o.getVector(0);
-
-            Triangle viewed = new Triangle(new Vector(), new Vector(), new Vector());
-
-            viewed.setVector((new Vector().Matrix_MultiplyVector(matView, o.getVector(0))), 0);
-
-            //Triangle triViewed = viewed; //new Triangle(a, b, c, Color.rgb(red, green, blue));
-
-
-            // Clip Viewed Triangle against near plane, this could form two additional
-            // additional triangles.
-
-
-            int nClippedTriangles;
-            Triangle clipped[] = new Triangle[2];
-            clipped[0] = viewed;
-            clipped[1] = viewed;
-
-            nClippedTriangles = 1;
-
-
-            // We may end up with multiple triangles form the clip, so project as
-            // required
-            /**/
-
-            if (clipped[1].getVector(0).getValue(2) > 0 & clipped[1].getVector(1).getValue(2) > 0 & clipped[1].getVector(2).getValue(2) > 0) {
-                for (int n = 0; n < nClippedTriangles; n++) {
-
-                    // Project triangles from 3D --> 2D
-                    Matrix mat = new Matrix();
-
-                    Triangle triProjected = new Triangle(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(1)), new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(2)));
-                    triProjected.setVector(new Vector().Matrix_MultiplyVector(mat.ProjectionMatrix(), clipped[n].getVector(0)), 0);
-
-                    // Scale into view, we moved the normalising into cartesian space
-                    // out of the matrix.vector function from the previous videos, so
-                    // do this manually
-                    Triangle tridouble = new Triangle(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), triProjected.getVector(1).multiplydouble((float) (1 / triProjected.getVector(1).getW())), triProjected.getVector(2).multiplydouble((float) (1 / triProjected.getVector(2).getW())));
-                    tridouble.setVector(triProjected.getVector(0).multiplydouble((float) (1 / triProjected.getVector(0).getW())), 0);
-
-                    // X/Y are inverted so put them back
-                    triProjected.setVector(new Vector(-tridouble.getVector(0).getValue(0), -tridouble.getVector(0).getValue(1), tridouble.getVector(0).getValue(2)), 0);
-                    // Offset verts into visible normalised space
-                    tridouble.setVector(triProjected.getVector(0).addVector(new Vector(1, 1, 0)), 0);
-                    triProjected.setVector(new Vector(tridouble.getVector(0).getValue(0) * WIDTH / 2, tridouble.getVector(0).getValue(1) * HEIGHT / 2, tridouble.getVector(0).getValue(2)), 0);
-
-                    objectsrendering.add(triProjected);
-                }
-            }
-        }
-    }
-
-    private void ClipTriangles() {
-        /*for (Object o : objectstorender){
-            Triangle Old = new Triangle(o.getVector(0),o.getVector(1),o.getVector(2));
-            if (0 < o.getVector(0).getValue(0) && o.getVector(0).getValue(0) < WIDTH &&
-                    0 < o.getVector(1).getValue(0) && o.getVector(0).getValue(0) < WIDTH &&
-                    0 < o.getVector(2).getValue(0) && o.getVector(0).getValue(0) < WIDTH &&
-
-                    0 < o.getVector(0).getValue(0) && o.getVector(0).getValue(0) < HEIGHT &&
-                    0 < o.getVector(1).getValue(0) && o.getVector(0).getValue(0) < HEIGHT &&
-                    0 < o.getVector(2).getValue(0) && o.getVector(0).getValue(0) < HEIGHT){
-
-                clippedTriangles.add(Old);
-            } // Triangle inside Screen
-
-
-
-
-        }
-        objectsrendering.clear();
-        objectsrendering.addAll(clippedTriangles);*/
-    }
-
-    private void clipPolygon() {
-
-
-    }
-    private void Sortlist() {
-        Collections.sort(objectsrendering, new Comparator<Object>() {
-            @Override
-            public int compare(Object t0, Object t1) {
-                float t0Z = (float) (t0.getVector(1).getValue(2));
-                float t1Z = (float) (t1.getVector(1).getValue(2));
-
-                return Float.valueOf(t1Z).compareTo(t0Z);
-
-            }
-        });
-    }
-
-
-    private void DrawTriangle() {
-        for (Object o : objectsrendering) {
-            Vector pv0 = o.getVector(0);
-            Vector pv1 = o.getVector(1);
-            Vector pv2 = o.getVector(2);
-
-
-            if (pv1.getY() < pv0.getY()) {
-                Vector a = pv0;
-                pv0 = pv1;
-                pv1 = a;
-            }
-            if (pv2.getY() < pv1.getY()) {
-                Vector a = pv1;
-                pv1 = pv2;
-                pv2 = a;
-            }
-            if (pv1.getY() < pv0.getY()) {
-                Vector a = pv0;
-                pv0 = pv1;
-                pv1 = a;
-            }
-            if (pv0.getY() == pv1.getY()) { // natural flat top
-                //sorting vertices
-                if (pv1.getX() < pv0.getX()) {
-                    Vector a = pv0;
-                    pv0 = pv1;
-                    pv1 = a;
-                }
-                int yStart = (int) Math.ceil(pv0.getValue(1) - 0.5);
-                int yEnd = (int) Math.ceil(pv2.getValue(1) - 0.5);
-                DrawTriangleTop(pv0, pv1, pv2, yStart, yEnd);
-            } else if (pv1.getY() == pv2.getY()) {
-                //sorting vertices
-                if (pv2.getX() < pv1.getX()) {
-                    Vector a = pv1;
-                    pv1 = pv2;
-                    pv2 = a;
-                }
-                int yStart = (int) pv0.getValue(1);
-                int yEnd = (int) pv1.getValue(1);
-                DrawTriangleBottom(pv0, pv1, pv2, yStart, yEnd);
-            } else { // general triangle
-                //find splitting vertex
-                final float alphaSplit = (float) ((pv1.getY() - pv0.getY()) / (pv2.getY() - pv0.getY()));
-                final Vector vi = pv0.addVector((pv2.subtract(pv0)).multiplydouble(alphaSplit));
-
-                if (pv1.getX() < vi.getX()) { // major right
-
-
-                    int yStart1 = (int) Math.ceil(pv1.getValue(1) - 0.5);
-                    int yEnd1 = (int) Math.ceil(pv2.getValue(1) - 0.5);
-
-                    DrawTriangleBottom(pv0, pv1, vi, yStart1, yEnd1);
-
-
-                    int yStart = (int) pv0.getValue(1);
-                    int yEnd = (int) pv1.getValue(1);
-
-                    DrawTriangleTop(pv1, vi, pv2, yStart, yEnd); // top flat
-                } else { // major left
-
-
-                    int yStart = (int) pv0.getValue(1);
-                    int yEnd = (int) vi.getValue(1);
-
-                    DrawTriangleBottom(pv0, vi, pv1, yStart, yEnd);
-
-                    int yStart1 = (int) Math.ceil(vi.getValue(1) - 0.5);
-                    int yEnd1 = (int) Math.ceil(pv2.getValue(1) - 0.5); // top flat
-
-
-                    DrawTriangleTop(vi, pv1, pv2, yStart1, yEnd1);
-                }
-            }
-        }
-    }
-
-    private void DrawTriangleBottom(Vector a, Vector b, Vector c, int yStart2, int yEnd2) {
-
-        float m0 = (float) ((b.getValue(0) - a.getValue(0)) / (b.getValue(1) - a.getValue(1)));
-        float m1 = (float) ((c.getValue(0) - a.getValue(0)) / (c.getValue(1) - a.getValue(1)));
-
-        float xmin = (float) Math.min(a.getValue(0), Math.min(b.getValue(0), c.getValue(0)));
-        float xmax = (float) Math.max(a.getValue(0), Math.max(b.getValue(0), c.getValue(0)));
-
-        float curx1 = (float) (a.getValue(0));
-        float curx2 = (float) (a.getValue(0));
-
-        int yStart = (int) a.getValue(1);
-        int yEnd = (int) b.getValue(1);
-
-        for (int y = yStart; y <= yEnd; y++) {
-            for (int x = (int) curx1; x < curx2; x++) {
-
-                if (x < xmin) {
-                    x = (int) xmin;
-                }
-                if (x < 0) {
-                    x = 0;
-                }
-                if (xmax < x) {
-                    break;
-                }
-                if (0 < x && x < WIDTH && 0 < y && y < HEIGHT) {
-
-                    float z = getZ(a, b, c, curx1, curx2, x, yStart, yEnd, y, false, yStart2, yEnd2);
-                    TrianglegetColor(x, y, z);
-                }
-            }
-            curx1 += m0;
-            curx2 += m1;
-        }
-    }
-
-    private void DrawTriangleTop(Vector a, Vector b, Vector c, int yStart2, int yEnd2) { // a = ymax c = xmin
-
-        float m0 = (float) ((c.getValue(0) - a.getValue(0)) / (c.getValue(1) - a.getValue(1)));
-        float m1 = (float) ((c.getValue(0) - b.getValue(0)) / (c.getValue(1) - b.getValue(1)));
-
-        int yStart = (int) Math.ceil(a.getValue(1) - 0.5);
-        int yEnd = (int) Math.ceil(c.getValue(1) - 0.5);
-        if (yStart > HEIGHT) {
-            yStart = HEIGHT;
-        }
-        if (yEnd > HEIGHT) {
-            yEnd = HEIGHT;
-        }
-
-        if (yEnd < 0) {
-            yEnd = 0;
-        }
-        for (int y = yStart; y < yEnd; y++) {
-            final float px0 = (float) ((m0 * (y + 0.5 - a.getValue(1))) + a.getValue(0));
-            final float px1 = (float) ((m1 * (y + 0.5 - b.getValue(1))) + b.getValue(0));
-
-
-            int xStart = (int) (Math.ceil(px0 - 0.5));
-            int xEnd = (int) (Math.ceil(px1 - 0.5));
-            if (xStart > WIDTH) {
-                xStart = WIDTH;
-            }
-            if (xEnd > WIDTH) {
-                xEnd = WIDTH;
-            }
-            if (xStart < 0) {
-                xStart = 0;
-            }
-            if (xEnd < 0) {
-                xEnd = 0;
-            }
-            for (int x = xStart; x < xEnd; x++) {
-                if (x < 0) {
-                    x = 0;
-                }
-                if (WIDTH < x) {
-                    break;
-                }
-                if (0 < x && x < WIDTH && 0 < y && y < HEIGHT) {
-
-                    float z = getZ(a, b, c, xStart, xEnd, x, yStart, yEnd, y, true, yStart2, yEnd2);
-
-                    TrianglegetColor(x, y, z);
-                }
-            }
-        }
-    }
-
-    private float getZ(Vector p1, Vector p2, Vector p3, float xStart, float xEnd, float x, float yStart, float yEnd, float y, boolean TopBottom, int yStart2, int yEnd2) {
-
-        float z1 = (float) (p1.getValue(2)); //xmin
-        float z2 = (float) (p2.getValue(2)); //xmax
-        float z3 = (float) (p3.getValue(2)); //ymax
-        /*
-        if (z1 < 0) {
-            z1 = 0;
-        }
-        if (z2 < 0) {
-            z2 = 0;
-        }
-        if (z3 < 0) {
-            z3 = 0;
-        }*/
-
-        float xpercentage = (x - xStart) / (xEnd - xStart);
-
-        float ypercentage;
-        if (TopBottom) {
-            ypercentage = ((y - yStart) + yEnd2 - yStart2) / (yEnd - yStart + yEnd2 - yStart2);
-        } else {
-
-            ypercentage = (y - yStart) / (yEnd - yStart + yEnd2 - yStart2);
-        }
-
-        float a1 = (1 - ypercentage);
-        float b1 = (ypercentage) * (xpercentage);
-        float c1 = (ypercentage) * (1 - xpercentage);
-
-        return z1 * a1 + z2 * b1 + z3 * c1; // z
-    }
-
-    private void TrianglegetColor(int x, int y, float z) {
-
-        if (z < pDepthBuffer[x][y]) {
-            pDepthBuffer[x][y] = z;
-
-            canvas.drawPoint(x, y, paint);
-        }
-    }
-}
Index: app/src/main/java/com/jacobjacob/ttproject/ReadFile.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/ReadFile.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/ReadFile.java	(date 1564787735000)
@@ -1,211 +0,0 @@
-package com.jacobjacob.ttproject;
-
-import android.widget.Toast;
-
-import java.io.BufferedReader;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-
-import static com.jacobjacob.ttproject.Util.CONTEXT;
-import static com.jacobjacob.ttproject.Util.DISPAYTOAST;
-import static com.jacobjacob.ttproject.Util.FILE_NAME;
-import static com.jacobjacob.ttproject.Util.FRAMETIME;
-import static com.jacobjacob.ttproject.Util.FRAMETIMESTART;
-import static com.jacobjacob.ttproject.Util.KDTREE;
-import static com.jacobjacob.ttproject.Util.KDTREECOPY;
-import static com.jacobjacob.ttproject.Util.KDTREECURRENTLYBUILDING;
-import static com.jacobjacob.ttproject.Util.MATERIALARRAY;
-import static com.jacobjacob.ttproject.Util.STARTINGMATERIAL;
-import static com.jacobjacob.ttproject.Util.TEXTUREWIDTH;
-import static com.jacobjacob.ttproject.Util.UPDATEVIEW;
-
-
-public class ReadFile {
-
-    public void ReadFile() { // String Filename
-        FileInputStream fis = null;
-
-        try {
-            fis = CONTEXT.openFileInput(FILE_NAME);
-
-            InputStreamReader isr = new InputStreamReader(fis);
-            BufferedReader br = new BufferedReader(isr);
-            StringBuilder sb = new StringBuilder();
-            String text;
-
-            while ((text = br.readLine()) != null) {
-                sb.append(text).append("\n");
-            }
-            //Toast.makeText(CONTEXT, "Sucess!! : " + CONTEXT.getFilesDir() + "/" + FILE_NAME + " loadet", Toast.LENGTH_LONG).show();
-            if (DISPAYTOAST) {
-                Toast.makeText(CONTEXT, sb.toString(), Toast.LENGTH_LONG).show();
-            }
-            //mEditText.setText(sb.toString());
-
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            if (fis != null) {
-                try {
-                    fis.close();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-    }
-
-    public void ReadFileTiles() { // String Filename
-
-
-        UPDATEVIEW = false;
-
-        ArrayList<Tile> AllTiles = new ArrayList<>();
-
-        KDTREE = new KdTree();//reset();
-        MATERIALARRAY = new Material[TEXTUREWIDTH * TEXTUREWIDTH]; // reset
-        int Materialint = 0;
-
-        boolean readMaterial = false;
-        boolean readMaterialAnimations = false;
-
-        FileInputStream fis = null;
-
-        try {
-            fis = CONTEXT.openFileInput(FILE_NAME);
-
-            InputStreamReader isr = new InputStreamReader(fis);
-            BufferedReader br = new BufferedReader(isr);
-            StringBuilder sb = new StringBuilder();
-            String text;
-
-            while ((text = br.readLine()) != null) {
-                sb.append(text).append("\n");
-
-                String[] parts = text.split(" ");
-
-                if (String.valueOf(parts[0]).equals("m")) {
-                    readMaterial = true;
-                }
-                if (String.valueOf(parts[0]).equals("a")) {
-                    readMaterial = false;
-                    readMaterialAnimations = true;
-                }
-
-                if (!readMaterial && !readMaterialAnimations) {
-
-                    Tile newTile = new Tile(new Vector(Integer.parseInt(parts[0]), Integer.parseInt(parts[1])), Integer.parseInt(parts[2]), Integer.parseInt(parts[3]));
-                    if (parts.length > 4) {
-                        newTile.setMaterial(Integer.parseInt(parts[4]));
-                        if (parts.length > 5) {
-                            newTile.setStarttime(Integer.parseInt(parts[5]));
-                        }
-                    }
-                    AllTiles.add(newTile);
-                }
-                if (readMaterial) {
-
-                    if (!String.valueOf(parts[0]).equals("m")) {
-
-                        MATERIALARRAY[Materialint] = new Material(Integer.parseInt(parts[0]), // number
-                                Integer.parseInt(parts[1]), // layer 1
-                                Integer.parseInt(parts[2]), // layer 2
-                                Integer.parseInt(parts[3]), // layer 3
-
-                                Integer.parseInt(parts[4]), // color int 1
-                                Integer.parseInt(parts[5]), // color int 2
-                                Integer.parseInt(parts[6])); // color int 3
-                        Materialint++;
-                    }
-                }
-
-
-                if (readMaterialAnimations) {
-
-                    if (!String.valueOf(parts[0]).equals("a") && !String.valueOf(parts[0]).equals(" ")) {
-                        int[][] Animation = new int[31][3];
-                        if (MATERIALARRAY[Integer.parseInt(parts[0])] != null) {
-                            for (int i = 0; i < (parts.length - 2) / 4; i++) {
-                                Animation[Integer.parseInt(parts[i * 4 + 2])][0] = Integer.parseInt(parts[i * 4 + 3]);
-                                Animation[Integer.parseInt(parts[i * 4 + 2])][1] = Integer.parseInt(parts[i * 4 + 4]);
-                                Animation[Integer.parseInt(parts[i * 4 + 2])][2] = Integer.parseInt(parts[i * 4 + 5]);
-                            }
-                        } else {
-                            MATERIALARRAY[Integer.parseInt(parts[0])] = STARTINGMATERIAL;
-                            for (int i = 0; i < (parts.length - 1) / 4; i++) {
-                                Animation[i * 4 + 2][0] = Integer.parseInt(parts[i * 4 + 3]);
-                                Animation[i * 4 + 2][1] = Integer.parseInt(parts[i * 4 + 4]);
-                                Animation[i * 4 + 2][2] = Integer.parseInt(parts[i * 4 + 5]);
-                            }
-                        }
-
-                        MATERIALARRAY[Integer.parseInt(parts[0])].LoadAnimation(Animation);
-                        MATERIALARRAY[Integer.parseInt(parts[0])].setAnimationtime(Integer.parseInt(parts[1]));
-                        //set Animationtime
-                    }
-                }
-            }
-            //Toast.makeText(CONTEXT, "Success!! : " + CONTEXT.getFilesDir() + "/" + FILE_NAME + " loaded", Toast.LENGTH_LONG).show();
-            //Toast.makeText(CONTEXT, sb.toString(), Toast.LENGTH_LONG).show();
-            if (DISPAYTOAST) {
-                Toast.makeText(CONTEXT, "SUCCESS: " + FILE_NAME + " loaded", Toast.LENGTH_LONG).show();
-            }
-            //mEditText.setText(sb.toString());
-
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            if (fis != null) {
-                try {
-                    fis.close();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-
-
-        FRAMETIMESTART = System.currentTimeMillis();
-
-        KDTREE = new KdTree();
-        KDTREE.setTilesInCurrentTree(AllTiles); // 16ms
-        KDTREE.CreatenewKDTree();
-
-
-        KDTREECOPY = new KdTree();
-        KDTREECOPY = KDTREE;
-
-
-        FRAMETIME = System.currentTimeMillis() - FRAMETIMESTART; //41ms with 20 iterations // 23 with 5 iterations // 102 with unlimited Iterations and 6467 Tiles // now 770
-        KDTREECURRENTLYBUILDING = false;
-
-        //if (MATERIALARRAY.length < 1) {
-        //    MATERIALARRAY[0] = STARTINGMATERIAL;
-        //}
-        for (int i = 0; i < MATERIALARRAY.length; i++) {
-            if (MATERIALARRAY[i] == null) {
-                Material NewMaterial = STARTINGMATERIAL;
-                int Number = i;
-                NewMaterial.setNumber(Number);
-                MATERIALARRAY[i] = NewMaterial;
-            } else {
-                if (MATERIALARRAY[i].getNumber() != i) {
-                    MATERIALARRAY[i].setNumber(i);
-                }
-            }
-
-
-            MATERIALARRAY[i].UpdateMaterialTileset();
-        }
-        UPDATEVIEW = true;
-
-        //int a = 6;
-    }
-}
Index: app/src/main/java/com/jacobjacob/ttproject/Triangle.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Triangle.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Triangle.java	(date 1564787735000)
@@ -1,45 +0,0 @@
-package com.jacobjacob.ttproject;
-
-public class Triangle implements Object{
-    private Vector A,B,C,Normal;
-
-    public Triangle(Vector A, Vector B, Vector C){
-        this.A=A;
-        this.B = B;
-        this.C = C;
-        Normal = B.subtract(A).cross(C.subtract(A)).normalize();
-    }
-    public Vector getVector(int vector){
-        if (vector == 0){
-            return A;
-        }
-        else if (vector == 1){
-            return B;
-        }
-        else if (vector == 2){
-            return C;
-        }
-        else return A;
-    }
-    public Vector getNormal(){
-        return Normal;
-    }
-    public void setVector(Vector input, int vectorposition){
-        if (vectorposition == 0){
-            A = input;
-        }
-        if (vectorposition == 1){
-            B = input;
-        }
-        if (vectorposition == 2){
-            C = input;
-        }
-    }
-
-    public Triangle addVector(Vector Offsetadd){
-        this.A.add(Offsetadd);
-        this.B.add(Offsetadd);
-        this.C.add(Offsetadd);
-        return new Triangle(A,B,C);
-    }
-}
Index: app/src/main/java/com/jacobjacob/ttproject/WriteFile.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/WriteFile.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/WriteFile.java	(date 1564787735000)
@@ -1,49 +0,0 @@
-package com.jacobjacob.ttproject;
-
-import android.widget.Toast;
-
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-
-import static android.content.Context.MODE_PRIVATE;
-import static com.jacobjacob.ttproject.Util.CONTEXT;
-import static com.jacobjacob.ttproject.Util.DISPAYTOAST;
-import static com.jacobjacob.ttproject.Util.FILE_NAME;
-
-public class WriteFile {
-
-    public void WriteFile(String text/*,String SAVEFILENAME*/) {
-
-        //String text = "new save file complete!!";
-
-
-        FileOutputStream fos = null;
-
-        try {
-
-            fos = CONTEXT.openFileOutput(FILE_NAME, MODE_PRIVATE);
-
-            fos.write(text.getBytes());
-            //Toast.makeText(CONTEXT, "Saved to: " + CONTEXT.getFilesDir() + "/" + FILE_NAME, Toast.LENGTH_LONG).show();
-            if (DISPAYTOAST) {
-                Toast.makeText(CONTEXT, "SUCCESS: " + FILE_NAME + " saved", Toast.LENGTH_LONG).show();
-            }
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        } catch (IOException e) {
-            e.printStackTrace();
-        } finally {
-            if (fos != null) {
-                try {
-                    fos.close();
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-            }
-        }
-        //System.out.print(text); /SAVING WORKS !!!
-    }
-
-
-}
Index: app/src/main/java/com/jacobjacob/ttproject/RenderTiles.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/RenderTiles.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/RenderTiles.java	(date 1567859061990)
@@ -11,6 +11,9 @@
 import android.os.Handler;
 import android.os.Looper;
 
+import com.jacobjacob.ttproject.Tile.KdTree;
+import com.jacobjacob.ttproject.Tile.Tile;
+
 import java.util.ArrayList;
 
 import static com.jacobjacob.ttproject.LevelEditor.SelectedMaterial;
@@ -42,6 +45,7 @@
 import static com.jacobjacob.ttproject.Util.SELECTEDIDINVENTORY;
 import static com.jacobjacob.ttproject.Util.TEXTUREWIDTH;
 import static com.jacobjacob.ttproject.Util.TILELAYER;
+import static com.jacobjacob.ttproject.Util.TILELAYERSTART;
 import static com.jacobjacob.ttproject.Util.TILESIZE;
 import static com.jacobjacob.ttproject.Util.TILESIZETEXTURE;
 import static com.jacobjacob.ttproject.Util.TILETEXTURE;
@@ -52,18 +56,12 @@
 public class RenderTiles {
 
     static Bitmap bmp;
-    static Bitmap bmpScreen;
     static Canvas canvas;
     Paint paint = new Paint(BACKGROUNDCOLOR);
     Rect Screenboundaries;
     float TILESIZEzoom = (float) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
-    //public  static KdTree kdtreeCopy = new KdTree();
-
 
     public void initializeRenderTiles() {
-
-        //this.kdtreeCopy = new KdTree();
-        //this.kdtreeCopy = KDTREECOPY;
         if (!KDTREECURRENTLYBUILDING) {
             KDTREECOPYING = true;
             KDTREECOPY = new KdTree();
@@ -153,7 +151,7 @@
     }
 
     public void DrawSelectedTileLayer() { // Draws the TILES on the left or top, like a quick inventory
-        if (TILELAYER > 0 && TILELAYER < 4) {
+        if (TILELAYER > 0 && TILELAYER < TILELAYERSTART + 4) {
 
             this.paint.setColor(INVENTORYBACKGROUNDCOLOR);
 
@@ -162,48 +160,52 @@
 
             Rect dst;
             Rect src = new Rect(0, 0, TILESIZE, TILESIZE);
-            int idselectedmaterial = MATERIALARRAY[SelectedMaterial].getLayer(TILELAYER);
-            int ColorSelectedmaterial = MATERIALARRAY[SelectedMaterial].getColor(TILELAYER);
+            int idselectedmaterial = MATERIALARRAY[SelectedMaterial].getLayer(TILELAYER/*/+ TILELAYERSTART/**/);
+            int ColorSelectedmaterial = MATERIALARRAY[SelectedMaterial].getColor(TILELAYER/*/+ TILELAYERSTART/**/);
 
 
-            dst = new Rect((2) * HeTeIn + Height7Texturewidth,  HeTeIn + Height7Texturewidth, HeTeIn * ((2) + 1), HeTeIn * (1 + 1));
+            dst = new Rect((2) * HeTeIn + Height7Texturewidth, HeTeIn + Height7Texturewidth, HeTeIn * ((2) + 1), HeTeIn * (1 + 1));
             Paint tempPaint1 = new Paint();
-            tempPaint1.setColor(Color.rgb(255,255,255));
+            tempPaint1.setColor(Color.rgb(255, 255, 255));
             canvas.drawRect(dst, tempPaint1);
 
-
-            for (int i = 0; i < 5; i++) {
+            if (TILELAYERSTART < TILELAYER) {
+                for (int i = 0; i < 5; i++) {
 
-                dst = new Rect((i) * HeTeIn + Height7Texturewidth,  HeTeIn + Height7Texturewidth, HeTeIn * ((i) + 1), HeTeIn * (1 + 1));
+                    dst = new Rect((i) * HeTeIn + Height7Texturewidth, HeTeIn + Height7Texturewidth, HeTeIn * ((i) + 1), HeTeIn * (1 + 1));
 
-                if (SelectedMaterial <= INVENTORY.size()/* && Display*/) {
+                    if (SelectedMaterial <= INVENTORY.size()/* && Display*/) {
 
-                    Paint temppaint = new Paint();
-                    temppaint.setColor(ColorSelectedmaterial);
+                        Paint temppaint = new Paint();
+                        temppaint.setColor(ColorSelectedmaterial);
 
-                    Bitmap Tilebmp = TILETEXTURE.getBitmap(idselectedmaterial + i - 2);
+                        Bitmap Tilebmp = TILETEXTURE.getBitmap(idselectedmaterial + i - 2);
 
 
-
-                    if (Tilebmp != null) {
-                        ColorFilter filter = new LightingColorFilter(ColorSelectedmaterial, 0);
-                        temppaint.setColorFilter(filter);
-                        temppaint.setAlpha(Color.alpha(ColorSelectedmaterial));
-                        Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
-                        Canvas Currentcanvas = new Canvas();
-                        Currentcanvas.setBitmap(Current);
-                        Currentcanvas.drawBitmap(Tilebmp, src, src, temppaint);
+                        if (Tilebmp != null) {
+                            ColorFilter filter = new LightingColorFilter(ColorSelectedmaterial, 0);
+                            temppaint.setColorFilter(filter);
+                            temppaint.setAlpha(Color.alpha(ColorSelectedmaterial));
+                            Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+                            Canvas Currentcanvas = new Canvas();
+                            Currentcanvas.setBitmap(Current);
+                            Currentcanvas.drawBitmap(Tilebmp, src, src, temppaint);
 
-                        this.canvas.drawBitmap(Current, src, dst, null);
+                            this.canvas.drawBitmap(Current, src, dst, null);
+                        }
                     }
                 }
             }
 
-            dst = new Rect((2) * HeTeIn + Height7Texturewidth,  HeTeIn + Height7Texturewidth, HeTeIn * ((2) + 1), HeTeIn * (1 + 1));
+            dst = new Rect((2) * HeTeIn + Height7Texturewidth, HeTeIn + Height7Texturewidth, HeTeIn * ((2) + 1), HeTeIn * (1 + 1));
             Paint tempPaint = new Paint();
+            if (TILELAYER == TILELAYERSTART) {
+                tempPaint.setColor(MATERIALARRAY[SelectedMaterial].getColor(TILELAYERSTART));
+                this.canvas.drawRect(dst, tempPaint);
+            }
             tempPaint.setColor(INVENTORYSELECTTILECOLOR);
             tempPaint.setStyle(Paint.Style.STROKE);
-            tempPaint.setStrokeWidth((int)(Height7Texturewidth/5));
+            tempPaint.setStrokeWidth((int) (Height7Texturewidth / 5));
             canvas.drawRect(dst, tempPaint);
         }
     }
@@ -271,7 +273,12 @@
 
                 if (this.Screenboundaries.contains(TileonScreen)/*|| new Rect(0, 0, WIDTHSCREEN, HEIGHTSCREEN).intersect(draw)*/) {
                     if (VisibleTiles.get(i).getTexture() != null) {
-                        this.canvas.drawBitmap(VisibleTiles.get(i).getTexture(), src, TileonScreen, null);
+                        try {
+
+                            this.canvas.drawBitmap(VisibleTiles.get(i).getTexture(), src, TileonScreen, null);
+                        } catch (Exception e) {
+
+                        }
                     }
                 }
             }
@@ -442,36 +449,15 @@
                     }
                 }
             }
-            //}catch (Exception e){
-            //    System.out.print("Boundaries broke");
-            //    Log.d("Render Tiles","Boundaries broke");
-            //}
         }
     }
 
     public void postImage() {
-        //this.bmp.prepareToDraw();
-        //IMAGE.setImageBitmap(bmp);
-        int i = 0;
         new Handler(Looper.getMainLooper()).post(new Runnable() {
             @Override
             public void run() {
-
-                //IMAGE.setVisibility(View.INVISIBLE);
                 IMAGE.setImageBitmap(bmp);
-                //IMAGE.setVisibility(View.VISIBLE);
-                //MainActivity.UpdateScreen(bmp);
-                //bmp.recycle();
-                //FRAMEDRAWN = true;
             }
         });
     }
-
-    public static Bitmap getBmp() {
-        return bmp;
-    }
-
-    //public Bitmap getRenderedTiles() {
-    //    return bmp;
-    //}
 }
Index: app/src/main/java/com/jacobjacob/ttproject/Tiletexture.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Tiletexture.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Tiletexture.java	(date 1567947596354)
@@ -9,6 +9,9 @@
 import android.graphics.Matrix;
 import android.graphics.Paint;
 import android.graphics.Rect;
+import android.opengl.GLES20;
+import android.opengl.GLUtils;
+import android.util.Log;
 
 import java.util.ArrayList;
 
@@ -16,8 +19,12 @@
 import static com.jacobjacob.ttproject.Util.MATERIALARRAY;
 import static com.jacobjacob.ttproject.Util.MATERIALLIST;
 import static com.jacobjacob.ttproject.Util.MATERIALLISTUPDATING;
+import static com.jacobjacob.ttproject.Util.MATERIALNORMALS;
+import static com.jacobjacob.ttproject.Util.NORMALSTRENGTH;
+import static com.jacobjacob.ttproject.Util.PLACETILE;
 import static com.jacobjacob.ttproject.Util.TEXTUREWIDTH;
 import static com.jacobjacob.ttproject.Util.TILELAYER;
+import static com.jacobjacob.ttproject.Util.TILELAYERSTART;
 import static com.jacobjacob.ttproject.Util.TILESIZE;
 import static com.jacobjacob.ttproject.Util.TILESIZEORIGINAL;
 import static com.jacobjacob.ttproject.Util.TILESIZETEXTURE;
@@ -39,11 +46,14 @@
     private Rect SrcDst = new Rect(0, 0, TILESIZE, TILESIZE);
     private long Starttime;
 
+    /**
+     * Initializes the bmp Arrays. Takes the rgb values and creates new Arrays with grey images that get Colored later
+     */
     public Tiletexture() { //rgb
         Bitmaplist = new ArrayList<>();
 
         MATERIALLIST = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
-
+        MATERIALNORMALS = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
 
         Bitmap LayerR, LayerG, LayerB;
         //BitmaplistLLOD = new ArrayList<>();
@@ -134,7 +144,7 @@
 
 
     /**
-     * This method rotates
+     * This method rotates a Bitmap
      *
      * @param Input   the bitmap that should be rotated
      * @param Degrees the amount of rotation
@@ -147,6 +157,13 @@
         return /* Bitmap rotatedBitmap = */Bitmap.createBitmap(scaledBitmap, 0, 0, scaledBitmap.getWidth(), scaledBitmap.getHeight(), matrix, true);
     }
 
+    /**
+     * This method Overlays two Bitmaps
+     *
+     * @param Bottom The first bitmap on the bottom
+     * @param Top    The second Bitmap that gets drawn on top of the first one
+     * @return
+     */
     private Bitmap OverlayTilemap(Bitmap Bottom, Bitmap Top) {
 
         Bitmap Out = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
@@ -158,33 +175,286 @@
         return Out;
     }
 
+    /**
+     * Returns a bmp of a Bitmap with fitting ID and Material
+     *
+     * @param ID          The Id of the Bitmap / can range from 0 to 15
+     * @param MATERIALint The Material the Texture has
+     * @return
+     */
     public Bitmap getBitmap(int ID, int MATERIALint) { // no animations possible yet
-        //MATERIALint = 0;
-        //if (MATERIALLIST == null){
-        //    MATERIALLIST = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
-        //}
+
+        if (!PLACETILE/*MATERIALNORMALS[MATERIALint] != null && MATERIALint * 5 < Bitmaplist.size() && MATERIALARRAY[MATERIALint].showNormal()*/) {
+            try {
+                return MATERIALNORMALS[MATERIALint][ID];
+            } catch (Exception e) {
+                Log.d("TILETEXTURE","Tile not in Normal Array!");
+            }
+        }
+
+
         if (MATERIALLIST != null && MATERIALLIST[MATERIALint] != null && ID < MATERIALLIST[MATERIALint].length) {
-
-            /**/
-            Bitmap imagetexture;
-            imagetexture = MATERIALLIST[MATERIALint][ID];
-
-            return imagetexture;/*/return Materiallist.get(ID)[MATERIALint];/**/
+            return MATERIALLIST[MATERIALint][ID];/*/return Materiallist.get(ID)[MATERIALint];/**/
 
         } else {
             return null;
         }
     }
 
+
+    public void deleteTextures() {
+        for (int i = 0; i < TEXTUREWIDTH; i++) {
+            try {
+                GLES20.glDeleteTextures(15, Textures[i], 0);
+
+            } catch (Exception e) {
+                Log.d("Textures: ", "Failed Deleting Textures" + e);
+            }
+        }
+    }
+
+    public void deleteNormals() {
+        for (int i = 0; i < TEXTUREWIDTH; i++) {
+            try {
+                GLES20.glDeleteTextures(15, TextureNormals[i], 0);
+            } catch (Exception e) {
+                Log.d("Textures: ", "Failed Deleting Textures" + e);
+            }
+        }
+    }
+
+
+    /**
+     * Updates the Material loads the Bitmap as a Texture
+     *
+     * @param MaterialToUpdate The Material that gets a new Texture
+     */
+    public void UpdateMaterialTexture(int MaterialToUpdate) {
+        MATERIALARRAY[MaterialToUpdate].CreateMaterialTileset();
+
+        updateTextures(MaterialToUpdate);
+    }
+
+
+    /**
+     * Updates the Material loads the Bitmap as a Texture. This is the normal map- Texture
+     *
+     * @param MaterialToUpdate The Material that gets a new Texture
+     */
+    public void UpdateMaterialNormalTexture(int MaterialToUpdate) {
+        MATERIALARRAY[MaterialToUpdate].CreateMaterialTilesetNormal();
+
+        updateTexturesNormals(MaterialToUpdate);
+    }
+
+
+    public void updateTextures(int TextureToUpdate) {
+
+        int[] textureHandle = new int[16];
+        for (int j = 0; j < 16; j++) {
+
+
+            GLES20.glGenTextures(1, textureHandle, j);
+
+            try {
+
+                if (textureHandle[j] != 0) {
+                    // Bind to the texture in OpenGL
+                    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[j]);
+
+                    // Set filtering
+                    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
+                    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);
+
+                    // Load the bitmap into the bound texture.
+                    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, MATERIALLIST[TextureToUpdate][j], 0);
+                }
+            } catch (Exception e) {
+                Log.d("Load Texture:", "" + e);
+            }
+            if (textureHandle[0] == 0) {
+                throw new RuntimeException("Error loading texture.");
+            }
+            if (j == 15) {
+                Textures[TextureToUpdate] = textureHandle;
+            }
+        }
+    }
+
+    public void updateTexturesNormals(int TextureToUpdate) {
+
+
+        int[] textureHandle = new int[16];
+        for (int j = 0; j < 16; j++) {
+
+            GLES20.glGenTextures(1, textureHandle, j);
+
+            try {
+
+                if (textureHandle[j] != 0) {
+                    // Bind to the texture in OpenGL
+                    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[j]);
+
+                    // Set filtering
+                    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
+                    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);
+
+                    // Load the bitmap into the bound texture.
+                    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, MATERIALNORMALS[TextureToUpdate][j], 0);
+                }
+            } catch (Exception e) {
+                Log.d("Load Texture:", "" + e);
+            }
+            if (textureHandle[0] == 0) {
+                throw new RuntimeException("Error loading texture.");
+            }
+            if (j == 15) {
+                TextureNormals[TextureToUpdate] = textureHandle;
+            }
+        }
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*/
+    public void updateTextures() { // new void
+
+        TODO5 remove 4
+
+        for (int i = 0; i < TEXTUREWIDTH; i++) {
+
+            int[] textureHandle = new int[16];
+            for (int j = 0; j < 16; j++) {
+
+
+                GLES20.glGenTextures(1, textureHandle, j);
+
+                try {
+
+                    if (textureHandle[j] != 0) {
+                        // Bind to the texture in OpenGL
+                        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[j]);
+
+                        // Set filtering
+                        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
+                        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);
+
+                        // Load the bitmap into the bound texture.
+                        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, MATERIALLIST[i][j], 0);
+                    }
+                } catch (Exception e) {
+                    Log.d("Load Texture:", "" + e);
+                }
+                if (textureHandle[0] == 0) {
+                    throw new RuntimeException("Error loading texture.");
+                }
+                if (j == 15) {
+                    Textures[i] = textureHandle;
+                }
+            }
+
+        }
+    }/**/
+
+/*/
+    public void updateTexturesNormals() {
+        //TODO0 remove 4
+
+        for (int i = 0; i < TEXTUREWIDTH; i++) {
+
+            int[] textureHandle = new int[16];
+            for (int j = 0; j < 16; j++) {
+
+                GLES20.glGenTextures(1, textureHandle, j);
+
+                try {
+
+                    if (textureHandle[j] != 0) {
+                        // Bind to the texture in OpenGL
+                        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[j]);
+
+                        // Set filtering
+                        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
+                        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);
+
+                        // Load the bitmap into the bound texture.
+                        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, MATERIALNORMALS[i][j], 0);
+                    }
+                } catch (Exception e) {
+                    Log.d("Load Texture:", "" + e);
+                }
+                if (textureHandle[0] == 0) {
+                    throw new RuntimeException("Error loading texture.");
+                }
+                if (j == 15) {
+                    TextureNormals[i] = textureHandle;
+                }
+            }
+
+        }
+    }/**/
+
+    int Textures[][] = new int[TEXTUREWIDTH * TEXTUREWIDTH][15];
+
+    int TextureNormals[][] = new int[TEXTUREWIDTH * TEXTUREWIDTH][15];
+
+    public int getTexture(int ID, int Materialint) {
+
+        try {
+            return Textures[Materialint][ID];
+        } catch (Exception e) {
+
+        }
+        return 0;
+        /**/
+    }
+
+    public int getTextureNormals(int ID, int Materialint) {
+
+        try {
+            return TextureNormals[Materialint][ID];
+        } catch (Exception e) {
+
+        }
+        return 0;
+        /**/
+    }
+
+    /**
+     * Returns the Bitmap of a specific Layer to make the quick selection screen possible.
+     * It does not take in an ID, the ID equals 15 / the bottom Tile
+     *
+     * @param MATERIALint The Material we want the Bitmap of a specific Layer from
+     * @return a grey Bitmap
+     */
     public Bitmap getBitmap(int MATERIALint) { // no animations possible yet
         // Material
         if (MATERIALint >= 0) {
             if (MATERIALARRAY[MATERIALint] != null && MATERIALint * 5 < Bitmaplist.size()) {
-                if (TILELAYER == 1) {
+                if (TILELAYER == TILELAYERSTART + 1) {
                     return RGBTilesLAYER1.get(MATERIALint * 5);
-                } else if (TILELAYER == 2) {
+                } else if (TILELAYER == TILELAYERSTART + 2) {
                     return RGBTilesLAYER2.get(MATERIALint * 5);
-                } else if (TILELAYER == 3) {
+                } else if (TILELAYER == TILELAYERSTART + 3) {
                     return RGBTilesLAYER3.get(MATERIALint * 5);
                 } else {
                     return null;
@@ -193,13 +463,13 @@
             } else {
                 return null;
             }
-        }else {
+        } else {
             return null;
         }
     }
 
 
-    public void CreateTilemap(int Material, int Layer1, int Layer2, int Layer3, int ColorLayer1, int ColorLayer2, int ColorLayer3) { // needs more Options as input
+    public void CreateTilemap(int Material, int Layer1, int Layer2, int Layer3, int ColorLayer0, int ColorLayer1, int ColorLayer2, int ColorLayer3) { // needs more Options as input
 
         Bitmap[] SingleTilemap = new Bitmap[15]; // Tiles from 0 to 15 as Bitmap
 
@@ -210,13 +480,13 @@
         //Layer1 = 0;
         //Layer2 = 0;
         //Layer3 = 0;
-        if (Layer1 < 0){
+        if (Layer1 < 0) {
             Layer1 = 0;
         }
-        if (Layer2 < 0){
+        if (Layer2 < 0) {
             Layer2 = 0;
         }
-        if (Layer3 < 0){
+        if (Layer3 < 0) {
             Layer3 = 0;
         }
         Layer1 *= TILESOFSINGLEKIND;
@@ -228,7 +498,10 @@
             Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
             Canvas Currentcanvas = new Canvas();
             Currentcanvas.setBitmap(Current);
-
+            if (i == 0) {
+                paint.setColor(ColorLayer0);
+                Currentcanvas.drawRect(SrcDst, paint);
+            }
 
             filter = new LightingColorFilter(ColorLayer1, 0);
             paint.setColorFilter(filter);
@@ -255,7 +528,7 @@
         MATERIALLIST[Material] = FinishedTilemap; // updates all Tiles from a specific Material
     }
 
-    public void UpdateTilemap(int Material, int Layer1, int Layer2, int Layer3, int ColorLayer1, int ColorLayer2, int ColorLayer3) { // needs more Options as input
+    public void UpdateTilemap(int Material, int Layer1, int Layer2, int Layer3, int ColorLayer0, int ColorLayer1, int ColorLayer2, int ColorLayer3) { // needs more Options as input
 
         if (MATERIALLISTUPDATING == null) {
             MATERIALLISTUPDATING = new Bitmap[TEXTUREWIDTH * TEXTUREWIDTH][15];
@@ -267,6 +540,18 @@
         Paint paint = new Paint();
         ColorFilter filter;
 
+
+        if (Layer1 < 0) {
+            Layer1 = 0;
+        }
+        if (Layer2 < 0) {
+            Layer2 = 0;
+        }
+        if (Layer3 < 0) {
+            Layer3 = 0;
+        }
+
+
         Layer1 *= TILESOFSINGLEKIND;
         Layer2 *= TILESOFSINGLEKIND;
         Layer3 *= TILESOFSINGLEKIND;
@@ -297,13 +582,18 @@
 
         Bitmap[] FinishedTilemap = getFinnishedBitmaplist(SingleTilemap);
 
-        for (int i = 0; i < FinishedTilemap.length; i++) {
+        for (int i = 0; i < FinishedTilemap.length-1; i++) {
             FinishedTilemap[i] = OverlayTilemap(FinishedTilemap[15], FinishedTilemap[i]);
         }
 
         MATERIALLISTUPDATING[Material] = FinishedTilemap; // updates all Tiles from a specific Material
     }
 
+    /**
+     * Transforms a bmp[] with 5 Tiles into one with 15 Tiles
+     * @param SingleTilemap The 5 Tiles as Input
+     * @return The 15 Finished Tiles
+     */
     private Bitmap[] getFinnishedBitmaplist(Bitmap[] SingleTilemap) {
         Bitmap[] FinishedTilemap = new Bitmap[16];
 
@@ -343,5 +633,286 @@
         bm.recycle();
         return resizedBitmap;
     }
+
+
+    //TODO Create accurate normals
+    public void CreateNormals(int intMaterial, int Layer1, int Layer2, int Layer3, int alpha1, int alpha2, int alpha3) {
+
+        Bitmap[] SingleTilemap = new Bitmap[15]; // Tiles from 0 to 15 as Bitmap
+
+        SrcDst = new Rect(0, 0, TILESIZE, TILESIZE);
+        Paint paint = new Paint();
+
+        if (Layer1 < 0) {
+            Layer1 = 0;
+        }
+        if (Layer2 < 0) {
+            Layer2 = 0;
+        }
+        if (Layer3 < 0) {
+            Layer3 = 0;
+        }
+
+        Layer1 *= TILESOFSINGLEKIND;
+        Layer2 *= TILESOFSINGLEKIND;
+        Layer3 *= TILESOFSINGLEKIND;
+
+        for (int i = 0; i < TILESOFSINGLEKIND; i++) { // i < 5 // all five starting tiles in grey
+
+            Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+            Canvas Currentcanvas = new Canvas();
+            Currentcanvas.setBitmap(Current);
+
+            if (i == 0) {
+                paint.setColor(Color.rgb(127, 127, 255)); // equals 0 0 1
+                //paint.setColor(Color.rgb(0,0,0)); // equals 0 0 1
+                Currentcanvas.drawRect(new Rect(0, 0, TILESIZEORIGINAL, TILESIZEORIGINAL), paint);
+            }
+
+            for (int j = TILESIZEORIGINAL; j < 2 * TILESIZEORIGINAL; j++) {
+                for (int k = TILESIZEORIGINAL; k < 2 * TILESIZEORIGINAL; k++) {
+
+
+                    int ColorLayerUP = 0;
+                    int ColorLayerDOWN = 0;
+                    int ColorLayerLEFT = 0;
+                    int ColorLayerRIGHT = 0;
+
+                    Bitmap Layer;
+                    float Alpha;
+
+                    for (int l = 0; l < 3; l++) {
+
+                        if (l == 0) {
+                            Layer = RGBTilesLAYER1.get(Layer1 + i);
+                            Alpha = alpha1;
+                        } else if (l == 1) {
+                            Layer = RGBTilesLAYER2.get(Layer2 + i);
+                            Alpha = alpha2;
+                        } else {
+                            Layer = RGBTilesLAYER2.get(Layer3 + i);
+                            Alpha = alpha3;
+                        }
+
+                        int jrelative = j % TILESIZEORIGINAL;
+                        int krelative = k % TILESIZEORIGINAL;
+
+                        ColorLayerUP += (int) (1/*((Alpha / 255.0f))*/ * Color.red(Layer.getPixel(jrelative, (k - 1) % TILESIZEORIGINAL)));// takes the colorvalue of the three bitmaps at the same point
+
+                        ColorLayerDOWN += (int) (1/*((Alpha / 255.0f))*/ * Color.red(Layer.getPixel(jrelative, (k + 1) % TILESIZEORIGINAL)));// takes the colorvalue of the three bitmaps at the same point
+
+                        ColorLayerLEFT += (int) (1/*((Alpha / 255.0f))*/ * Color.red(Layer.getPixel((j - 1) % TILESIZEORIGINAL, krelative)));// takes the colorvalue of the three bitmaps at the same point
+
+                        ColorLayerRIGHT += (int) (1/*((Alpha / 255.0f))*/ * Color.red(Layer.getPixel((j + 1) % TILESIZEORIGINAL, krelative)));// takes the colorvalue of the three bitmaps at the same point
+                    }
+
+
+                    Vector NormalVec;
+
+                    //NormalVec = (NormalVec.normalize()).multiplydouble(255);
+
+                    float Scale = alpha1 + alpha2 + alpha3;
+
+                    float Hor = (float) (ColorLayerLEFT - ColorLayerRIGHT) / Scale; // value from 0 to 1
+                    float Ver = (float) (ColorLayerUP - ColorLayerDOWN) / Scale; // value from 0 to 1
+
+
+
+                    Vector vb = /*/new Vector(Hor, 0, Sca).normalize();/*/new Vector(NORMALSTRENGTH, 0, Hor).normalize();/**/
+                    Vector va = /*/new Vector(0, Ver, Sca).normalize();/*/new Vector(0, NORMALSTRENGTH, Ver).normalize();/**/
+
+                    //va = new Vector(Hor, 0,Sca).normalize();
+                    //vb = new Vector(0, Ver,Sca).normalize();
+                    NormalVec = ((va.cross(vb)).normalize()).negate();
+
+                    NormalVec = new Vector(NormalVec.getX(), NormalVec.getY(), Math.abs(NormalVec.getZ())).normalize();
+
+                    int red = (int) (/**/255 - /**/((NormalVec.getX() + 1) * 127));
+                    int green = (int) (/**/255 - /**/(NormalVec.getY() + 1) * 127);
+                    int blue = (int) ((NormalVec.getZ() + 1) * 127);
+
+                    //blue = 127;
+
+                    paint.setColor(Color.rgb(red, green, blue));
+
+
+                    //Currentcanvas.drawRect(j%TILESIZEORIGINAL, k%TILESIZEORIGINAL,j%TILESIZEORIGINAL+1,k%TILESIZEORIGINAL+1, paint);
+                    if ((red < 123 || red > 130) && (green < 123 || green > 130)/* && (blue < 123 || blue > 130)*/) {
+                        Currentcanvas.drawPoint(j % TILESIZEORIGINAL, k % TILESIZEORIGINAL, paint);
+                    }
+                }
+            }
+
+            SingleTilemap[i] = Current;
+        }
+
+
+        Bitmap[] FinishedTilemap = getFinnishedBitmaplist(SingleTilemap);
+
+        for (int i = 0; i < FinishedTilemap.length; i++) {
+            FinishedTilemap[i] = OverlayTilemap(FinishedTilemap[FinishedTilemap.length-1], FinishedTilemap[i]);
+        }
+
+        MATERIALNORMALS[intMaterial] = FinishedTilemap;
+    }
+
+
+    /**
+     * Creates a Bitmaplist with 5 bmps for one Layer ony
+     *
+     * @param Layer    The chosen LayerBitmap like  5 = brick wall or 3 = sand,...
+     * @param alpha    The chosen Opacity
+     * @param Position The original Layer = 1, 2 or 3
+     * @return
+     */
+    public Bitmap[] createBitmapOfSingleKind(int Position, int Layer, int alpha) {
+        Bitmap[] BitmapArry = new Bitmap[TILESOFSINGLEKIND];
+
+        Paint paint = new Paint();
+        paint.setAlpha(alpha);
+
+
+        for (int i = 0; i < TILESOFSINGLEKIND; i++) {
+            //Create Bitmap
+            Bitmap newLayer = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+            Canvas Currentcanvas = new Canvas();
+            Currentcanvas.setBitmap(newLayer);
+
+
+            if (Position == 0) {
+                Currentcanvas.drawBitmap(RGBTilesLAYER1.get(Layer * TILESOFSINGLEKIND + i), 0, 0, paint);
+            } else if (Position == 1) {
+                Currentcanvas.drawBitmap(RGBTilesLAYER2.get(Layer * TILESOFSINGLEKIND + i), 0, 0, paint);
+            } else {
+                Currentcanvas.drawBitmap(RGBTilesLAYER3.get(Layer * TILESOFSINGLEKIND + i), 0, 0, paint);
+            }
+            BitmapArry[i] = newLayer;
+        }
+
+        return BitmapArry;
+    }
+
+    public Bitmap returnNormalBmp(int ID, Bitmap Layer1, Bitmap Layer2, Bitmap Layer3, int alpha1, int alpha2, int alpha3) {
+
+        Paint paint = new Paint();
+
+        Bitmap Current = Bitmap.createBitmap(TILESIZE, TILESIZE, Bitmap.Config.ARGB_8888);
+        Canvas Currentcanvas = new Canvas();
+        Currentcanvas.setBitmap(Current);
+
+        if (ID == 15) {
+            paint.setColor(Color.rgb(127, 127, 255)); // equals 0 0 1
+            //paint.setColor(Color.rgb(0,0,0)); // equals 0 0 1
+            Currentcanvas.drawRect(new Rect(0, 0, TILESIZEORIGINAL, TILESIZEORIGINAL), paint);
+        }
+
+        for (int j = TILESIZEORIGINAL; j < 2 * TILESIZEORIGINAL; j++) {
+            for (int k = TILESIZEORIGINAL; k < 2 * TILESIZEORIGINAL; k++) {
+
+
+                int ColorLayerUP = 0;
+                int ColorLayerDOWN = 0;
+                int ColorLayerLEFT = 0;
+                int ColorLayerRIGHT = 0;
+
+                Bitmap Layer;
+
+                for (int l = 0; l < 3; l++) {
+
+                    if (l == 0) {
+                        Layer = Layer1;
+                    } else if (l == 1) {
+                        Layer = Layer2;
+                    } else {
+                        Layer = Layer3;
+                    }
+
+                    int jrelative = j % TILESIZEORIGINAL;
+                    int krelative = k % TILESIZEORIGINAL;
+
+                    ColorLayerUP += Color.red(Layer.getPixel(jrelative, (k - 1) % TILESIZEORIGINAL));// takes the colorvalue of the three bitmaps at the same point
+
+                    ColorLayerDOWN += Color.red(Layer.getPixel(jrelative, (k + 1) % TILESIZEORIGINAL));// takes the colorvalue of the three bitmaps at the same point
+
+                    ColorLayerLEFT += Color.red(Layer.getPixel((j - 1) % TILESIZEORIGINAL, krelative));// takes the colorvalue of the three bitmaps at the same point
+
+                    ColorLayerRIGHT += Color.red(Layer.getPixel((j + 1) % TILESIZEORIGINAL, krelative));// takes the colorvalue of the three bitmaps at the same point
+                }
+
+
+                Vector NormalVec;
+
+                float Scale = alpha1 + alpha2 + alpha3;
+
+                float Hor = (float) (ColorLayerLEFT - ColorLayerRIGHT) / Scale; // value from 0 to 1
+                float Ver = (float) (ColorLayerUP - ColorLayerDOWN) / Scale; // value from 0 to 1
+
+
+
+                Vector vb = new Vector(NORMALSTRENGTH, 0, Hor).normalize();/**/
+                Vector va = new Vector(0, NORMALSTRENGTH, Ver).normalize();/**/
+
+                NormalVec = ((va.cross(vb)).normalize()).negate();
+
+                NormalVec = new Vector(NormalVec.getX(), NormalVec.getY(), Math.abs(NormalVec.getZ())).normalize();
+
+                int red = (int) (255 - ((NormalVec.getX() + 1) * 127));
+                int green = (int) (255 - (NormalVec.getY() + 1) * 127);
+                int blue = (int) ((NormalVec.getZ() + 1) * 127);
+
+                //blue = 127;
+
+                paint.setColor(Color.rgb(red, green, blue));
+
+
+                //Currentcanvas.drawRect(j%TILESIZEORIGINAL, k%TILESIZEORIGINAL,j%TILESIZEORIGINAL+1,k%TILESIZEORIGINAL+1, paint);
+                if ((red < 123 || red > 130) && (green < 123 || green > 130)/* && (blue < 123 || blue > 130)*/) {
+                    Currentcanvas.drawPoint(j % TILESIZEORIGINAL, k % TILESIZEORIGINAL, paint);
+                }
+            }
+        }
+        return Current;
+    }
+
+    //TODO Create accurate normals
+    public void CreateAccurateNormals(int intMaterial, int Layer1, int Layer2, int Layer3, int alpha1, int alpha2, int alpha3) {
+
+        Bitmap[] SingleTilemap = new Bitmap[16]; // Tiles from 0 to 15 as Bitmap
+
+        Bitmap[][] GreyTilemaps = new Bitmap[3][16];
+
+        for (int i = 0; i < 3; i++) {
+
+            Bitmap[] FinishedTilemap;
+
+            if (i == 0) {
+                FinishedTilemap = createBitmapOfSingleKind(i, Layer1, alpha1); // length of 5, only the basic Tiles
+                int a = 0;
+            } else if (i == 1) {
+                FinishedTilemap = createBitmapOfSingleKind(i, Layer2, alpha2); // length of 5, only the basic Tiles
+            } else {
+                FinishedTilemap = createBitmapOfSingleKind(i, Layer3, alpha3); // length of 5, only the basic Tiles
+            }
+
+            FinishedTilemap = getFinnishedBitmaplist(FinishedTilemap);
+            int b = 0;
+
+            for (int j = 0; j < FinishedTilemap.length; j++) {
+                FinishedTilemap[j] = OverlayTilemap(FinishedTilemap[FinishedTilemap.length-1], FinishedTilemap[j]);
+            }
+            GreyTilemaps[i] = FinishedTilemap;
+        }
+
+        for (int i = 0; i < 16; i++) {
+            SingleTilemap[i] = returnNormalBmp(i, GreyTilemaps[0][i], GreyTilemaps[1][i], GreyTilemaps[2][i], alpha1, alpha2, alpha3);
+        }
+        int a = 0;
+        for (int j = 0; j < SingleTilemap.length-1; j++) {
+            SingleTilemap[j] = OverlayTilemap(SingleTilemap[15]/*SingleTilemap[SingleTilemap.length-1]*/, SingleTilemap[j]);
+        }
+
+
+        MATERIALNORMALS[intMaterial] = SingleTilemap;
+    }
 }
 
Index: app/src/main/java/com/jacobjacob/ttproject/KdTree.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/KdTree.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Tile/KdTree.java	(date 1567961077519)
@@ -1,6 +1,9 @@
-package com.jacobjacob.ttproject;
+package com.jacobjacob.ttproject.Tile;
 
 import android.graphics.Rect;
+import android.util.Log;
+
+import com.jacobjacob.ttproject.Vector;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -64,77 +67,86 @@
     }
 
     public void addTilesInCurrentTree(ArrayList<Tile> tilesInCurrentTree) {
-        this.TilesInCurrentTree.addAll(tilesInCurrentTree);
+        try {
+            this.TilesInCurrentTree.addAll(tilesInCurrentTree);
+        }catch (Exception e){
+
+        }
     }
 
     public void CreatenewKDTree() {
-        //KDTREECURRENTLYBUILDING = true;
+        try {
+
+            //KDTREECURRENTLYBUILDING = true;
 
-        //TilesInCurrentTree = getTilesInCurrentTree();
+            //TilesInCurrentTree = getTilesInCurrentTree();
 
-        int minX = 999, minY = 999, maxX = -999, maxY = -999;
+            int minX = 999, minY = 999, maxX = -999, maxY = -999;
 
-        if (this.Iteration == 0) {
+            if (this.Iteration == 0) {
 
-            ArrayList<Tile> allTiles = getTilesInCurrentTree();
-            this.TilesInCurrentTree.clear();
-            this.TilesInCurrentTree.addAll(allTiles);
-            this.Children.clear();
-            this.hasChildren = false;
+                ArrayList<Tile> allTiles = getTilesInCurrentTree();
+                this.TilesInCurrentTree.clear();
+                this.TilesInCurrentTree.addAll(allTiles);
+                this.Children.clear();
+                this.hasChildren = false;
 
-            for (int i = 0; i < this.TilesInCurrentTree.size(); i++) {
-                if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0) < minX) {
-                    minX = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0);
-                }
-                if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1) < minY) {
-                    minY = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1);
-                }
-                if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0) > maxX) {
-                    maxX = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0);
-                }
-                if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1) > maxY) {
-                    maxY = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1);
-                }
-            }
-            minX -= 1;
-            minY -= 1;
-            maxX += 1;
-            maxY += 1;
-            this.BoundaryOld = new Rect(minX, minY, maxX, maxY);
+                for (int i = 0; i < this.TilesInCurrentTree.size(); i++) {
+                    if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0) < minX) {
+                        minX = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0);
+                    }
+                    if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1) < minY) {
+                        minY = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1);
+                    }
+                    if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0) > maxX) {
+                        maxX = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(0);
+                    }
+                    if (this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1) > maxY) {
+                        maxY = (int) this.TilesInCurrentTree.get(i).getPositionRAW().getValue(1);
+                    }
+                }
+                minX -= 1;
+                minY -= 1;
+                maxX += 1;
+                maxY += 1;
+                this.BoundaryOld = new Rect(minX, minY, maxX, maxY);
 
-            int X = this.BoundaryOld.width() + 2;
-            int Y = this.BoundaryOld.height() + 2;
-            if (X < 0) {
-                X = 0;
-            }
-            if (Y < 0) {
-                Y = 0;
-            }
-            this.TileMaterialint = new int[X][Y]; // must be bigger to give the Tiles on the edges the right Orientation
-            for (int i = 0; i < X; i++) {
-                for (int j = 0; j < Y; j++) {
-                    this.TileMaterialint[i][j] = -1;
+                int X = this.BoundaryOld.width() + 2;
+                int Y = this.BoundaryOld.height() + 2;
+                if (X < 0) {
+                    X = 0;
+                }
+                if (Y < 0) {
+                    Y = 0;
+                }
+                this.TileMaterialint = new int[X][Y]; // must be bigger to give the Tiles on the edges the right Orientation
+                for (int i = 0; i < X; i++) {
+                    for (int j = 0; j < Y; j++) {
+                        this.TileMaterialint[i][j] = -1;
 
-                }
-            }
+                    }
+                }
 
-            //Vector a = new Vector(this.BoundaryOld.left, this.BoundaryOld.top).multiplydouble(TILESIZE);
-            //Vector b = new Vector(this.BoundaryOld.right, this.BoundaryOld.bottom).multiplydouble(TILESIZE);
+                //Vector a = new Vector(this.BoundaryOld.left, this.BoundaryOld.top).multiplydouble(TILESIZE);
+                //Vector b = new Vector(this.BoundaryOld.right, this.BoundaryOld.bottom).multiplydouble(TILESIZE);
 
-            //a = a.getScreencoordinatesFromTileCoordinates(a);
-            //b = b.getScreencoordinatesFromTileCoordinates(b);
+                //a = a.getScreencoordinatesFromTileCoordinates(a);
+                //b = b.getScreencoordinatesFromTileCoordinates(b);
 
-            //this.CURRENTOnScreen = new Rect((int) a.getValue(0), (int) a.getValue(1), (int) b.getValue(0), (int) b.getValue(1));
+                //this.CURRENTOnScreen = new Rect((int) a.getValue(0), (int) a.getValue(1), (int) b.getValue(0), (int) b.getValue(1));
 
-            this.Boundary = (int) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
+                this.Boundary = (int) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
 
-            Autotile();
-        }
+                Autotile();
+            }
 
-        if (( /* 2 * */KDTREEMAXITEMS) < this.TilesInCurrentTree.size()) { // THE MAXIMUM IN A GIVEN CELL IS NOW KDTREEMMAXITEMS, SINCE THE TREE GETS DEVIDED INTO TWO CHILDREN HALF AS BIG
-            Split();
-        }
-        //KDTREECURRENTLYBUILDING = false;
+            if (( /* 2 * */KDTREEMAXITEMS) < this.TilesInCurrentTree.size()) { // THE MAXIMUM IN A GIVEN CELL IS NOW KDTREEMMAXITEMS, SINCE THE TREE GETS DEVIDED INTO TWO CHILDREN HALF AS BIG
+                Split();
+            }
+            //KDTREECURRENTLYBUILDING = false;
+        }catch (Exception e){
+
+        }
     }
 
 
@@ -250,7 +262,7 @@
         return Boundary;
     }
 
-
+    //TODO make new sorting System to get the visible Tiles more efficently and faster!!!
     public ArrayList<Tile> getVisibleTilesInCurrentTree() { // Looks like it Works!
         ArrayList<Tile> returnTilesfromChildren = new ArrayList<>();
 
@@ -272,13 +284,25 @@
             } else {
                 if (Screenboundaries.intersect(CURRENTOnScreen)) {
                     for (int i = 0; i < this.Children.size(); i++) {
-                        returnTilesfromChildren.addAll(this.Children.get(i).getVisibleTilesInCurrentTree());
+                        try {
+                            returnTilesfromChildren.addAll(this.Children.get(i).getVisibleTilesInCurrentTree());
+                        }catch (Exception e){
+                            Log.d("KDTREE","CHILD = null" + e);
+                        }
                     }
                 }
             }
         } else {
-            returnTilesfromChildren.addAll(this.TilesInCurrentTree);
+            try {
+                for (int i = 0; i < this.TilesInCurrentTree.size();i++) {
+                    if (this.TilesInCurrentTree.get(i).isOnScreen()){
+                        returnTilesfromChildren.add(this.TilesInCurrentTree.get(i));
+                    }
+                }
+                //returnTilesfromChildren.addAll(this.TilesInCurrentTree);
+            }catch (Exception e){
 
+            }
         }
         return returnTilesfromChildren;
 
Index: app/src/main/java/com/jacobjacob/ttproject/Vector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Vector.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Vector.java	(date 1566305118127)
@@ -251,11 +251,11 @@
         return (float) ((plane_n.x * p.x + plane_n.y * p.y + plane_n.z * p.z) - plane_n.skalarprodukt(plane_p));
     }
 
-    ArrayList<Triangle> Triangle_ClipAgainstPlane(Vector plane_p, Vector plane_n, Triangle in_tri) {
-        Triangle out_tri1, out_tri2;
-        Triangle output1;
-        Triangle output2;
-        ArrayList<Triangle> outputArray = new ArrayList<>();
+    public ArrayList<com.jacobjacob.ttproject.Old.Triangle> Triangle_ClipAgainstPlane(Vector plane_p, Vector plane_n, com.jacobjacob.ttproject.Old.Triangle in_tri) {
+        com.jacobjacob.ttproject.Old.Triangle out_tri1, out_tri2;
+        com.jacobjacob.ttproject.Old.Triangle output1;
+        com.jacobjacob.ttproject.Old.Triangle output2;
+        ArrayList<com.jacobjacob.ttproject.Old.Triangle> outputArray = new ArrayList<>();
         // Make sure plane normal is indeed normal
         plane_n = plane_n.normalize();
 
Index: app/src/main/java/com/jacobjacob/ttproject/LevelEditor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/LevelEditor.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/LevelEditor.java	(date 1567961631182)
@@ -2,6 +2,8 @@
 
 import android.graphics.Rect;
 
+import com.jacobjacob.ttproject.Tile.Tile;
+
 import java.util.ArrayList;
 
 import static com.jacobjacob.ttproject.Util.CHUNKCOLOR;
@@ -26,7 +28,6 @@
 import static com.jacobjacob.ttproject.Util.WF;
 import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
 
-//import static com.jacobjacob.ttproject.Util.KDTREECOPY;
 
 public class LevelEditor {
 
Index: app/src/main/java/com/jacobjacob/ttproject/Material.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Material.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Material.java	(date 1567961631081)
@@ -5,9 +5,11 @@
 
 import static com.jacobjacob.ttproject.LevelEditor.SelectedMaterial;
 import static com.jacobjacob.ttproject.Util.ANIMATIONPROGRESS;
+import static com.jacobjacob.ttproject.Util.COLORTILELAYER0;
 import static com.jacobjacob.ttproject.Util.COLORTILELAYER1;
 import static com.jacobjacob.ttproject.Util.COLORTILELAYER2;
 import static com.jacobjacob.ttproject.Util.COLORTILELAYER3;
+import static com.jacobjacob.ttproject.Util.CREATEFASTNORMALS;
 import static com.jacobjacob.ttproject.Util.STARTTIME;
 import static com.jacobjacob.ttproject.Util.SeekbarALPHA;
 import static com.jacobjacob.ttproject.Util.SeekbarANIMATON;
@@ -15,6 +17,7 @@
 import static com.jacobjacob.ttproject.Util.SeekbarGREEN;
 import static com.jacobjacob.ttproject.Util.SeekbarRED;
 import static com.jacobjacob.ttproject.Util.TILELAYER;
+import static com.jacobjacob.ttproject.Util.TILELAYERSTART;
 import static com.jacobjacob.ttproject.Util.TILETEXTURE;
 import static com.jacobjacob.ttproject.Util.UPDATETILESET;
 
@@ -22,7 +25,7 @@
 public class Material {
 
     private int Number, Layer1, Layer2, Layer3;
-    private int ColorLayer1, ColorLayer2, ColorLayer3;
+    private int ColorLayer1, ColorLayer2, ColorLayer3, ColorLayer0;
     private int[][] AnimationColor;
     private boolean hasAnimation = false;
     private int Animationtime = 0;
@@ -30,15 +33,27 @@
     public Material() {
     }
 
+    /**
+     * Material initializer
+     * The Material can then be used to change the Colors of the Tileparts to create a more diversed Tileset easily
+     *
+     * @param Number      The Id of the Material / unique identifier
+     * @param Layer1      The first layer = red channel in the Textureimage / to change the number of a layer means to choose parts of the custom Tileset
+     * @param Layer2      The second layer = green channel in the Textureimage / to change the number of a layer means to choose parts of the custom Tileset
+     * @param Layer3      The third layer = blue channel in the Textureimage / to change the number of a layer means to choose parts of the custom Tileset
+     * @param ColorLayer1 The Colors the different Layers get painted in
+     * @param ColorLayer2 The Colors the different Layers get painted in
+     * @param ColorLayer3 The Colors the different Layers get painted in
+     */
     public Material(int Number, int Layer1, int Layer2, int Layer3, int ColorLayer1, int ColorLayer2, int ColorLayer3) {
         this.Number = Number;
-        if (Layer1 < 0){
+        if (Layer1 < 0) {
             Layer1 = 0;
         }
-        if (Layer2 < 0){
+        if (Layer2 < 0) {
             Layer2 = 0;
         }
-        if (Layer3 < 0){
+        if (Layer3 < 0) {
             Layer3 = 0;
         }
         this.Layer1 = Layer1;
@@ -56,6 +71,20 @@
         this.AnimationColor = new int[31][4];
     }
 
+    /**
+     * Changes the Backgroundcolor of the 15th Tile / the bottom of the Tile
+     *
+     * @param Colorlayer0 Color that the lowest part gets painted in
+     */
+    public void setColorLayer0(int Colorlayer0) {
+        this.ColorLayer0 = Colorlayer0;
+    }
+
+    /**
+     * int for the lenght of an Animation
+     *
+     * @param Anim int * 1000 is the Animationlength in ms
+     */
     public void setAnimationtime(int Anim) { // in s - Time of the whole animation
         this.hasAnimation = false;
         if (Anim < 1) {
@@ -67,9 +96,19 @@
         this.Animationtime = Anim; // in ms
     }
 
+    public boolean showNormal() {
+        if (this.Animationtime == 1000) {
+            return true; //hasAnimation;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Takes in all the saved ints and interpolates and updates the Tileset
+     */
     public void UpdateTileset() {
 
-
         int Anim = ANIMATIONPROGRESS; // int from 0 to seekbarmax(30)
         float Animfloat = ANIMATIONPROGRESS;
 
@@ -162,29 +201,36 @@
             }
         }
         if (SelectedMaterial == this.Number) {
-            if (TILELAYER == 4) {
+            if (TILELAYER == TILELAYERSTART + 4) {
                 SeekbarALPHA.setProgress(Color.alpha(ColorA));
                 SeekbarRED.setProgress(Color.red(ColorA));
                 SeekbarGREEN.setProgress(Color.green(ColorA));
                 SeekbarBLUE.setProgress(Color.blue(ColorA));
             }
-            if (TILELAYER == 5) {
+            if (TILELAYER == TILELAYERSTART + 5) {
                 SeekbarALPHA.setProgress(Color.alpha(ColorB));
                 SeekbarRED.setProgress(Color.red(ColorB));
                 SeekbarGREEN.setProgress(Color.green(ColorB));
                 SeekbarBLUE.setProgress(Color.blue(ColorB));
             }
-            if (TILELAYER == 6) {
+            if (TILELAYER == TILELAYERSTART + 6) {
                 SeekbarALPHA.setProgress(Color.alpha(ColorC));
                 SeekbarRED.setProgress(Color.red(ColorC));
                 SeekbarGREEN.setProgress(Color.green(ColorC));
                 SeekbarBLUE.setProgress(Color.blue(ColorC));
             }
         }
-        TILETEXTURE.UpdateTilemap(this.Number, this.Layer1, this.Layer2, this.Layer3, ColorA, ColorB, ColorC);
+        TILETEXTURE.UpdateTilemap(this.Number, this.Layer1, this.Layer2, this.Layer3, this.ColorLayer0, ColorA, ColorB, ColorC);
     }
 
-
+    /**
+     * This Method interpolates two Color integers
+     *
+     * @param C1       The first integer
+     * @param C2       The second integer
+     * @param Progress The Value between 0 and 1 that the new Color gets interpolated to
+     * @return
+     */
     private int interpolateColor(int C1, int C2, float Progress) {
 
         Vector Colorvec = (new Vector(Color.alpha(C2), Color.red(C2), Color.green(C2), Color.blue(C2))).subtract(new Vector(Color.alpha(C1), Color.red(C1), Color.green(C1), Color.blue(C1)));
@@ -197,21 +243,31 @@
         return Color.argb(a, r, g, b);
     }
 
+    /**
+     * Updates the Colorsliders to the corresponding Colors at the Layervalue
+     * That makes editing the Colors easier
+     */
     public void UpdateSeekbarProgress() {
         //if (this.Oldprogress != ANIMATIONPROGRESS) {
-        if (TILELAYER == 1) {
+        if (TILELAYER == TILELAYERSTART) {
+            SeekbarALPHA.setProgress(Color.alpha(this.ColorLayer0));
+            SeekbarRED.setProgress(Color.red(this.ColorLayer0));
+            SeekbarGREEN.setProgress(Color.green(this.ColorLayer0));
+            SeekbarBLUE.setProgress(Color.blue(this.ColorLayer0));
+        }
+        if (TILELAYER == TILELAYERSTART + 1) {
             SeekbarALPHA.setProgress(Color.alpha(this.ColorLayer1));
             SeekbarRED.setProgress(Color.red(this.ColorLayer1));
             SeekbarGREEN.setProgress(Color.green(this.ColorLayer1));
             SeekbarBLUE.setProgress(Color.blue(this.ColorLayer1));
         }
-        if (TILELAYER == 2) {
+        if (TILELAYER == TILELAYERSTART + 2) {
             SeekbarALPHA.setProgress(Color.alpha(this.ColorLayer2));
             SeekbarRED.setProgress(Color.red(this.ColorLayer2));
             SeekbarGREEN.setProgress(Color.green(this.ColorLayer2));
             SeekbarBLUE.setProgress(Color.blue(this.ColorLayer2));
         }
-        if (TILELAYER == 3) {
+        if (TILELAYER == TILELAYERSTART + 3) {
             SeekbarALPHA.setProgress(Color.alpha(this.ColorLayer3));
             SeekbarRED.setProgress(Color.red(this.ColorLayer3));
             SeekbarGREEN.setProgress(Color.green(this.ColorLayer3));
@@ -221,9 +277,12 @@
         //}
     }
 
+    /**
+     * Changes the Color of the Seekbarthumb to the Color of the Animation at the current progress to make it easier to see the already saved Timeframes
+     */
     public void UpdateAnimationSeekbarColor() {
         if (this.AnimationColor != null && this.AnimationColor[ANIMATIONPROGRESS] != null) {
-            int AnimColor = this.AnimationColor[ANIMATIONPROGRESS][TILELAYER - 4];
+            int AnimColor = this.AnimationColor[ANIMATIONPROGRESS][TILELAYERSTART + TILELAYER - 4];
             if (AnimColor != 0) {
                 SeekbarANIMATON.getThumb().setColorFilter(AnimColor, PorterDuff.Mode.SCREEN);
             } else {
@@ -232,26 +291,41 @@
         }
     }
 
+    /**
+     * Sets Colorvalues to Seekbarvalues as well as setting the Animationcolorvalues inside an Array
+     */
     public void UpdateMaterial() {
-        if (TILELAYER == 1) {
+        if (TILELAYER == TILELAYERSTART) {
+            this.ColorLayer0 = COLORTILELAYER0;
+        } else if (TILELAYER == TILELAYERSTART + 1) {
             this.ColorLayer1 = COLORTILELAYER1;
-        } else if (TILELAYER == 2) {
+        } else if (TILELAYER == TILELAYERSTART + 2) {
             this.ColorLayer2 = COLORTILELAYER2;
-        } else if (TILELAYER == 3) {
+        } else if (TILELAYER == TILELAYERSTART + 3) {
             this.ColorLayer3 = COLORTILELAYER3;
-        } else if (TILELAYER == 4 && !UPDATETILESET) {
+        } else if (TILELAYER == TILELAYERSTART + 4 && !UPDATETILESET) {
             this.AnimationColor[ANIMATIONPROGRESS][0] = COLORTILELAYER1;
-        } else if (TILELAYER == 5 && !UPDATETILESET) {
+        } else if (TILELAYER == TILELAYERSTART + 5 && !UPDATETILESET) {
             this.AnimationColor[ANIMATIONPROGRESS][1] = COLORTILELAYER2;
-        } else if (TILELAYER == 6 && !UPDATETILESET) {
+        } else if (TILELAYER == TILELAYERSTART + 6 && !UPDATETILESET) {
             this.AnimationColor[ANIMATIONPROGRESS][2] = COLORTILELAYER3;
         }
     }
 
+    /**
+     * Get the Id of the Material
+     *
+     * @return The Id of the Material / unique identifier
+     */
     public int getNumber() {
         return this.Number;
     }
 
+    /**
+     * Checks if the Material has an Animation
+     *
+     * @return a bool if the time of the Animation is greater than 1000ms
+     */
     public boolean hasAnimation() {
         if (this.Animationtime > 1000) {
             return true;
@@ -261,14 +335,29 @@
         //return this.hasAnimation;
     }
 
+    /**
+     * Sets the unique id
+     *
+     * @param Number The new Id of the Material
+     */
     public void setNumber(int Number) {
         this.Number = Number;
     }
 
+    /**
+     * Get The Material information as String in order to save it
+     *
+     * @return The Id/ Number, the Layers and fitting Colors and the Backgroundcolor
+     */
     public String getMaterialdetails() {
-        return this.Number + " " + this.Layer1 + " " + this.Layer2 + " " + this.Layer3 + " " + this.ColorLayer1 + " " + this.ColorLayer2 + " " + this.ColorLayer3;
+        return this.Number + " " + this.Layer1 + " " + this.Layer2 + " " + this.Layer3 + " " + this.ColorLayer1 + " " + this.ColorLayer2 + " " + this.ColorLayer3 + " " + this.ColorLayer0;
     }
 
+    /**
+     * Get The Animation information as String in order to save it
+     *
+     * @return A String of Colors alternating from Layer 1 to Layer 3
+     */
     public String getAnimationdetails() {
         String Animinfo = new String();
 
@@ -283,47 +372,95 @@
         return this.Number + " " + this.Animationtime / 1000 + Animinfo; // Animationtime in s
     }
 
+    /**
+     * Gives the Material the loaded int[][] that contains the Animationdetails
+     *
+     * @param Animation int[][] with the 3 Layers and a lenght > 1
+     */
     public void LoadAnimation(int[][] Animation) {
         this.AnimationColor = Animation;
     }
 
-
+    /**
+     * Updates the Tileset Bitmap if (TILELAYER < TILELAYERSTART + 4)
+     */
     public void UpdateMaterialTileset() {
-        if (TILELAYER < 4) {
-            TILETEXTURE.CreateTilemap(this.Number, this.Layer1, this.Layer2, this.Layer3, this.ColorLayer1, this.ColorLayer2, this.ColorLayer3);
+        if (TILELAYER < TILELAYERSTART + 4) {
+            TILETEXTURE.CreateTilemap(this.Number, this.Layer1, this.Layer2, this.Layer3, this.ColorLayer0, this.ColorLayer1, this.ColorLayer2, this.ColorLayer3);
+            UpdateMaterialTilesetNormal();
+        }
+    }
+
+    public void CreateMaterialTileset() {
+        TILETEXTURE.CreateTilemap(this.Number, this.Layer1, this.Layer2, this.Layer3, this.ColorLayer0, this.ColorLayer1, this.ColorLayer2, this.ColorLayer3);
+    }
+
+    public void UpdateMaterialTilesetNormal() {
+        if (TILELAYER < TILELAYERSTART + 4) {
+            if (CREATEFASTNORMALS) {
+                TILETEXTURE.CreateNormals(this.Number, this.Layer1, this.Layer2, this.Layer3, Color.alpha(ColorLayer1), Color.alpha(ColorLayer2), Color.alpha(ColorLayer3));
+            } else {
+                TILETEXTURE.CreateAccurateNormals(this.Number, this.Layer1, this.Layer2, this.Layer3, Color.alpha(ColorLayer1), Color.alpha(ColorLayer2), Color.alpha(ColorLayer3));
+            }
         }
     }
 
+    public void CreateMaterialTilesetNormal() {
+        if (CREATEFASTNORMALS) {
+            TILETEXTURE.CreateNormals(this.Number, this.Layer1, this.Layer2, this.Layer3, Color.alpha(ColorLayer1), Color.alpha(ColorLayer2), Color.alpha(ColorLayer3));
+        } else {
+            TILETEXTURE.CreateAccurateNormals(this.Number, this.Layer1, this.Layer2, this.Layer3, Color.alpha(ColorLayer1), Color.alpha(ColorLayer2), Color.alpha(ColorLayer3));
+        }
+    }
+
+
+    /**
+     * Sets a new Layervalue to the Layer Corresponding to the TILELAYER
+     *
+     * @param Layer123 the new Value for that specific Layer
+     */
     public void setLayer123(int Layer123) {
-        if (TILELAYER == 1) {
+        if (TILELAYER == TILELAYERSTART + 1) {
             this.Layer1 = Layer123;
+        } else if (TILELAYER == TILELAYERSTART + 2) {
             this.Layer2 = Layer123;
-            this.Layer3 = Layer123;
-        } else if (TILELAYER == 2) {
-            this.Layer2 = Layer123;
-            this.Layer3 = Layer123;
-        } else if (TILELAYER == 3) {
+        } else if (TILELAYER == TILELAYERSTART + 3) {
             this.Layer3 = Layer123;
         }
     }
 
+    /**
+     * Returns the number of a Layer
+     *
+     * @param Layer The layer it returns the number from
+     * @return
+     */
     public int getLayer(int Layer) {
-        if (Layer == 1) {
+        if (Layer == TILELAYERSTART + 1) {
             return this.Layer1;
-        } else if (Layer == 2) {
+        } else if (Layer == TILELAYERSTART + 2) {
             return this.Layer2;
-        } else if (Layer == 3) {
+        } else if (Layer == TILELAYERSTART + 3) {
             return this.Layer3;
-        }else return 0;
+        } else return 0;
     }
 
+    /**
+     * Returns the number of a ColorLayer
+     *
+     * @param ColorLayer The layer it returns the color from
+     * @return
+     */
     public int getColor(int ColorLayer) {
-        if (ColorLayer == 1) {
+        if (ColorLayer == TILELAYERSTART) {
+            return this.ColorLayer0;
+        }
+        if (ColorLayer == TILELAYERSTART + 1) {
             return this.ColorLayer1;
-        } else if (ColorLayer == 2) {
+        } else if (ColorLayer == TILELAYERSTART + 2) {
             return this.ColorLayer2;
-        } else if (ColorLayer == 3) {
+        } else if (ColorLayer == TILELAYERSTART + 3) {
             return this.ColorLayer3;
-        }else return 0;
+        } else return 0;
     }
 }
Index: app/src/main/java/com/jacobjacob/ttproject/UpdateHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/UpdateHandler.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/UpdateHandler.java	(date 1567883248736)
@@ -9,30 +9,30 @@
 import static com.jacobjacob.ttproject.Util.MATERIALARRAY;
 import static com.jacobjacob.ttproject.Util.MATERIALLIST;
 import static com.jacobjacob.ttproject.Util.MATERIALLISTUPDATING;
-import static com.jacobjacob.ttproject.Util.MINUPDATETIME;
 import static com.jacobjacob.ttproject.Util.RENDERERTILES;
 import static com.jacobjacob.ttproject.Util.RUNNING;
 import static com.jacobjacob.ttproject.Util.TILELAYER;
+import static com.jacobjacob.ttproject.Util.TILELAYERSTART;
 import static com.jacobjacob.ttproject.Util.TILESIZE;
 import static com.jacobjacob.ttproject.Util.UPDATEVIEW;
 import static com.jacobjacob.ttproject.Util.camera;
 import static com.jacobjacob.ttproject.Util.movespeed;
 
-class UpdateHandler/* extends AppCompatActivity*/ {
+public class UpdateHandler/* extends AppCompatActivity*/ {
 
-    static Rasterizer Rasterize;
+    static com.jacobjacob.ttproject.Old.Rasterizer Rasterize;
     //public static RenderTiles RenderTiles;
     static boolean UPDATEBITMAP;
     //boolean check = true;
 
 
     UpdateHandler() {
-        Rasterize = new Rasterizer();
+        Rasterize = new com.jacobjacob.ttproject.Old.Rasterizer();
         RENDERERTILES = new RenderTiles();
         movespeed = 2 * TILESIZE / 3;
     }
 
-    void updateScreen() {
+    public void updateScreen() {
 
 
         //updateTiles();
@@ -55,7 +55,12 @@
         }
 
         RENDERERTILES.DrawSelectedTile(); /** Draws the Inventory to the left or top*/
-        RENDERERTILES.DrawSelectedTileLayer();
+        try {
+
+            RENDERERTILES.DrawSelectedTileLayer();
+        } catch (Exception e) {
+            Log.d("Renderer: ", "Draw Tile Layer" + e);
+        }
         RENDERERTILES.DrawInventoryTiles(); /**Inventory to select IDs**/
 
         RENDERERTILES.postImage();
@@ -68,7 +73,7 @@
         while (RUNNING) {
             //UPDATEVIEW = true;
             if (UPDATEVIEW) {
-                if (System.currentTimeMillis() - LASTUPDATETIME >= MINUPDATETIME) { // the minimum ammount of Time has passed, you may now update the Screen
+                if (/*System.currentTimeMillis() - LASTUPDATETIME >= MINUPDATETIME ||/**/true) { // the minimum ammount of Time has passed, you may now update the Screen
                     //long Starttime = System.currentTimeMillis();
                     if (FRAMEDRAWN && !KDTREECURRENTLYBUILDING) {
                         //thisIMAGE.findViewById(R.id.SCREEN);
@@ -106,10 +111,10 @@
     void runTileUpdates() {
         boolean UPDATEBITMAP2 = false;
         while (RUNNING) {
-            if (UPDATEBITMAP != UPDATEBITMAP2 && FRAMEDRAWN && UPDATEVIEW && TILELAYER == 0 || TILELAYER > 3) {
+            if (UPDATEBITMAP != UPDATEBITMAP2 && FRAMEDRAWN && UPDATEVIEW /*&& TILELAYER == 0*/) {
                 for (int i = 0; i < MATERIALARRAY.length; i++) {
                     if (MATERIALARRAY[i] != null) {
-                        if (MATERIALARRAY[i].hasAnimation()) {
+                        if ((MATERIALARRAY[i].hasAnimation() && (TILELAYER > 3 + TILELAYERSTART) || MATERIALARRAY[i].showNormal())) {
                             MATERIALARRAY[i].UpdateTileset();
                             MATERIALLIST[i] = MATERIALLISTUPDATING[i];
                         }
Index: app/src/main/java/com/jacobjacob/ttproject/Camera.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Camera.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Camera.java	(date 1566233032444)
@@ -75,14 +75,6 @@
         //MainActivity.uHandeler.updateScreen();
     }
 
-    public int getL() {
-        return l;
-    }
-
-    public void setL(int l) {
-        this.l = l;
-    }
-
     public int getR() {
         return r;
     }
@@ -91,13 +83,6 @@
         this.r = r;
     }
 
-    public int getT() {
-        return t;
-    }
-
-    public void setT(int t) {
-        this.t = t;
-    }
 
     public int getB() {
         return b;
@@ -111,10 +96,6 @@
         return UP;
     }
 
-    public void setUP(Vector UP) {
-        this.UP = UP;
-    }
-
     public Vector getEye2D() {
         //if (FRAMEDRAWN) {
         //    this.eye2DFRAME = this.eye2D;
@@ -141,56 +122,10 @@
             this.eye2D = this.eye2D.addVector(eye);
         }
     }
-    public void setEyeVector(Vector eye) {
-        if (eye != null) {
-            this.eye = eye;
-        }
-    }
-
-    public Vector getZ() {
-        return Z;
-    }
-
-    public void setZ(Vector z) {
-        this.Z = z;
-    }
-
     public Vector getW() {
         return W.normalize(); //W
     }
 
-    public void setW(Vector w) {
-        this.W = w;
-    }
-
-    public Vector getU() {
-        return U;
-    }
-
-    public void setU(Vector u) {
-        this.U = u;
-    }
-
-    public Vector getV() {
-        return V;
-    }
-
-    public void setV(Vector v) {
-        this.V = v;
-    }
-
-    public double getD() {
-        return d;
-    }
-
-    public void setD(double d) {
-        this.d = d;
-    }
-
-    public Vector getW_d_negated() {
-        return W_d_negated;
-    }
-
     public void setW_d_negated(Vector w_d_negated) {
         W_d_negated = w_d_negated;
     }
Index: app/src/main/res/layout/activity_main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_main.xml	(date 1564787735000)
+++ app/src/main/res/layout/activity_main.xml	(date 1567880082067)
@@ -5,6 +5,9 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     tools:context=".MainActivity">
+<android.opengl.GLSurfaceView
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content" />
 
     <ImageView
         android:id="@+id/SCREEN"
@@ -263,4 +266,15 @@
         app:layout_constraintRight_toLeftOf="@id/seekBarALPHA"
         app:layout_constraintTop_toTopOf="@id/LoadLVL"
         app:layout_constraintVertical_bias="0.0" />
+
+    <ToggleButton
+        android:id="@+id/OPENGL_TOGGLE"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:text="OPENGL"
+        android:textOff="OPENGLf"
+        android:textOn="OPENGLt"
+        app:layout_constraintBottom_toBottomOf="@+id/REMOVETILES"
+        app:layout_constraintStart_toEndOf="@+id/REMOVETILES"
+        app:layout_constraintTop_toTopOf="@+id/REMOVETILES" />
 </android.support.constraint.ConstraintLayout>
\ No newline at end of file
Index: app/src/main/java/com/jacobjacob/ttproject/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/MainActivity.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/MainActivity.java	(date 1567961631107)
@@ -1,38 +1,45 @@
 package com.jacobjacob.ttproject;
 
 import android.annotation.SuppressLint;
+import android.app.ActivityManager;
+import android.content.Context;
 import android.content.pm.ActivityInfo;
-import android.content.res.TypedArray;
+import android.content.pm.ConfigurationInfo;
 import android.graphics.Color;
 import android.graphics.Point;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffColorFilter;
+import android.os.Build;
 import android.os.Bundle;
 import android.os.Looper;
+import android.support.annotation.RequiresApi;
 import android.support.v7.app.AppCompatActivity;
-import android.util.TypedValue;
+import android.util.Log;
 import android.view.Display;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.WindowManager;
 import android.widget.AdapterView;
 import android.widget.ArrayAdapter;
+import android.widget.Button;
 import android.widget.CompoundButton;
 import android.widget.ImageView;
 import android.widget.SeekBar;
-import android.widget.Toast;
+import android.widget.TextView;
+import android.widget.ToggleButton;
 
 import static com.jacobjacob.ttproject.LevelEditor.SelectedMaterial;
 import static com.jacobjacob.ttproject.Util.ADDLEFT;
 import static com.jacobjacob.ttproject.Util.ADDRIGHT;
 import static com.jacobjacob.ttproject.Util.ANIMATIONPROGRESS;
 import static com.jacobjacob.ttproject.Util.ANIMATIONPROGRESSPERCENT;
+import static com.jacobjacob.ttproject.Util.COLORTILELAYER0;
 import static com.jacobjacob.ttproject.Util.COLORTILELAYER1;
 import static com.jacobjacob.ttproject.Util.COLORTILELAYER2;
 import static com.jacobjacob.ttproject.Util.COLORTILELAYER3;
 import static com.jacobjacob.ttproject.Util.CONTEXT;
+import static com.jacobjacob.ttproject.Util.CUSTOMBUTTONSLIST;
 import static com.jacobjacob.ttproject.Util.DESTROYTILES;
-import static com.jacobjacob.ttproject.Util.DISPAYTOAST;
 import static com.jacobjacob.ttproject.Util.DISPLAYFRAMES;
 import static com.jacobjacob.ttproject.Util.DISPLAYINVENTORY;
 import static com.jacobjacob.ttproject.Util.DRAWFILLTILERECT;
@@ -44,8 +51,6 @@
 import static com.jacobjacob.ttproject.Util.FILLTILERECT;
 import static com.jacobjacob.ttproject.Util.FILLTILES;
 import static com.jacobjacob.ttproject.Util.FRAMES;
-import static com.jacobjacob.ttproject.Util.FRAMETIME;
-import static com.jacobjacob.ttproject.Util.HEIGHT;
 import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
 import static com.jacobjacob.ttproject.Util.INVENTORY_TOGGLE;
 import static com.jacobjacob.ttproject.Util.KDTREECURRENTLYBUILDING;
@@ -59,9 +64,13 @@
 import static com.jacobjacob.ttproject.Util.MOVE_RIGHT;
 import static com.jacobjacob.ttproject.Util.MOVE_UP;
 import static com.jacobjacob.ttproject.Util.NOISE;
+import static com.jacobjacob.ttproject.Util.OPENGL;
+import static com.jacobjacob.ttproject.Util.OPENGL_TOGGLE;
 import static com.jacobjacob.ttproject.Util.PLACETILE;
 import static com.jacobjacob.ttproject.Util.REMOVETILES;
 import static com.jacobjacob.ttproject.Util.RENDERER;
+import static com.jacobjacob.ttproject.Util.RF;
+import static com.jacobjacob.ttproject.Util.SETTINGS_OPENGL;
 import static com.jacobjacob.ttproject.Util.SeekbarALPHA;
 import static com.jacobjacob.ttproject.Util.SeekbarANIMATON;
 import static com.jacobjacob.ttproject.Util.SeekbarBLUE;
@@ -70,26 +79,33 @@
 import static com.jacobjacob.ttproject.Util.TEXTUREWIDTH;
 import static com.jacobjacob.ttproject.Util.TILEEDIT;
 import static com.jacobjacob.ttproject.Util.TILELAYER;
+import static com.jacobjacob.ttproject.Util.TILELAYERSTART;
 import static com.jacobjacob.ttproject.Util.TILETEXTURE;
 import static com.jacobjacob.ttproject.Util.TILEUPDATE;
+import static com.jacobjacob.ttproject.Util.TOUCHCUSTOMBUTTONS;
+import static com.jacobjacob.ttproject.Util.TOUCHPOSITION;
+import static com.jacobjacob.ttproject.Util.TOUCHSTATE;
 import static com.jacobjacob.ttproject.Util.UPDATETILESET;
-import static com.jacobjacob.ttproject.Util.WIDTH;
+import static com.jacobjacob.ttproject.Util.WF;
 import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
 import static com.jacobjacob.ttproject.Util.camera;
 import static com.jacobjacob.ttproject.Util.movespeed;
 
 public class MainActivity extends AppCompatActivity {
 
-    public float xmove, ymove, xmove2, ymove2, height;
+    public float xmove, ymove, xmove2, ymove2;
     public static ImageView IMAGE;
     public static boolean UHANDELERSTARTED = false;
+    public static com.jacobjacob.ttproject.OpenGL.MainSurfaceView mainSurfaceView;
 
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
     @SuppressLint("ClickableViewAccessibility")
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
         super.onCreate(savedInstanceState);
 
+
         Display display = getWindowManager().getDefaultDisplay();
         getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
 
@@ -101,608 +117,718 @@
         WIDTHSCREEN = size.x;
         HEIGHTSCREEN = size.y;
 
-        int[] textSizeAttr = new int[]{R.attr.actionBarSize};
-        TypedArray a = getApplicationContext().obtainStyledAttributes(new TypedValue().data, textSizeAttr);
-        height = a.getDimensionPixelSize(0, 0);
-        a.recycle();
+
+        //FrameLayout Layer = new FrameLayout(this.getApplicationContext());
+        //Layer.addView(findViewById());
+
+        /**/
+        //OPENGL = true;
+
+        // try {
+        CONTEXT = this.getApplicationContext();
+
+        RF.ReadSettings();
+
+        //}catch (Exception e){
+        //    Log.d("Read: ", "Settings file broken " + e);
+        //}
+        //OPENGL = !OPENGL;
+
+        //Log.d("Openglbool ", String.valueOf(OPENGL));
+
+
+        if (OPENGL) {
+            ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
+            ConfigurationInfo info = am.getDeviceConfigurationInfo();
+            boolean supportES2 = (info.reqGlEsVersion >= 0x30000);
+            if (supportES2) {
+                com.jacobjacob.ttproject.OpenGL.MainRenderer mainRenderer = new com.jacobjacob.ttproject.OpenGL.MainRenderer(/**/getApplicationContext()/**/);
+
+                mainSurfaceView = new com.jacobjacob.ttproject.OpenGL.MainSurfaceView(this);
+                mainSurfaceView.setEGLContextClientVersion(3);
+                mainSurfaceView.setRenderer(mainRenderer);
+                this.setContentView(mainSurfaceView);
+
+            } else {
+                Log.e("OpenGLES 2", "Your device doesn't support ES2. (" + info.reqGlEsVersion + ")");
+            }
+
+
+            IMAGE = findViewById(R.id.SCREEN);
+            CONTEXT = getApplicationContext();
+            TILETEXTURE = new Tiletexture();
+            LE.Inventory();
+            NOISE.setSeed(System.currentTimeMillis() / 1000);
+
+            LE.LoadLevel();
+
+            //LE.SaveLevel();
+
+            for (int i = 0; i < MATERIALARRAY.length; i++) {
+                MATERIALARRAY[i].CreateMaterialTilesetNormal();
+            }
+
+        } /**/ else {
+            //setContentView(mainSurfaceView);
 
 
-        IMAGE = findViewById(R.id.SCREEN);
-        CONTEXT = getApplicationContext();
-        TILETEXTURE = new Tiletexture();
+            IMAGE = findViewById(R.id.SCREEN);
+            CONTEXT = getApplicationContext();
+            TILETEXTURE = new Tiletexture();
 
-        LE.Inventory();
+            LE.Inventory();
 
-        NOISE.setSeed(System.currentTimeMillis() / 1000);
+            NOISE.setSeed(System.currentTimeMillis() / 1000);
+            LE.LoadLevel();
+
+            SeekbarALPHA = new SeekBar(CONTEXT);
+            SeekbarRED = new SeekBar(CONTEXT);
+            SeekbarGREEN = new SeekBar(CONTEXT);
+            SeekbarBLUE = new SeekBar(CONTEXT);
+            SeekbarANIMATON = new SeekBar(CONTEXT);
+            MOVE_UP = new Button(CONTEXT);
+            MOVE_FORWARD = new Button(CONTEXT);
+            MOVE_DOWN = new Button(CONTEXT);
+            MOVE_LEFT = new Button(CONTEXT);
+            MOVE_BACK = new Button(CONTEXT);
+            MOVE_RIGHT = new Button(CONTEXT);
+            INVENTORY_TOGGLE = new ToggleButton(CONTEXT);
+            OPENGL_TOGGLE = new ToggleButton(CONTEXT);
+            FILLPLACE = new ToggleButton(CONTEXT);
+            DRAWKDTREE = new ToggleButton(CONTEXT);
+            REMOVETILES = new ToggleButton(CONTEXT);
+            ADDLEFT = new Button(CONTEXT);
+            ADDRIGHT = new Button(CONTEXT);
+            TILEEDIT = new Button(CONTEXT);
+            DISPLAYFRAMES = new TextView(CONTEXT);
+
 
-        TILEEDIT = findViewById(R.id.TOGGLETEXTUREEDIT);
-        SeekbarALPHA = findViewById(R.id.seekBarALPHA);
-        SeekbarRED = findViewById(R.id.seekBarRED);
-        SeekbarGREEN = findViewById(R.id.seekBarGREEN);
-        SeekbarBLUE = findViewById(R.id.seekBarBLUE);
-        SeekbarANIMATON = new SeekBar(this.getApplicationContext());
-        SeekbarANIMATON = findViewById(R.id.seekBarANIMATION);
+            TILEEDIT = findViewById(R.id.TOGGLETEXTUREEDIT);
+            SeekbarALPHA = findViewById(R.id.seekBarALPHA);
+            SeekbarRED = findViewById(R.id.seekBarRED);
+            SeekbarGREEN = findViewById(R.id.seekBarGREEN);
+            SeekbarBLUE = findViewById(R.id.seekBarBLUE);
+            SeekbarANIMATON = new SeekBar(this.getApplicationContext());
+            SeekbarANIMATON = findViewById(R.id.seekBarANIMATION);
 
-        MOVE_UP = findViewById(R.id.MOVE_UP);
-        MOVE_FORWARD = findViewById(R.id.MOVE_FORWARD);
-        MOVE_DOWN = findViewById(R.id.MOVE_DOWN);
-        MOVE_LEFT = findViewById(R.id.MOVE_LEFT);
-        MOVE_BACK = findViewById(R.id.MOVE_BACK);
-        MOVE_RIGHT = findViewById(R.id.MOVE_RIGHT);
-        INVENTORY_TOGGLE = findViewById(R.id.INVENTORY_TOGGLE);
-        FILLPLACE = findViewById(R.id.FILLPLACE);
-        DRAWKDTREE = findViewById(R.id.DRAWKDTREE);
-        ADDLEFT = findViewById(R.id.ADDLEFT);
-        ADDRIGHT = findViewById(R.id.ADDRIGHT);
-        DISPLAYFRAMES = findViewById(R.id.DISPLAYFRAMES);
-        REMOVETILES = findViewById(R.id.REMOVETILES);
+            MOVE_UP = findViewById(R.id.MOVE_UP);
+            MOVE_FORWARD = findViewById(R.id.MOVE_FORWARD);
+            MOVE_DOWN = findViewById(R.id.MOVE_DOWN);
+            MOVE_LEFT = findViewById(R.id.MOVE_LEFT);
+            MOVE_BACK = findViewById(R.id.MOVE_BACK);
+            MOVE_RIGHT = findViewById(R.id.MOVE_RIGHT);
+            INVENTORY_TOGGLE = findViewById(R.id.INVENTORY_TOGGLE);
+            OPENGL_TOGGLE = findViewById(R.id.OPENGL_TOGGLE);
+            FILLPLACE = findViewById(R.id.FILLPLACE);
+            DRAWKDTREE = findViewById(R.id.DRAWKDTREE);
+            ADDLEFT = findViewById(R.id.ADDLEFT);
+            ADDRIGHT = findViewById(R.id.ADDRIGHT);
+            DISPLAYFRAMES = findViewById(R.id.DISPLAYFRAMES);
+            REMOVETILES = findViewById(R.id.REMOVETILES);
 
-        /**/
-        DISPLAYFRAMES.setVisibility(View.INVISIBLE);
-        ADDLEFT.setVisibility(View.INVISIBLE);
-        ADDRIGHT.setVisibility(View.INVISIBLE);
-        REMOVETILES.setVisibility(View.INVISIBLE);
-        DRAWKDTREE.setVisibility(View.INVISIBLE);
-        FILLPLACE.setVisibility(View.INVISIBLE);
+            DISPLAYFRAMES.setVisibility(View.INVISIBLE);
+            ADDLEFT.setVisibility(View.INVISIBLE);
+            ADDRIGHT.setVisibility(View.INVISIBLE);
+            REMOVETILES.setVisibility(View.INVISIBLE);
+            DRAWKDTREE.setVisibility(View.INVISIBLE);
+            FILLPLACE.setVisibility(View.INVISIBLE);
+            OPENGL_TOGGLE.setVisibility(View.INVISIBLE);
 
-        TILEEDIT.setText("EDIT TILE");
-        SeekbarALPHA.setVisibility(View.INVISIBLE);
-        SeekbarRED.setVisibility(View.INVISIBLE);
-        SeekbarGREEN.setVisibility(View.INVISIBLE);
-        SeekbarBLUE.setVisibility(View.INVISIBLE);
-        SeekbarANIMATON.setVisibility(View.INVISIBLE);
+            TILEEDIT.setText("EDIT TILE");
+            SeekbarALPHA.setVisibility(View.INVISIBLE);
+            SeekbarRED.setVisibility(View.INVISIBLE);
+            SeekbarGREEN.setVisibility(View.INVISIBLE);
+            SeekbarBLUE.setVisibility(View.INVISIBLE);
+            SeekbarANIMATON.setVisibility(View.INVISIBLE);
 
-        SeekbarALPHA.getThumb().setColorFilter(Color.rgb(255, 255, 255), PorterDuff.Mode.SCREEN);
-        SeekbarRED.getThumb().setColorFilter(Color.rgb(255, 0, 0), PorterDuff.Mode.SCREEN);
-        SeekbarGREEN.getThumb().setColorFilter(Color.rgb(0, 255, 0), PorterDuff.Mode.SCREEN);
-        SeekbarBLUE.getThumb().setColorFilter(Color.rgb(0, 0, 255), PorterDuff.Mode.SCREEN);
+            SeekbarALPHA.getThumb().setColorFilter(Color.rgb(255, 255, 255), PorterDuff.Mode.SCREEN);
+            SeekbarRED.getThumb().setColorFilter(Color.rgb(255, 0, 0), PorterDuff.Mode.SCREEN);
+            SeekbarGREEN.getThumb().setColorFilter(Color.rgb(0, 255, 0), PorterDuff.Mode.SCREEN);
+            SeekbarBLUE.getThumb().setColorFilter(Color.rgb(0, 0, 255), PorterDuff.Mode.SCREEN);
 
-        SeekbarALPHA.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(255, 255, 255), PorterDuff.Mode.MULTIPLY));
-        SeekbarRED.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(255, 0, 0), PorterDuff.Mode.MULTIPLY));
-        SeekbarGREEN.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(0, 255, 0), PorterDuff.Mode.MULTIPLY));
-        SeekbarBLUE.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(0, 0, 255), PorterDuff.Mode.MULTIPLY));
+            SeekbarALPHA.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(255, 255, 255), PorterDuff.Mode.MULTIPLY));
+            SeekbarRED.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(255, 0, 0), PorterDuff.Mode.MULTIPLY));
+            SeekbarGREEN.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(0, 255, 0), PorterDuff.Mode.MULTIPLY));
+            SeekbarBLUE.getProgressDrawable().setColorFilter(new PorterDuffColorFilter(Color.rgb(0, 0, 255), PorterDuff.Mode.MULTIPLY));
 
 
-        LOADLVLSPINNER = findViewById(R.id.LoadLVL);
-        ArrayAdapter<String> myAdapter = new ArrayAdapter<String>(MainActivity.this, android.R.layout.simple_list_item_1, FILE_NAMES);
-        myAdapter.setDropDownViewResource(/**/android.R.layout.simple_spinner_dropdown_item/**/);
-        LOADLVLSPINNER.setAdapter(myAdapter);
+            LOADLVLSPINNER = findViewById(R.id.LoadLVL);
+            ArrayAdapter<String> myAdapter = new ArrayAdapter<String>(MainActivity.this, android.R.layout.simple_list_item_1, FILE_NAMES);
+            myAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+            LOADLVLSPINNER.setAdapter(myAdapter);
 
+            //mainSurfaceView.add
 
-        LOADLVLSPINNER.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
-            @Override
-            public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
-                LE.SaveLevel();
-                FILE_NAME = adapterView.getSelectedItem().toString();
+            LOADLVLSPINNER.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+                @Override
+                public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
+                    LE.SaveLevel();
+                    FILE_NAME = adapterView.getSelectedItem().toString();
 
-                LE.LoadLevel();
+                    LE.LoadLevel();
 
-                //uHandeler.updateScreen();
-            }
+                    //uHandeler.updateScreen();
+                }
 
-            @Override
-            public void onNothingSelected(AdapterView<?> adapterView) {
+                @Override
+                public void onNothingSelected(AdapterView<?> adapterView) {
 
-            }
-        });
+                }
+            });
 
 
-        INVENTORY_TOGGLE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
-                DISPLAYINVENTORY = b;
-                if (!DISPLAYINVENTORY) {
-                    /***///DISPLAYFRAMES.setVisibility(View.INVISIBLE);
-                    /***///ADDLEFT.setVisibility(View.INVISIBLE);
-                    /***///ADDRIGHT.setVisibility(View.INVISIBLE);
+            INVENTORY_TOGGLE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
+                    DISPLAYINVENTORY = b;
+                    if (!DISPLAYINVENTORY) {
+                        //DISPLAYFRAMES.setVisibility(View.INVISIBLE);
+                        //ADDLEFT.setVisibility(View.INVISIBLE);
+                        //ADDRIGHT.setVisibility(View.INVISIBLE);
 
 
-                    REMOVETILES.setVisibility(View.INVISIBLE);
-                    DRAWKDTREE.setVisibility(View.INVISIBLE);
-                    FILLPLACE.setVisibility(View.INVISIBLE);
-
+                        REMOVETILES.setVisibility(View.INVISIBLE);
+                        DRAWKDTREE.setVisibility(View.INVISIBLE);
+                        FILLPLACE.setVisibility(View.INVISIBLE);
+                        OPENGL_TOGGLE.setVisibility(View.INVISIBLE);
 
-                } else {
-                    /***///DISPLAYFRAMES.setVisibility(View.VISIBLE);
-                    /***///ADDLEFT.setVisibility(View.VISIBLE);
-                    /***///ADDRIGHT.setVisibility(View.VISIBLE);
+                    } else {
+                        //DISPLAYFRAMES.setVisibility(View.VISIBLE);
+                        //ADDLEFT.setVisibility(View.VISIBLE);
+                        //ADDRIGHT.setVisibility(View.VISIBLE);
 
 
-                    REMOVETILES.setVisibility(View.VISIBLE);
-                    DRAWKDTREE.setVisibility(View.VISIBLE);
-                    FILLPLACE.setVisibility(View.VISIBLE);
+                        REMOVETILES.setVisibility(View.VISIBLE);
+                        DRAWKDTREE.setVisibility(View.VISIBLE);
+                        FILLPLACE.setVisibility(View.VISIBLE);
+                        OPENGL_TOGGLE.setVisibility(View.VISIBLE);
 
 
+                    }
                 }
-                //uHandeler.updateScreen();
-            }
-        });
+            });
+
+            OPENGL_TOGGLE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
+                    SETTINGS_OPENGL = b;
+                    WF.SaveSettings();
+                }
+            });
 
-        FILLPLACE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
+            FILLPLACE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
 
-                if (b) {
-                    FILLTILES = true;
-                    PLACETILE = false;
-                } else {
-                    FILLTILES = false;
-                    PLACETILE = true;
-                }
-                if (TILELAYER > 3) {
-                    FILLTILES = false;
-                    PLACETILE = false;
-                }
+                    if (b) {
+                        FILLTILES = true;
+                        PLACETILE = false;
+                    } else {
+                        FILLTILES = false;
+                        PLACETILE = true;
+                    }
+                    if (TILELAYER > TILELAYERSTART + 3) {
+                        FILLTILES = false;
+                        PLACETILE = false;
+                    }
 
-            }
-        });
+                }
+            });
 
-        REMOVETILES.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
+            REMOVETILES.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
 
-                DESTROYTILES = b;
+                    DESTROYTILES = b;
 
-            }
-        });
+                }
+            });
 
-        DRAWKDTREE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton compoundButton, boolean drawkdtreebutton) {
-                DRAWKDTREEBOOL = drawkdtreebutton;
-                //uHandeler.updateScreen();
-            }
-        });
+            DRAWKDTREE.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+                @Override
+                public void onCheckedChanged(CompoundButton compoundButton, boolean drawkdtreebutton) {
+                    DRAWKDTREEBOOL = drawkdtreebutton;
+                }
+            });
 
 
-        ADDLEFT.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                FRAMES--;
+            ADDLEFT.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    FRAMES--;
 
-                if (FRAMES < -TEXTUREWIDTH * TEXTUREWIDTH) {
-                    FRAMES = TEXTUREWIDTH * TEXTUREWIDTH;
-                }
+                    if (FRAMES < -TEXTUREWIDTH * TEXTUREWIDTH) {
+                        FRAMES = TEXTUREWIDTH * TEXTUREWIDTH;
+                    }
 
-                if (TILELAYER < 4) {
-                    MATERIALARRAY[SelectedMaterial].setLayer123(FRAMES);
-                    MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
-                    DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
-                } else {
-                    DISPLAYFRAMES.setText("Animationtime: " + String.valueOf(FRAMES) + "s");
-                    MATERIALARRAY[SelectedMaterial].setAnimationtime(FRAMES);
-                }
-
-                //uHandeler.updateScreen();
-            }
-        });
-        ADDRIGHT.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                FRAMES++;
+                    if (TILELAYER < TILELAYERSTART + 4) {
+                        MATERIALARRAY[SelectedMaterial].setLayer123(FRAMES);
+                        MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
+                        DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
+                    } else {
+                        DISPLAYFRAMES.setText("Animationtime: " + String.valueOf(FRAMES) + "s");
+                        MATERIALARRAY[SelectedMaterial].setAnimationtime(FRAMES);
+                    }
+                }
+            });
+            ADDRIGHT.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    FRAMES++;
 
 
-                if (FRAMES > TEXTUREWIDTH * TEXTUREWIDTH) {
-                    FRAMES = -TEXTUREWIDTH * TEXTUREWIDTH;
-                }
+                    if (FRAMES > TEXTUREWIDTH * TEXTUREWIDTH) {
+                        FRAMES = -TEXTUREWIDTH * TEXTUREWIDTH;
+                    }
 
-                if (TILELAYER < 4) {
-                    MATERIALARRAY[SelectedMaterial].setLayer123(FRAMES);
-                    MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
-                    DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
-                } else {
-                    DISPLAYFRAMES.setText("Animationtime: " + String.valueOf(FRAMES) + "s");
-                    MATERIALARRAY[SelectedMaterial].setAnimationtime(FRAMES);
-                }
-            }
-        });
+                    if (TILELAYER < TILELAYERSTART + 4) {
+                        MATERIALARRAY[SelectedMaterial].setLayer123(FRAMES);
+                        MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
+                        DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
+                    } else {
+                        DISPLAYFRAMES.setText("Animationtime: " + String.valueOf(FRAMES) + "s");
+                        MATERIALARRAY[SelectedMaterial].setAnimationtime(FRAMES);
+                    }
+                }
+            });
 
-        MOVE_RIGHT.setOnClickListener(new View.OnClickListener() {
+            MOVE_RIGHT.setOnClickListener(new View.OnClickListener() {
 
-            @Override
-            public void onClick(View v) { //right bottomright
-                //camera.move(new Vector(movespeed * Math.cos(camera.RotationX), 0, -movespeed * Math.sin(camera.RotationX)));
-                camera.move2D(new Vector(movespeed, 0));
-            }
-        });
+                @Override
+                public void onClick(View v) { //right bottomright
+                    //camera.move(new Vector(movespeed * Math.cos(camera.RotationX), 0, -movespeed * Math.sin(camera.RotationX)));
+                    camera.move2D(new Vector(movespeed, 0));
+                }
+            });
 
-        MOVE_RIGHT.setOnTouchListener(new View.OnTouchListener() { //right bootomright
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                //camera.move(new Vector(movespeed * Math.cos(camera.RotationX), 0, -movespeed * Math.sin(camera.RotationX)));
-                camera.move2D(new Vector(movespeed, 0));
-                return true;
-            }
-        });
+            MOVE_RIGHT.setOnTouchListener(new View.OnTouchListener() { //right bootomright
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    //camera.move(new Vector(movespeed * Math.cos(camera.RotationX), 0, -movespeed * Math.sin(camera.RotationX)));
+                    camera.move2D(new Vector(movespeed, 0));
+                    return true;
+                }
+            });
 
-        MOVE_BACK.setOnClickListener(new View.OnClickListener() { //backwards bottommid
-            @Override
-            public void onClick(View v) {
-                //camera.move(new Vector(movespeed * Math.sin(camera.RotationX), 0, movespeed * Math.cos(camera.RotationX)));
-                camera.move2D(new Vector(0, movespeed));
-            }
-        });
+            MOVE_BACK.setOnClickListener(new View.OnClickListener() { //backwards bottommid
+                @Override
+                public void onClick(View v) {
+                    //camera.move(new Vector(movespeed * Math.sin(camera.RotationX), 0, movespeed * Math.cos(camera.RotationX)));
+                    camera.move2D(new Vector(0, movespeed));
+                }
+            });
 
-        MOVE_BACK.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) { //backwards bottommid
-                //camera.move(new Vector(movespeed * Math.sin(camera.RotationX), 0, movespeed * Math.cos(camera.RotationX)));
-                camera.move2D(new Vector(0, movespeed));
-                return true;
-            }
-        });
+            MOVE_BACK.setOnTouchListener(new View.OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) { //backwards bottommid
+                    //camera.move(new Vector(movespeed * Math.sin(camera.RotationX), 0, movespeed * Math.cos(camera.RotationX)));
+                    camera.move2D(new Vector(0, movespeed));
+                    return true;
+                }
+            });
 
 
-        MOVE_FORWARD.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) { //forward topmid
-                //camera.move(new Vector(-movespeed * Math.sin(camera.RotationX), 0, -movespeed * Math.cos(camera.RotationX)));
-                camera.move2D(new Vector(0, -movespeed));
-            }
-        });
-        MOVE_FORWARD.setOnTouchListener(new View.OnTouchListener() { //forward topmid
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                //camera.move(new Vector(-movespeed * Math.sin(camera.RotationX), 0, -movespeed * Math.cos(camera.RotationX)));
-                camera.move2D(new Vector(0, -movespeed));
-                return true;
-            }
-        });
+            MOVE_FORWARD.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) { //forward topmid
+                    //camera.move(new Vector(-movespeed * Math.sin(camera.RotationX), 0, -movespeed * Math.cos(camera.RotationX)));
+                    camera.move2D(new Vector(0, -movespeed));
+                }
+            });
+            MOVE_FORWARD.setOnTouchListener(new View.OnTouchListener() { //forward topmid
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    //camera.move(new Vector(-movespeed * Math.sin(camera.RotationX), 0, -movespeed * Math.cos(camera.RotationX)));
+                    camera.move2D(new Vector(0, -movespeed));
+                    return true;
+                }
+            });
 
-        MOVE_LEFT.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) { //left bottomleft
-                //camera.move(new Vector(-movespeed * Math.cos(camera.RotationX), 0, movespeed * Math.sin(camera.RotationX)));
-                camera.move2D(new Vector(-movespeed, 0));
-            }
-        });
-        MOVE_LEFT.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) { //left bottomleft
-                //camera.move(new Vector(-movespeed * Math.cos(camera.RotationX), 0, movespeed * Math.sin(camera.RotationX)));
-                camera.move2D(new Vector(-movespeed, 0));
-                return true;
-            }
-        });
+            MOVE_LEFT.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) { //left bottomleft
+                    //camera.move(new Vector(-movespeed * Math.cos(camera.RotationX), 0, movespeed * Math.sin(camera.RotationX)));
+                    camera.move2D(new Vector(-movespeed, 0));
+                }
+            });
+            MOVE_LEFT.setOnTouchListener(new View.OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) { //left bottomleft
+                    //camera.move(new Vector(-movespeed * Math.cos(camera.RotationX), 0, movespeed * Math.sin(camera.RotationX)));
+                    camera.move2D(new Vector(-movespeed, 0));
+                    return true;
+                }
+            });
 
-        MOVE_DOWN.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                //camera.move(new Vector(0, -movespeed, 0));
-                camera.move2D(new Vector(0, 0, movespeed / 5));
-            }
-        });
+            MOVE_DOWN.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    //camera.move(new Vector(0, -movespeed, 0));
+                    camera.move2D(new Vector(0, 0, movespeed / 5));
+                }
+            });
 
 
-        MOVE_DOWN.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                //camera.move(new Vector(0, -movespeed, 0));
-                camera.move2D(new Vector(0, 0, movespeed / 5));
-                return true;
-            }
-        });
+            MOVE_DOWN.setOnTouchListener(new View.OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    //camera.move(new Vector(0, -movespeed, 0));
+                    camera.move2D(new Vector(0, 0, movespeed / 5));
+                    return true;
+                }
+            });
 
-        MOVE_UP.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                //camera.move(new Vector(0, movespeed, 0));
-                camera.move2D(new Vector(0, 0, -movespeed / 5));
-            }
-        });
-        MOVE_UP.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                //camera.move(new Vector(0, movespeed, 0));
-                camera.move2D(new Vector(0, 0, -movespeed / 5));
-                return true;
-            }
-        });
+            MOVE_UP.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    //camera.move(new Vector(0, movespeed, 0));
+                    camera.move2D(new Vector(0, 0, -movespeed / 5));
+                }
+            });
+            MOVE_UP.setOnTouchListener(new View.OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    //camera.move(new Vector(0, movespeed, 0));
+                    camera.move2D(new Vector(0, 0, -movespeed / 5));
+                    return true;
+                }
+            });
 
-        if (!UHANDELERSTARTED) {
-            UHANDELERSTARTED = true;
-            RENDERER = new Thread(new Runnable() {
-                @Override
-                public void run() {
-                    Looper.prepare();
-                    UpdateHandler newUhandeler = new UpdateHandler();
-                    newUhandeler.run();
-                    //function one or whatever
-                }
-            });
-            RENDERER.start();
+            if (!UHANDELERSTARTED) {
+                UHANDELERSTARTED = true;
+                RENDERER = new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        Looper.prepare();
+                        UpdateHandler newUhandeler = new UpdateHandler();
+                        newUhandeler.run();
+                        //function one or whatever
+                    }
+                });
+                RENDERER.start();
 
-            TILEUPDATE = new Thread(new Runnable() {
-                @Override
-                public void run() {
-                    Looper.prepare();
-                    UpdateHandler newUhandeler = new UpdateHandler();
-                    newUhandeler.runTileUpdates();
-                    //function one or whatever
-                }
-            });
-            TILEUPDATE.start();
+                TILEUPDATE = new Thread(new Runnable() {
+                    @Override
+                    public void run() {
+                        Looper.prepare();
+                        UpdateHandler newUhandeler = new UpdateHandler();
+                        newUhandeler.runTileUpdates();
+                        //function one or whatever
+                    }
+                });
+                TILEUPDATE.start();
 
-        }
+            }
 
-        TILEEDIT.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                TILELAYER++;
-                if (TILELAYER > 6) {
-                    TILELAYER = 0;
-                }
-                if (TILELAYER == 0) {
-                    FILLTILES = FILLPLACE.isChecked();
-                    PLACETILE = !FILLPLACE.isChecked();
-                    TILEEDIT.setText("EDIT TILE");
-                    DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
-                    SeekbarALPHA.setVisibility(View.INVISIBLE);
-                    SeekbarRED.setVisibility(View.INVISIBLE);
-                    SeekbarGREEN.setVisibility(View.INVISIBLE);
-                    SeekbarBLUE.setVisibility(View.INVISIBLE);
-                    SeekbarANIMATON.setVisibility(View.INVISIBLE);
-                    ADDLEFT.setVisibility(View.INVISIBLE);
-                    ADDRIGHT.setVisibility(View.INVISIBLE);
-                    DISPLAYFRAMES.setVisibility(View.INVISIBLE);
-                } else if (TILELAYER < 4) {
-
-                    TILEEDIT.setText("LAYER: " + String.valueOf(TILELAYER));
-                    DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
-                    SeekbarALPHA.setVisibility(View.VISIBLE);
-                    SeekbarRED.setVisibility(View.VISIBLE);
-                    SeekbarGREEN.setVisibility(View.VISIBLE);
-                    SeekbarBLUE.setVisibility(View.VISIBLE);
-                    SeekbarANIMATON.setVisibility(View.INVISIBLE);
+            TILEEDIT.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View view) {
+                    TILELAYER++;
+                    if (TILELAYER > TILELAYERSTART + 6) {
+                        TILELAYER = 0;
+                    }
+                    if (TILELAYER == 0) {
+                        FILLTILES = FILLPLACE.isChecked();
+                        PLACETILE = !FILLPLACE.isChecked();
+                        TILEEDIT.setText("EDIT TILE");
+                        DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
+                        SeekbarALPHA.setVisibility(View.INVISIBLE);
+                        SeekbarRED.setVisibility(View.INVISIBLE);
+                        SeekbarGREEN.setVisibility(View.INVISIBLE);
+                        SeekbarBLUE.setVisibility(View.INVISIBLE);
+                        SeekbarANIMATON.setVisibility(View.INVISIBLE);
+                        ADDLEFT.setVisibility(View.INVISIBLE);
+                        ADDRIGHT.setVisibility(View.INVISIBLE);
+                        DISPLAYFRAMES.setVisibility(View.INVISIBLE);
+                    } else if (TILELAYER < TILELAYERSTART + 4) {
+                        if (TILELAYER == TILELAYERSTART) {
+                            TILEEDIT.setText("BACK");
+                        } else {
+                            TILEEDIT.setText("LAYER: " + String.valueOf(TILELAYER));
+                        }
+                        DISPLAYFRAMES.setText("Material: " + String.valueOf(FRAMES));
+                        SeekbarALPHA.setVisibility(View.VISIBLE);
+                        SeekbarRED.setVisibility(View.VISIBLE);
+                        SeekbarGREEN.setVisibility(View.VISIBLE);
+                        SeekbarBLUE.setVisibility(View.VISIBLE);
+                        SeekbarANIMATON.setVisibility(View.INVISIBLE);
 
-                    ADDLEFT.setVisibility(View.VISIBLE);
-                    ADDRIGHT.setVisibility(View.VISIBLE);
-                    DISPLAYFRAMES.setVisibility(View.VISIBLE);
-                    MATERIALARRAY[SelectedMaterial].UpdateSeekbarProgress();
+                        ADDLEFT.setVisibility(View.VISIBLE);
+                        ADDRIGHT.setVisibility(View.VISIBLE);
+                        DISPLAYFRAMES.setVisibility(View.VISIBLE);
+                        MATERIALARRAY[SelectedMaterial].UpdateSeekbarProgress();
 
-                } else {
-                    FILLTILES = false;
-                    PLACETILE = false;
-                    DISPLAYFRAMES.setText("Animationtime: " + String.valueOf(FRAMES) + "s");
-                    TILEEDIT.setText("ANIMATIONLAYER: " + String.valueOf(TILELAYER - 3));
-                    SeekbarANIMATON.setVisibility(View.VISIBLE);
-                }
+                    } else {
+                        FILLTILES = false;
+                        PLACETILE = false;
+                        DISPLAYFRAMES.setText("Animationtime: " + String.valueOf(FRAMES) + "s");
+                        TILEEDIT.setText("ANIMATIONLAYER: " + String.valueOf(TILELAYER - 3 - TILELAYERSTART));
+                        SeekbarANIMATON.setVisibility(View.VISIBLE);
+                    }
 
-            }
-        });
+                }
+            });
 
-        SeekbarALPHA.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                if (TILELAYER == 1 || TILELAYER == 4) {
-                    COLORTILELAYER1 = Color.argb(progress, Color.red(COLORTILELAYER1), Color.green(COLORTILELAYER1), Color.blue(COLORTILELAYER1));
-                } else if (TILELAYER == 2 || TILELAYER == 5) {
-                    COLORTILELAYER2 = Color.argb(progress, Color.red(COLORTILELAYER2), Color.green(COLORTILELAYER2), Color.blue(COLORTILELAYER2));
-                } else if (TILELAYER == 3 || TILELAYER == 6) {
-                    COLORTILELAYER3 = Color.argb(progress, Color.red(COLORTILELAYER3), Color.green(COLORTILELAYER3), Color.blue(COLORTILELAYER3));
-                }
+            SeekbarALPHA.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+                @Override
+                public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+
+                    if (TILELAYER == TILELAYERSTART) {
+                        COLORTILELAYER0 = Color.argb(progress, Color.red(COLORTILELAYER0), Color.green(COLORTILELAYER0), Color.blue(COLORTILELAYER0));
+                    } else if (TILELAYER == TILELAYERSTART + 1 || TILELAYER == TILELAYERSTART + 4) {
+                        COLORTILELAYER1 = Color.argb(progress, Color.red(COLORTILELAYER1), Color.green(COLORTILELAYER1), Color.blue(COLORTILELAYER1));
+                    } else if (TILELAYER == TILELAYERSTART + 2 || TILELAYER == TILELAYERSTART + 5) {
+                        COLORTILELAYER2 = Color.argb(progress, Color.red(COLORTILELAYER2), Color.green(COLORTILELAYER2), Color.blue(COLORTILELAYER2));
+                    } else if (TILELAYER == TILELAYERSTART + 3 || TILELAYER == TILELAYERSTART + 6) {
+                        COLORTILELAYER3 = Color.argb(progress, Color.red(COLORTILELAYER3), Color.green(COLORTILELAYER3), Color.blue(COLORTILELAYER3));
+                    }
 
-                MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
-                MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
 
-            }
+                }
 
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-            }
+                @Override
+                public void onStartTrackingTouch(SeekBar seekBar) {
+                }
 
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-            }
-        });
+                @Override
+                public void onStopTrackingTouch(SeekBar seekBar) {
+                }
+            });
 
-        SeekbarRED.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                if (TILELAYER == 1 || TILELAYER == 4) {
-                    COLORTILELAYER1 = Color.argb(Color.alpha(COLORTILELAYER1), progress, Color.green(COLORTILELAYER1), Color.blue(COLORTILELAYER1));
-                } else if (TILELAYER == 2 || TILELAYER == 5) {
-                    COLORTILELAYER2 = Color.argb(Color.alpha(COLORTILELAYER2), progress, Color.green(COLORTILELAYER2), Color.blue(COLORTILELAYER2));
-                } else if (TILELAYER == 3 || TILELAYER == 6) {
-                    COLORTILELAYER3 = Color.argb(Color.alpha(COLORTILELAYER3), progress, Color.green(COLORTILELAYER3), Color.blue(COLORTILELAYER3));
-                }
+            SeekbarRED.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+                @Override
+                public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+                    if (TILELAYER == TILELAYERSTART) {
+                        COLORTILELAYER0 = Color.argb(Color.alpha(COLORTILELAYER0), progress, Color.green(COLORTILELAYER0), Color.blue(COLORTILELAYER0));
+                    } else if (TILELAYER == TILELAYERSTART + 1 || TILELAYER == TILELAYERSTART + 4) {
+                        COLORTILELAYER1 = Color.argb(Color.alpha(COLORTILELAYER1), progress, Color.green(COLORTILELAYER1), Color.blue(COLORTILELAYER1));
+                    } else if (TILELAYER == TILELAYERSTART + 2 || TILELAYER == TILELAYERSTART + 5) {
+                        COLORTILELAYER2 = Color.argb(Color.alpha(COLORTILELAYER2), progress, Color.green(COLORTILELAYER2), Color.blue(COLORTILELAYER2));
+                    } else if (TILELAYER == TILELAYERSTART + 3 || TILELAYER == TILELAYERSTART + 6) {
+                        COLORTILELAYER3 = Color.argb(Color.alpha(COLORTILELAYER3), progress, Color.green(COLORTILELAYER3), Color.blue(COLORTILELAYER3));
+                    }
 
-                MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
-                MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
-            }
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
+                }
 
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-            }
+                @Override
+                public void onStartTrackingTouch(SeekBar seekBar) {
+                }
 
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-            }
-        });
+                @Override
+                public void onStopTrackingTouch(SeekBar seekBar) {
+                }
+            });
 
-        SeekbarGREEN.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                if (TILELAYER == 1 || TILELAYER == 4) {
-                    COLORTILELAYER1 = Color.argb(Color.alpha(COLORTILELAYER1), Color.red(COLORTILELAYER1), progress, Color.blue(COLORTILELAYER1));
-                } else if (TILELAYER == 2 || TILELAYER == 5) {
-                    COLORTILELAYER2 = Color.argb(Color.alpha(COLORTILELAYER2), Color.red(COLORTILELAYER2), progress, Color.blue(COLORTILELAYER2));
-                } else if (TILELAYER == 3 || TILELAYER == 6) {
-                    COLORTILELAYER3 = Color.argb(Color.alpha(COLORTILELAYER3), Color.red(COLORTILELAYER3), progress, Color.blue(COLORTILELAYER3));
-                }
+            SeekbarGREEN.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+                @Override
+                public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+                    if (TILELAYER == TILELAYERSTART) {
+                        COLORTILELAYER0 = Color.argb(Color.alpha(COLORTILELAYER0), Color.red(COLORTILELAYER0), progress, Color.blue(COLORTILELAYER0));
+                    } else if (TILELAYER == TILELAYERSTART + 1 || TILELAYER == TILELAYERSTART + 4) {
+                        COLORTILELAYER1 = Color.argb(Color.alpha(COLORTILELAYER1), Color.red(COLORTILELAYER1), progress, Color.blue(COLORTILELAYER1));
+                    } else if (TILELAYER == TILELAYERSTART + 2 || TILELAYER == TILELAYERSTART + 5) {
+                        COLORTILELAYER2 = Color.argb(Color.alpha(COLORTILELAYER2), Color.red(COLORTILELAYER2), progress, Color.blue(COLORTILELAYER2));
+                    } else if (TILELAYER == TILELAYERSTART + 3 || TILELAYER == TILELAYERSTART + 6) {
+                        COLORTILELAYER3 = Color.argb(Color.alpha(COLORTILELAYER3), Color.red(COLORTILELAYER3), progress, Color.blue(COLORTILELAYER3));
+                    }
 
-                MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
-                MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
-            }
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
+                }
 
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-            }
+                @Override
+                public void onStartTrackingTouch(SeekBar seekBar) {
+                }
 
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-            }
-        });
+                @Override
+                public void onStopTrackingTouch(SeekBar seekBar) {
+                }
+            });
 
-        SeekbarBLUE.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                if (TILELAYER == 1 || TILELAYER == 4) {
-                    COLORTILELAYER1 = Color.argb(Color.alpha(COLORTILELAYER1), Color.red(COLORTILELAYER1), Color.green(COLORTILELAYER1), progress);
-                } else if (TILELAYER == 2 || TILELAYER == 5) {
-                    COLORTILELAYER2 = Color.argb(Color.alpha(COLORTILELAYER2), Color.red(COLORTILELAYER2), Color.green(COLORTILELAYER2), progress);
-                } else if (TILELAYER == 3 || TILELAYER == 6) {
-                    COLORTILELAYER3 = Color.argb(Color.alpha(COLORTILELAYER3), Color.red(COLORTILELAYER3), Color.green(COLORTILELAYER3), progress);
-                }
-                MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
-                MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
-            }
+            SeekbarBLUE.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+                @Override
+                public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+                    if (TILELAYER == TILELAYERSTART) {
+                        COLORTILELAYER0 = Color.argb(Color.alpha(COLORTILELAYER0), Color.red(COLORTILELAYER0), Color.green(COLORTILELAYER0), progress);
+                    } else if (TILELAYER == TILELAYERSTART + 1 || TILELAYER == TILELAYERSTART + 4) {
+                        COLORTILELAYER1 = Color.argb(Color.alpha(COLORTILELAYER1), Color.red(COLORTILELAYER1), Color.green(COLORTILELAYER1), progress);
+                    } else if (TILELAYER == TILELAYERSTART + 2 || TILELAYER == TILELAYERSTART + 5) {
+                        COLORTILELAYER2 = Color.argb(Color.alpha(COLORTILELAYER2), Color.red(COLORTILELAYER2), Color.green(COLORTILELAYER2), progress);
+                    } else if (TILELAYER == TILELAYERSTART + 3 || TILELAYER == TILELAYERSTART + 6) {
+                        COLORTILELAYER3 = Color.argb(Color.alpha(COLORTILELAYER3), Color.red(COLORTILELAYER3), Color.green(COLORTILELAYER3), progress);
+                    }
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterial();//selected Material
+                    MATERIALARRAY[SelectedMaterial].UpdateMaterialTileset();
+                }
 
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-            }
+                @Override
+                public void onStartTrackingTouch(SeekBar seekBar) {
+                }
 
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-            }
-        });
+                @Override
+                public void onStopTrackingTouch(SeekBar seekBar) {
+                }
+            });
 
 
-        SeekbarANIMATON.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
-            @Override
-            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-                //UPDATETILESET = true;
-                ANIMATIONPROGRESSPERCENT = (((float) seekBar.getProgress()) / ((float) SeekbarANIMATON.getMax()));
-                ANIMATIONPROGRESS = seekBar.getProgress();
-                MATERIALARRAY[SelectedMaterial].UpdateAnimationSeekbarColor();
+            SeekbarANIMATON.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
+                @Override
+                public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
+                    ANIMATIONPROGRESSPERCENT = (((float) seekBar.getProgress()) / ((float) SeekbarANIMATON.getMax()));
+                    ANIMATIONPROGRESS = seekBar.getProgress();
+                    MATERIALARRAY[SelectedMaterial].UpdateAnimationSeekbarColor();
 
-            }
+                }
 
-            @Override
-            public void onStartTrackingTouch(SeekBar seekBar) {
-                UPDATETILESET = true;
-            }
+                @Override
+                public void onStartTrackingTouch(SeekBar seekBar) {
+                    UPDATETILESET = true;
+                }
 
-            @Override
-            public void onStopTrackingTouch(SeekBar seekBar) {
-                UPDATETILESET = false;
-            }
-        });
+                @Override
+                public void onStopTrackingTouch(SeekBar seekBar) {
+                    UPDATETILESET = false;
+                }
+            });
+        }
+        /**/
     }
 
+
+    /**/
     @Override
     public boolean onTouchEvent(MotionEvent event) {
+
         switch (event.getAction()) {
+            //case MotionEvent.ACTION_HOVER_ENTER:
+
             case MotionEvent.ACTION_DOWN:
 
+                TOUCHSTATE = 0;
 
-                Display display = getWindowManager().getDefaultDisplay();
-                android.graphics.Point size = new Point();
-                display.getSize(size);
-                WIDTHSCREEN = size.x;
-                HEIGHTSCREEN = size.y;
+                TOUCHCUSTOMBUTTONS = false;
 
-                if (WIDTH <= HEIGHT/* && WIDTHSCREEN > HEIGHTSCREEN*/) {
-                    int width = HEIGHT;
-                    HEIGHT = WIDTH;
-                    WIDTH = width;
-                } /* if (WIDTH < HEIGHT && WIDTHSCREEN > HEIGHTSCREEN)*/
+                TOUCHPOSITION = new Vector(event.getX(), event.getY());
+
+                if (OPENGL) { // update the custom buttons
+                    for (int i = 0; i < CUSTOMBUTTONSLIST.size(); i++) {
+                        CUSTOMBUTTONSLIST.get(i).UpdateButton();
+                    }
+                }
 
                 xmove2 = event.getX() - xmove;
                 ymove2 = event.getY() - ymove;
+
+
                 camera.move(-xmove2 + event.getX(), -ymove2 + event.getY());
 
-
-                if (DISPLAYINVENTORY) {
-                    LE.setSelectTilefromInventory(event.getX(), event.getY());
-                } else {
+                if ((OPENGL && !TOUCHCUSTOMBUTTONS) || !OPENGL) {
+                    if (DISPLAYINVENTORY) {
+                        LE.setSelectTilefromInventory(event.getX(), event.getY());
+                    } else {
 
-                    KDTREECURRENTLYBUILDING = true;
-                    if (FILLTILES) { // Starts the Boundarie to place many Tiles
-                        LE.StartFillingTile((int) event.getX(), (int) event.getY());
-                    }
-                    if (!DESTROYTILES) { // Removes many Tiles
-                        if (PLACETILE) {
-                            LE.PlaceSelectedTile((int) event.getX(), (int) event.getY());
-                        }
-                    } else {
-                        if (PLACETILE) { // removes single Tile
-                            LE.RemoveTileKDTREE((int) event.getX(), (int) event.getY());
-                        }
-                    }
+                        KDTREECURRENTLYBUILDING = true;
+                        if (FILLTILES) { // Starts the Boundarie to place many Tiles
+                            LE.StartFillingTile((int) event.getX(), (int) event.getY());
+                        }
+                        if (!DESTROYTILES) { // Removes many Tiles
+                            if (PLACETILE) {
+                                LE.PlaceSelectedTile((int) event.getX(), (int) event.getY());
+                            }
+                        } else {
+                            if (PLACETILE) { // removes single Tile
+                                LE.RemoveTileKDTREE((int) event.getX(), (int) event.getY());
+                            }
+                        }
 
-                    KDTREECURRENTLYBUILDING = false;
+                        KDTREECURRENTLYBUILDING = false;
+                    }
                 }
-
-
-                //uHandeler.updateScreen();
 
                 break;
             case MotionEvent.ACTION_MOVE:
 
+                TOUCHSTATE = 1;
+
+                TOUCHCUSTOMBUTTONS = false;
+                if (OPENGL) { // update the custom buttons
+                    for (int i = 0; i < CUSTOMBUTTONSLIST.size(); i++) {
+                        CUSTOMBUTTONSLIST.get(i).UpdateButton();
+                    }
+                }
+
+                TOUCHPOSITION = new Vector(event.getX(), event.getY());
+
                 xmove = event.getX() - xmove2;
                 ymove = event.getY() - ymove2;
 
                 camera.move(xmove, ymove);
 
-
-                if (DISPLAYINVENTORY) {
-                    LE.setSelectTilefromInventory(event.getX(), event.getY());
-                } else {
+                if ((OPENGL && !TOUCHCUSTOMBUTTONS) || !OPENGL) {
+                    if (DISPLAYINVENTORY) {
+                        LE.setSelectTilefromInventory(event.getX(), event.getY());
+                    } else {
 
-                    KDTREECURRENTLYBUILDING = true;
-                    if (FILLTILES) { // Tileboundarie
-                        FILLTILERECT = LE.GetFillBoundaries((int) event.getX(), (int) event.getY());
-                    }
+                        KDTREECURRENTLYBUILDING = true;
+                        if (FILLTILES) { // Tileboundarie
+                            FILLTILERECT = LE.GetFillBoundaries((int) event.getX(), (int) event.getY());
+                        }
 
-                    if (!DESTROYTILES) {
-                        if (PLACETILE) {// Adds single Tile
-                            LE.PlaceSelectedTile((int) event.getX(), (int) event.getY());
-                        }
+                        if (!DESTROYTILES) {
+                            if (PLACETILE) {// Adds single Tile
+                                LE.PlaceSelectedTile((int) event.getX(), (int) event.getY());
+                            }
 
-                    } else {
-                        if (PLACETILE) {// Removes single Tiles
-                            LE.RemoveTileKDTREE((int) event.getX(), (int) event.getY());
-                        }
-                    }
+                        } else {
+                            if (PLACETILE) {// Removes single Tiles
+                                LE.RemoveTileKDTREE((int) event.getX(), (int) event.getY());
+                            }
+                        }
 
-                    KDTREECURRENTLYBUILDING = false;
+                        KDTREECURRENTLYBUILDING = false;
+                    }
                 }
 
                 DRAWFILLTILERECT = true;
 
-                //UpdateHandler updateHandler = new UpdateHandler();
-                //updateHandler.updateScreen();
-
                 break;
             case MotionEvent.ACTION_UP:
+
+                TOUCHSTATE = 2;
+
+                //TOUCHCUSTOMBUTTONS = false;
+                //if (OPENGL) { // update the custom buttons
+                //    for (int i = 0; i < CUSTOMBUTTONSLIST.size(); i++) {
+                //        CUSTOMBUTTONSLIST.get(i).UpdateButton();
+                //    }
+                //}
                 camera.move(xmove, ymove);
-                //Toast.makeText(getApplicationContext(), "X: " + camera.getW().getX() + " " + "Y: " + camera.getW().getY() + " " + "Z: " + camera.getW().getZ() + " " + "Length: " + camera.getW().length(), Toast.LENGTH_SHORT).show();
-                //Toast.makeText(getApplicationContext(), "X: " + camera.getEye().getX() + " " + "Y: " + camera.getEye().getY() + " " + "Z: " + camera.getEye().getZ(), Toast.LENGTH_SHORT).show();
-                if (FRAMETIME > 0 && DISPAYTOAST) {
-                    Toast.makeText(getApplicationContext(), "FRAMERATE: " + (1000 / FRAMETIME) + " FPS", Toast.LENGTH_SHORT).show();
-                }
-                if (DISPLAYINVENTORY) LE.SELECTEDTILEIDINVENTORY();
-                else {
+
+                if ((OPENGL && !TOUCHCUSTOMBUTTONS) || !OPENGL) {
+                    if (DISPLAYINVENTORY) {
+                        LE.SELECTEDTILEIDINVENTORY();
+                    } else {
 
-                    KDTREECURRENTLYBUILDING = true;
-                    if (FILLTILES) {
-                        if (!DESTROYTILES) {
-                            LE.FillingTiles((int) event.getX(), (int) event.getY());
-                        } else {
-                            LE.RemoveTilesKDTREE((int) event.getX(), (int) event.getY());
-                        }
-                    }
+                        KDTREECURRENTLYBUILDING = true;
+                        if (FILLTILES) {
+                            if (!DESTROYTILES) {
+                                LE.FillingTiles((int) event.getX(), (int) event.getY());
+                            } else {
+                                LE.RemoveTilesKDTREE((int) event.getX(), (int) event.getY());
+                            }
+                        }
 
-                    KDTREECURRENTLYBUILDING = false;
+                        KDTREECURRENTLYBUILDING = false;
+                    }
                 }
                 DRAWFILLTILERECT = false;
-
-
-                //uHandeler.updateScreen();
-                //Toast.makeText(getApplicationContext(), String.valueOf((float) camera.getEye2D().getValue(2) / ZOOMFACTOR), Toast.LENGTH_SHORT).show();
                 break;
         }
         return true;
     }
+
 }
Index: app/src/main/java/com/jacobjacob/ttproject/Generate.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Generate.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Generate.java	(date 1567859062256)
@@ -1,5 +1,7 @@
 package com.jacobjacob.ttproject;
 
+import com.jacobjacob.ttproject.Tile.Tile;
+
 import java.util.ArrayList;
 
 import static com.jacobjacob.ttproject.Util.FRAMES;
Index: app/src/main/java/com/jacobjacob/ttproject/Tile.java
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Tile.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Tile/Tile.java	(date 1567859062405)
@@ -1,10 +1,17 @@
-package com.jacobjacob.ttproject;
+package com.jacobjacob.ttproject.Tile;
 
 import android.graphics.Bitmap;
 import android.graphics.Rect;
 
+import com.jacobjacob.ttproject.Vector;
+
+import static com.jacobjacob.ttproject.Util.HEIGHT;
+import static com.jacobjacob.ttproject.Util.HEIGHTSCREEN;
 import static com.jacobjacob.ttproject.Util.TILESIZE;
 import static com.jacobjacob.ttproject.Util.TILETEXTURE;
+import static com.jacobjacob.ttproject.Util.WIDTHSCREEN;
+import static com.jacobjacob.ttproject.Util.ZOOMFACTOR;
+import static com.jacobjacob.ttproject.Util.camera;
 
 //import static com.jacobjacob.ttproject.MainActivity.uHandeler;
 
@@ -48,6 +55,29 @@
         }
     }
 
+    public boolean isOnScreen(){
+
+
+        Vector Cal = new Vector().getScreencoordinatesFromTileCoordinates(this.getPosition());
+        float TILESIZEzoom = (float) Math.ceil(TILESIZE * (camera.getEye2D().getValue(2) / ZOOMFACTOR));
+
+
+        int left = (int) Cal.getValue(0);//(float) visible.get(i).getPositionRAW().getX() * Scale;//width / height;
+        int top = (int) Cal.getValue(1);//(float) visible.get(i).getPositionRAW().getY() * Scale;
+        int right = (int) (Cal.getValue(0) + TILESIZEzoom);//(float) (visible.get(i).getPositionRAW().getX() + 1) * Scale;
+        int bottom = (int) (Cal.getValue(1) + TILESIZEzoom);//(float) (visible.get(i).getPositionRAW().getY() + 1) * Scale;
+
+        Rect TileRect = new Rect(left,top,right,bottom);
+
+        Rect Screen = new Rect(0,0,WIDTHSCREEN,HEIGHTSCREEN);
+
+        if (Screen.contains(TileRect) || Screen.intersect(TileRect)) {
+            return true;
+        }else {
+            return false;
+        }
+    }
+
     public Vector getPosition() {
         return this.Position;
 
Index: app/src/main/java/com/jacobjacob/ttproject/Move.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Move.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Move.java	(date 1567599339061)
@@ -17,6 +17,9 @@
     public void Move(Vector direction) {
 
         Vector directionoriginal = direction;
+
+        directionoriginal.setX((float)(direction.getValue(0) / 2));
+        directionoriginal.setY((float)(direction.getValue(1) / 2));
         directionoriginal.setZ((float)(direction.getValue(2) * 20));
 
         //Collisionscale = 100;
Index: app/src/main/java/com/jacobjacob/ttproject/Portal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Portal.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Portal.java	(date 1567859062056)
@@ -3,6 +3,8 @@
 import android.graphics.Rect;
 import android.util.Log;
 
+import com.jacobjacob.ttproject.Tile.Tile;
+
 import java.util.ArrayList;
 
 import static com.jacobjacob.ttproject.Util.KDTREECOPY;
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(date 1564787735000)
+++ app/src/main/AndroidManifest.xml	(date 1566821221634)
@@ -1,7 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.jacobjacob.ttproject">
-
+    package="com.jacobjacob.ttproject"
+    android:versionCode="1"
+    android:versionName="1.0">
     <application
         android:allowBackup="true"
         android:icon="@mipmap/ic_launcher"
@@ -11,6 +12,8 @@
         android:theme="@style/AppTheme"
         android:screenOrientation="landscape"
         android:hardwareAccelerated="true"
+        android:minSdkVersion="18"
+
         >
 
         <activity android:name=".MainActivity">
Index: app/src/main/java/com/jacobjacob/ttproject/Util.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/jacobjacob/ttproject/Util.java	(date 1564787735000)
+++ app/src/main/java/com/jacobjacob/ttproject/Util.java	(date 1567961631143)
@@ -10,6 +10,10 @@
 import android.widget.TextView;
 import android.widget.ToggleButton;
 
+import com.jacobjacob.ttproject.Input.CustomButtons;
+import com.jacobjacob.ttproject.Tile.KdTree;
+import com.jacobjacob.ttproject.Tile.Tile;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 
@@ -22,6 +26,8 @@
     public static int HEIGHTSCREEN;
     public static int SEED = 24512654;
 
+    public static boolean OPENGL;
+    public static boolean SETTINGS_OPENGL;
 
     //public static double  EPSILON = 0.04;
 
@@ -43,6 +49,7 @@
     public static Button MOVE_BACK;
     public static Button MOVE_RIGHT;
     public static ToggleButton INVENTORY_TOGGLE;
+    public static ToggleButton OPENGL_TOGGLE;
     public static ToggleButton FILLPLACE;
     public static ToggleButton DRAWKDTREE;
     public static ToggleButton REMOVETILES;
@@ -56,6 +63,12 @@
     public static Generate GENERATE = new Generate();
     public static OpenSimplexNoise NOISE = new OpenSimplexNoise(SEED);
 
+    public static Vector TOUCHPOSITION = new Vector();
+    public static boolean TOUCHCUSTOMBUTTONS = false;
+
+    public static int TOUCHSTATE = 0; // 0 == Touch down | 1 == Touchmoving | 2 == Touchup
+
+
     public static Vector Cameraposition = new Vector(0, 0, -320); // -10 tiletexture 1
     public static Vector CameraZ = new Vector(0, 0, 1);
     public static Camera camera = new Camera(Cameraposition, CameraZ);
@@ -98,10 +111,12 @@
 
     public static int TEXTUREWIDTH = 20;
 
-    public static String FILE_NAME = "newtextfile.txt";
+    public static String FILE_NAME = "lvla.txt";
+    public static String SETTINS_NAME = "settings.txt";
 
     public static ArrayList<String> FILE_NAMES = new ArrayList<>(Arrays.asList("lvla.txt", "lvlb.txt", "lvlc.txt", "lvld.txt", "lvle.txt"));
     public static Spinner LOADLVLSPINNER;
+    public static int LEVELINT = 0;
 
     /**
      * INVENTORY
@@ -114,8 +129,8 @@
     public static float INVENTORYDISPLAYSIZE = 4;
 
     public static LevelEditor LE = new LevelEditor();
-    public static WriteFile WF = new WriteFile();
-    public static ReadFile RF = new ReadFile();
+    public static com.jacobjacob.ttproject.Savefile.WriteFile WF = new com.jacobjacob.ttproject.Savefile.WriteFile();
+    public static com.jacobjacob.ttproject.Loadfile.ReadFile RF = new com.jacobjacob.ttproject.Loadfile.ReadFile();
 
     public static boolean DISPAYTOAST = false;
     public static boolean DISPLAYINVENTORY = false;
@@ -135,7 +150,10 @@
     public static int FILLTILECOLOR = Color.argb(150, 0, 255, 0);
 
     public static int TILELAYER = 0;
+    public static int TILELAYERSTART = 1;
 
+    public static int COLORDEBUG = Color.rgb(255, 255, 255);
+    public static int COLORTILELAYER0;// = Color.rgb(255,235,145);
     public static int COLORTILELAYER1;// = Color.rgb(255,235,145);
     public static int COLORTILELAYER2;// = Color.rgb(130,120,50);
     public static int COLORTILELAYER3;// = Color.rgb(150,200,70);
@@ -146,10 +164,16 @@
     //public static ArrayList<Material> MATERIALARRAY = new ArrayList<>();
     public static Bitmap[][] MATERIALLIST;
     public static Bitmap[][] MATERIALLISTUPDATING;
+    public static Bitmap[][] MATERIALNORMALS;
+
+
     public static Material[] MATERIALARRAY = new Material[TEXTUREWIDTH * TEXTUREWIDTH];
     public static Material STARTINGMATERIAL = new Material(1, 0, 0, 0, Color.argb(255, 120, 170, 100), Color.argb(255, 174, 160, 108), Color.argb(255, 10, 255, 255));
     public static boolean UPDATETILESET = false;
 
+    public static boolean CREATEFASTNORMALS = true;
+    public static float NORMALSTRENGTH = 0.2f; //0.5f
+
     public static KdTree KDTREE = new KdTree();
     public static KdTree KDTREECOPY = KDTREE;
     public static int KDTREEMAXITEMS = 80;
@@ -166,4 +190,6 @@
     public static boolean BOTHPORTALSACTIVE = true;
 
     public static Rect HITBOX;
+
+    public static ArrayList<CustomButtons> CUSTOMBUTTONSLIST = new ArrayList<>();
 }
diff --git app/src/main/res/drawable-v24/tilemap.png app/src/main/res/drawable-v24/tilemap.png
index 1a7029989de08dc47f9bb004eea1a04642f281d7..b5c457218f36b58a2b69c0f68fc73685cc017ecb
GIT binary patch
literal 851402
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

diff --git .idea/caches/gradle_models.ser .idea/caches/gradle_models.ser
index e3aeacbc68f95e361f01268c3b8f763c867019e7..8e1ef17fd570a730f9b2948c06bf9de9be930b15
GIT binary patch
literal 124781
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
ahx=}_zKBlL6+Y@w;B&W-U=6-L{{H|YPcQ!f

